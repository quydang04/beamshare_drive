import External from "../../core/External";
import Messages from "../../utils/messages";
import $ from "jquery";
import util from "../../util";
const glob_color = util.glob_color;
/**
 * Function to return App element
 */
function rootElement(element) {
  const el = document.createElement("div");

  let root;

  if (typeof element === "string") {
    root = document.getElementById(element);
  } else {
    root = element;
  }

  root.innerHTML = "";
  root.appendChild(el);

  root.style.width = "auto";

  return el;
}

/**
 * Function to configure application with callbacks
 * @param {object} params
 */
function configureApplication(params) {
  const options = {
    alert: m => console.log(m), // Noop for demo: window.alert(m)
    messages: { ...Messages, ...params.messages },
    onSubmitCompletion: params.onSubmitCompletion ? params.onSubmitCompletion : External.onSubmitCompletion,
    onUpdateCompletion: params.onUpdateCompletion ? params.onUpdateCompletion : External.onUpdateCompletion,
    onDeleteCompletion: params.onDeleteCompletion ? params.onDeleteCompletion : External.onDeleteCompletion,
    onSkipTask: params.onSkipTask ? params.onSkipTask : External.onSkipTask,
    onSubmitDraft: params.onSubmitDraft || External.onSubmitDraft,
    onTaskLoad: params.onTaskLoad ? params.onTaskLoad : External.onTaskLoad,
    onLabelStudioLoad: params.onLabelStudioLoad ? params.onLabelStudioLoad : External.onLabelStudioLoad,
    onEntityCreate: params.onEntityCreate || External.onEntityCreate,
    onEntityDelete: params.onEntityDelete || External.onEntityDelete,
    onGroundTruth: params.onGroundTruth || External.onGroundTruth,
    onSelectCompletion: params.onSelectCompletion || External.onSelectCompletion,
  };

  return options;
}
function role_sync(role) {
  if (role === "tester") {
    $("#tagging").show();
    $("#reset_random").remove();
    $("#reset_skip").remove();
    $("#random").show();
  } else if (role === "chargehand" || role === "grouper") {
    $("#random").remove();
    $("#reset_random").remove();
    $("#reset_skip").remove();
    $("#tagging").show();
  } else if (role === "admin") {
    $("#tagging").show();
    $("#random").show();
    $("#reset_random").show();
    $("#reset_skip").show();
  }
}
function image_object_detection_handle(ls, completion) {
  let completions_tem_back = [];
  let stageWidth = ls.completionStore.root.children[0].stageWidth;
  let stageHeight = ls.completionStore.root.children[0].stageHeight;
  completion.areas.forEach(v => {
    let obj = {
      id: v.id,
      from_name: "label",
      source: "$image",
      to_name: "image",
      type: "rectanglelabels",
      normInput: v.normInput,
      normalization: v.normalization,
      value: {
        x: (v.x / stageWidth) * 100,
        y: (v.y / stageHeight) * 100,
        width: (v.width / stageWidth) * 100,
        height: (v.height / stageHeight) * 100,
        rotation: (v.rotation + 360) % 360,
        rectanglelabels: v.results[0].value.rectanglelabels.toJSON(),
      },
    };
    completions_tem_back.push(obj);
  });
  return completions_tem_back;
}
function image_polygon_segmentation_handle(completion) {
  let completions_tem_back = [];
  completion.areas.forEach(v => {
    let points = [];
    for (let s of v.points) {
      points.push([s.relativeX, s.relativeY]);
    }
    let labels = v.results[0].value.polygonlabels.toJSON();
    let obj = {
      id: v.id,
      from_name: "label",
      to_name: "image",
      source: "$image",
      type: "polygonlabels",
      normInput: v.normInput,
      normalization: v.normalization,
      parent_id: null,
      value: {
        points: points,
        polygonlabels: labels,
      },
      image_rotation: 0,
    };
    completions_tem_back.push(obj);
  });
  return completions_tem_back;
}

/**
 * ner 类型任务配置初始化
 * @param {Array} completions
 * @return {Array} completions format
 */
function ner_handle(completion) {
  let completions_tem_back = [];
  completion.areas.forEach(v => {
    let obj = {
      id: v.id,
      from_name: "ner",
      source: "$text",
      to_name: "text",
      type: "labels",
      value: {
        end: v.end,
        labels: v.results[0].value.labels.toJSON(),
        start: v.start,
        text: v.text,
      },
    };
    completions_tem_back.push(obj);
  });
  return completions_tem_back;
}
function text_classification(completion) {
  let completions_tem_back = [];
  completion.areas.forEach(v => {
    completions_tem_back = v.results.toJSON();
  });
  return completions_tem_back;
}

function classify_summary_handle(completion) {
  let completions_tem_back = [];
  completion.areas.forEach(v => {
    completions_tem_back.push(...v.results.toJSON());
  });
  return completions_tem_back;
}

function ner_with_tag_handle(completion) {
  let completions_tem_back = [];
  completion.areas.forEach(v => {
    let obj = {
      id: v.id,
      from_name: "ner",
      source: "$text",
      to_name: "text",
      type: "hypertextlabels",
      value: {
        start: v.start,
        end: v.end,
        startOffset: v.startOffset,
        endOffset: v.endOffset,
        htmllabels: v.results[0].value.htmllabels.toJSON(),
        text: v.text,
      },
    };
    completions_tem_back.push(obj);
  });
  return completions_tem_back;
}
function image_span_label_handle(completion) {
  let completions_tem_back = [];
  completion.areas.forEach(v => {
    completions_tem_back = v.results.toJSON();
  });
  return completions_tem_back;
}
function ner_relation_handle(completion) {
  let completions_tem_back = [];
  completion.areas.forEach(v => {
    let obj = {
      id: v.id,
      from_name: "ner",
      source: "$text",
      to_name: "text",
      type: "labels",
      value: {
        end: v.end,
        labels: v.results[0].value.labels.toJSON(),
        start: v.start,
        text: v.text,
      },
    };
    completions_tem_back.push(obj);
  });
  for (let k of completion.relationStore.relations) {
    let relation_labels = [];
    for (let d of k.relations.children) {
      if (d.selected) {
        relation_labels.push(d.value);
      }
    }
    let obj = {
      from_id: k.node1.id,
      to_id: k.node2.id,
      type: "relation",
      labels: relation_labels,
      direction: k.direction,
    };
    completions_tem_back.push(obj);
  }
  return completions_tem_back;
}

function ner_html_relation_handle(completion) {
  let completions_tem_back = [];
  completion.areas.forEach(v => {
    let obj = {
      id: v.id,
      from_name: "ner",
      source: "$text",
      to_name: "text",
      type: "hypertextlabels",
      value: {
        start: v.start,
        end: v.end,
        startOffset: v.startOffset,
        endOffset: v.endOffset,
        htmllabels: v.results[0].value.htmllabels.toJSON(),
        text: v.text,
      },
    };
    completions_tem_back.push(obj);
  });

  for (let k of completion.relationStore.relations) {
    let relation_labels = [];
    for (let d of k.relations.children) {
      if (d.selected) {
        relation_labels.push(d.value);
      }
    }
    let obj = {
      from_id: k.node1.id,
      to_id: k.node2.id,
      type: "relation",
      labels: relation_labels,
      direction: k.direction,
    };
    completions_tem_back.push(obj);
  }
  return completions_tem_back;
}

function text_summary_handle(completion) {
  let completions_tem_back = [];
  completion.areas.forEach(v => {
    let obj = {
      id: v.id,
      from_name: "answer",
      to_name: "text",
      type: "textarea",
      meta: {
        lead_time: Math.random().toFixed(3),
      },
      value: {
        text: v.results[0].value.text.toJSON(),
      },
    };
    completions_tem_back.push(obj);
  });
  return completions_tem_back;
}

async function bbox_created(region) {
  let chosen_text = $("#chosen_option").text();
  console.log(window.Htx)
  if (window.Bbox && window.Bbox.length > 0 && chosen_text === "自调整") {
    let ls = JSON.parse(JSON.stringify(window.Htx.completionStore));
    console.log(window.Size)
    let size = window.Size[1]
    let scale = 1
    if (size > 750) {
      scale = 750 / size
    }
    let [x1, y1, x2, y2] = [region.x / scale, region.y / scale, (region.width + region.x) / scale, (region.height + region.y) / scale];
    let valid_box = batch_iou([x1, y1, x2, y2], window.Bbox);
    if (valid_box.length > 0) {
      let [x1_list, y1_list, x2_list, y2_list] = [[], [], [], []];
      valid_box.forEach(k => {
        x1_list.push(k[0]);
        y1_list.push(k[1]);
        x2_list.push(k[2]);
        y2_list.push(k[3]);
      });
      let new_box = [Math.min(...x1_list), Math.min(...y1_list), Math.max(...x2_list), Math.max(...y2_list)];
      let stageWidth = ls.root.children[0].stageWidth;
      let stageHeight = ls.root.children[0].stageHeight;
      let news_comps = [];
      for (let h in ls.completions[0].areas) {
        let completion = ls.completions[0].areas[h];
        if (h === region.id) {
          completion.x = new_box[0];
          completion.y = new_box[1];
          completion.width = new_box[2] - new_box[0];
          completion.height = new_box[3] - new_box[1];
        }
        let obj = {
          id: h,
          from_name: "label",
          source: "$image",
          to_name: "image",
          type: "rectanglelabels",
          normInput: completion.normInput,
          normalization: completion.normalization,
          value: {
            x: (completion.x / stageWidth) * 100,
            y: (completion.y / stageHeight) * 100,
            width: (completion.width / stageWidth) * 100,
            height: (completion.height / stageHeight) * 100,
            rotation: (completion.rotation + 360) % 360,
            rectanglelabels: completion.results[0].value.rectanglelabels,
          },
        };
        news_comps.push(obj);
      }
      window.Htx.resetState();
      // .settings.toggleContinuousLabeling()
      window.Htx.initializeStore({ completions: [{ result: news_comps }], predictions: [] });
    }
  }
  else if (chosen_text === "手动调整") {
    const img = JSON.parse(window.Htx.task.data).image
    let ls = JSON.parse(JSON.stringify(window.Htx.completionStore));
    let stageWidth = ls.root.children[0].stageWidth;
    let stageHeight = ls.root.children[0].stageHeight;
    let [x1, y1, x2, y2] = [region.x, region.y, region.width + region.x, region.height + region.y];
    let task_record = await util.axiosPostPromise(util.url + "name_entities/manual_adjust_bbox",{url: img,
      box: [(x1/ stageWidth) * 100, (y1/ stageHeight) * 100, (x2/ stageWidth) * 100, (y2/ stageHeight) * 100]});
    let news_comps = [];
    for (let h in ls.completions[0].areas) {
      let completion = ls.completions[0].areas[h];
      let obj = {
        id: h,
        from_name: "label",
        source: "$image",
        to_name: "image",
        type: "rectanglelabels",
        normInput: ls.completions[0].areas[h].normInput,
        normalization: ls.completions[0].areas[h].normalization,
        value: {
          x: (completion.x / stageWidth) * 100,
          y: (completion.y / stageHeight) * 100,
          width: (completion.width / stageWidth) * 100,
          height: (completion.height / stageHeight) * 100,
          rotation: (completion.rotation + 360) % 360,
          rectanglelabels: completion.results[0].value.rectanglelabels,
        },
      };
      if (h === region.id) {
        console.log( task_record.box[0], "1111")
        obj.value.x = task_record.box[0];
        obj.value.y = task_record.box[1];
        obj.value.width = task_record.box[2] - task_record.box[0];
        obj.value.height = task_record.box[3] - task_record.box[1];
        console.log(ls.completions[0].areas[h], "2334")
      }
      news_comps.push(obj);
    }
    window.Htx.resetState();
    window.Htx.initializeStore({ completions: [{ result: news_comps }], predictions: [] });
  }
}

function area(box) {
  if (box[0] >= box[2] || box[1] >= box[3]) return 0;
  return (box[2] - box[0]) * (box[3] - box[1]);
}

const maxOfX = rec => Math.max(rec[0], rec[2]);
const maxOfY = rec => Math.max(rec[1], rec[3]);
const minOfX = rec => Math.min(rec[0], rec[2]);
const minOfY = rec => Math.min(rec[1], rec[3]);

function is_overlap_and_area(rec1, rec2) {
  let overlappedRec = [];
  const NolappingFromX = maxOfX(rec1) <= minOfX(rec2) || minOfX(rec1) >= maxOfX(rec2);
  const NolappingFromY = maxOfY(rec1) <= minOfY(rec2) || minOfY(rec1) >= maxOfY(rec2);
  if (!(NolappingFromX || NolappingFromY)) {
    overlappedRec[0] = Math.max(minOfX(rec1), minOfX(rec2));
    overlappedRec[1] = Math.max(minOfY(rec1), minOfY(rec2));
    overlappedRec[2] = Math.min(maxOfX(rec1), maxOfX(rec2));
    overlappedRec[3] = Math.min(maxOfY(rec1), maxOfY(rec2));
  }
  return overlappedRec;
}

function batch_iou(region, boxes, thresh = 0.85) {
  const valid_boxes = [];
  boxes.forEach(v => {
    let overlap_box = is_overlap_and_area(region, v);
    if (overlap_box.length === 4 && area(overlap_box) / area(v) >= thresh) {
      valid_boxes.push(v);
    }
  });
  return valid_boxes;
}

function render_bbox_range(obj) {
  let boxes = obj.texts;
  let whole_boxes = [];
  for (let v of boxes) {
    whole_boxes.push(v.bbox);
  }
  return whole_boxes;
}

function ner_view(data) {
  let label_str = "";
  for (let i in data) {
    let c = data[i];
    label_str += `<Label value="${c.tag_name}"></Label>`;
  }
  return `<View>
               <Labels name="ner" toName="text">${label_str}</Labels>
               <Text name="text" value="$text"></Text>
          </View>`;
}

function classify_view(task_radio, data) {
  let label_str = "";
  for (let c of data) {
    label_str += `<Choice value="${c.tag_name}"></Choice>`;
  }
  let choice_type = "";
  if (task_radio === "1") {
    choice_type = "single";
  } else {
    choice_type = "multiple";
  }
  return `<View>
               <HyperText name="text" value="$text" clickableLinks="true"></HyperText>
               <Choices name="ner" toName="text" choice="${choice_type}" showInLine="true"> 
                  ${label_str}
               </Choices>
          </View>`;
}

function classify_summary_view(task_radio, data) {
  let label_str = "";
  for (let c of data) {
    label_str += `<Choice value="${c.tag_name}"></Choice>`;
  }
  let choice_type = "";
  if (task_radio === "1") {
    choice_type = "single";
  } else {
    choice_type = "multiple";
  }
  return `<View>
               <HyperText name="text" value="$text" clickableLinks="true"></HyperText>
               <Choices name="ner" toName="text" choice="${choice_type}" showInLine="true"> 
                  ${label_str}
               </Choices>
               <TextArea name="answer" toName="text"  showSubmitButton="true" maxSubmissions="1" editable="true"></TextArea>
          </View>`;
}

function object_detection_view(data) {
  let label_str = "";
  for (let i in data) {
    let c = data[i];
    label_str += `<Label value="${c.tag_name}"  background="${util.colors[i]}"></Label>`;
  }
  return `<View>
                            <Image name="image" value="$image" zoom="true" negativeZoom="false"
                            rotateControl="true" zoomControl="true"/>
                            <RectangleLabels name="label" toName="image">
                               ${label_str}
                            </RectangleLabels>
                         </View>`;
}

function keypoints_view(data) {
  let label_str = "";
  for (let i in data) {
    let c = data[i];
    label_str += `<Label value="${c.tag_name}"  background="${util.colors[i]}"></Label>`;
  }
  return `<View>
                           <Image name="image" value="$image" zoom="true" negativeZoom="true" zoomControl="true"/>
                            <PolygonLabels name="label" toName="image">
                               ${label_str}
                            </PolygonLabels>
                         </View>`;
}

function image_summary_view() {
  return `<View>
                              <Text name="text" value="$text" />    
                              <Image name="image" value="$image"/>   
                              <Header value="Provide result" />              
                              <TextArea name="answer" toName="text"  showSubmitButton="true" maxSubmissions="1" editable="true"
                                       />
                           </View>`;
}

function ner_relation_view(re_data, ta_data) {
  let Relations = "";
  let relation_str = "";
  let label_str = "";
  for (let i in re_data) {
    let v = re_data[i];
    relation_str += `<Relation value="${v.relation_name}" background="${glob_color[i]}"/>`;
  }
  if (relation_str !== "") {
    Relations = `<Relations>${relation_str}</Relations>`;
  }
  for (let i in ta_data) {
    let c = ta_data[i];
    label_str += `<Label value="${c.tag_name}"/>`;
  }
  return `<View>
                           ${Relations}
                          <Labels name="ner" toName="text"> 
                          ${label_str}
                          </Labels>
                          <Style>.htx-text{ line-height: 3 }</Style>
                          <Text name="text" value="$text" ></Text>
                       </View>`;
}

function ner_with_html_view(data) {
  let label_str = "";
  for (let i in data) {
    let c = data[i];
    label_str += `<Label value="${c.tag_name}"></Label>`;
  }
  return `<View>
                          <HyperTextLabels name="ner" toName="text">
                          ${label_str}
                          </HyperTextLabels>
                            <View style="border: 1px solid #CCC;
                                         border-radius: 10px;
                                         padding: 5px;">
                            <HyperText  name="text" value="$text"/>
                          </View>
                       </View>`;
}

function text_summary_view(config_rows, labels) {
  let labels_sum = "";
  if (labels !== "") {
    labels_sum += `<View style="padding: 0 0em; width: 20px; margin-left: 0.5em; margin-right: 20px; border-radius: 3px">
                               <Header value="${labels}" />
                            </View>`;
  }
  return `<View>
                          <HyperText name="text" value="$text" ></HyperText>
                          <Header value="Please provide summary" />
                          <View style="display: flex;">
                            ${labels_sum}
                            <TextArea name="answer" toName="text" showSubmitButton="true" 
                             maxSubmissions="1"  rows="${config_rows}" editable="true"  />
                           </View>
                       </View>`;
}

function ner_with_html_relation_view(re_data, ta_data) {
  let Relations = "";
  let relation_str = "";
  let label_str = "";
  for (let i in re_data) {
    let v = re_data[i];
    relation_str += `<Relation value="${v.relation_name}" background="${glob_color[i]}"/>`;
  }
  if (relation_str !== "") {
    Relations = `<Relations>${relation_str}</Relations>`;
  }
  for (let i in ta_data) {
    let c = ta_data[i];
    label_str += `<Label value="${c.tag_name}"/>`;
  }
  return `<View>
                             ${Relations}
                            <HyperTextLabels name="ner" toName="text"> 
                            ${label_str}
                            </HyperTextLabels>
                            <Style>.htx-text{ line-height: 3 }</Style>
                            <HyperText name="text" value="$text" ></HyperText>
                         </View>`;
}
export default {
  rootElement,
  role_sync,
  configureApplication,
  ner_handle,
  image_object_detection_handle,
  image_polygon_segmentation_handle,
  text_classification,
  ner_with_tag_handle,
  image_span_label_handle,
  ner_relation_handle,
  ner_html_relation_handle,
  text_summary_handle,
  bbox_created,
  ner_view,
  classify_view,
  object_detection_view,
  keypoints_view,
  image_summary_view,
  ner_relation_view,
  ner_with_html_view,
  text_summary_view,
  render_bbox_range,
  ner_with_html_relation_view,
  classify_summary_view,
  classify_summary_handle,
};
