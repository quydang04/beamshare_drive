{"version":3,"file":"index.js","sources":["../../../../../../../../../node_modules/.pnpm/@codemirror+search@6.5.6/node_modules/@codemirror/search/dist/index.js"],"sourcesContent":["import { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';\nimport elt from 'crelt';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: end };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: end };\n            else\n                this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))\n            match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length)\n                    this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\n                    (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\", value: line });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: 'center' })],\n            selection,\n        });\n        view.focus();\n    }\n    return { dom };\n}\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) &&\n                    insideWord(check, state, range.from, range.to)))\n                    return Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query)\n                    return Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n        effects: EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: view => new SearchPanel(view),\n            scrollToMatch: range => EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */\n    unquote(text) {\n        return this.literal ? text :\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\n            this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n    getCursor(state, from = 0, to) {\n        let st = state.doc ? state : EditorState.create({ doc: state });\n        if (to == null)\n            to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos) => {\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||\n            categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&\n            (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||\n                categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done)\n            cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* FindPrev.ChunkSize */;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice(findClusterBreak(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, findClusterBreak(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match) => !match[0].length ||\n        (categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||\n            categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &&\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||\n                categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m);\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next)\n        return false;\n    let selection = EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev)\n        return false;\n    let selection = EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let next = query.nextMatch(state, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes, selection, effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = getPanel(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement)\n        input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Mod-Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = elt(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = elt(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return elt(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = elt(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            elt(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\n            ...view.state.readOnly ? [] : [\n                elt(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\n            ],\n            elt(\"button\", {\n                name: \"close\",\n                onclick: () => closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\"Ã—\"])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value,\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if (runScopeHandlers(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.low(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };\n"],"names":["basicNormalize","x","SearchCursor","text","query","from","to","normalize","test","codePointAt","next","str","fromCodePoint","start","codePointSize","norm","i","pos","code","match","end","index","keep","empty","baseFlags","RegExpCursor","options","MultilineRegExpCursor","startLine","toCharEnd","skip","off","flattened","FlattenedDoc","doc","cached","flat","cachedFrom","validRegExp","source","line","createLineDialog","view","input","elt","dom","event","dialogEffect","go","state","sign","ln","cl","percent","col","pc","docLine","selection","EditorSelection","EditorView","StateEffect","dialogField","StateField","value","tr","e","f","showPanel","val","gotoLine","panel","getPanel","effects","baseTheme$1","defaultHighlightOptions","highlightConfig","Facet","combineConfig","a","b","highlightSelectionMatches","defaultTheme","matchHighlighter","matchDeco","Decoration","mainMatchDeco","insideWordBoundaries","check","CharCategory","insideWord","ViewPlugin","update","conf","sel","range","word","len","deco","part","cursor","v","selectWord","dispatch","newSel","findNextOccurrence","main","ranges","fullWord","cycled","r","selectNextOccurrence","searchedText","searchConfigFacet","configs","SearchPanel","SearchQuery","config","_","ch","other","RegExpQuery","StringQuery","st","EditorState","regexpCursor","stringCursor","QueryType","spec","stringWordTest","categorizer","buf","bufPos","charBefore","charAfter","curFrom","curTo","_result","limit","add","regexpWordTest","findClusterBreak","_from","_to","size","result","m","setSearchQuery","togglePanel","searchState","SearchState","defaultQuery","effect","createSearchPanel","matchMark","selectedMatchMark","searchHighlighter","builder","RangeSetBuilder","l","selected","searchCommand","openSearchPanel","findNext","announceMatch","selectSearchInput","findPrevious","prev","selectMatches","selectSelectionMatches","cur","replaceNext","changes","replacement","replaceAll","announceText","fallback","_a","_b","_c","_d","_e","selText","getSearchInput","searchInput","searchExtensions","closeSearchPanel","searchKeymap","phrase","button","name","onclick","content","runScopeHandlers","AnnounceMargin","Break","lineEnd","baseTheme","Prec"],"mappings":"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","x_google_ignoreList":[0]}