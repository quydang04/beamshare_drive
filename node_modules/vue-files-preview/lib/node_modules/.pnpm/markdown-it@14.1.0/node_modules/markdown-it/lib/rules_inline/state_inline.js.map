{"version":3,"file":"state_inline.js","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/state_inline.mjs"],"sourcesContent":["// Inline parser state\n\nimport Token from '../token.mjs'\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs'\n\nfunction StateInline (src, md, env, outTokens) {\n  this.src = src\n  this.env = env\n  this.md = md\n  this.tokens = outTokens\n  this.tokens_meta = Array(outTokens.length)\n\n  this.pos = 0\n  this.posMax = this.src.length\n  this.level = 0\n  this.pending = ''\n  this.pendingLevel = 0\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {}\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = []\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = []\n\n  // backtick length => last seen position\n  this.backticks = {}\n  this.backticksScanned = false\n\n  // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n  this.linkLevel = 0\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  const token = new Token('text', '', 0)\n  token.content = this.pending\n  token.level = this.pendingLevel\n  this.tokens.push(token)\n  this.pending = ''\n  return token\n}\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending()\n  }\n\n  const token = new Token(type, tag, nesting)\n  let token_meta = null\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--\n    this.delimiters = this._prev_delimiters.pop()\n  }\n\n  token.level = this.level\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++\n    this._prev_delimiters.push(this.delimiters)\n    this.delimiters = []\n    token_meta = { delimiters: this.delimiters }\n  }\n\n  this.pendingLevel = this.level\n  this.tokens.push(token)\n  this.tokens_meta.push(token_meta)\n  return token\n}\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  const max = this.posMax\n  const marker = this.src.charCodeAt(start)\n\n  // treat beginning of the line as a whitespace\n  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20\n\n  let pos = start\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++ }\n\n  const count = pos - start\n\n  // treat end of the line as a whitespace\n  const nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20\n\n  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))\n  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))\n\n  const isLastWhiteSpace = isWhiteSpace(lastChar)\n  const isNextWhiteSpace = isWhiteSpace(nextChar)\n\n  const left_flanking =\n    !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar)\n  const right_flanking =\n    !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar)\n\n  const can_open  = left_flanking  && (canSplitWord || !right_flanking || isLastPunctChar)\n  const can_close = right_flanking && (canSplitWord || !left_flanking  || isNextPunctChar)\n\n  return { can_open, can_close, length: count }\n}\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token\n\nexport default StateInline\n"],"names":["StateInline","src","md","env","outTokens","token","Token","type","tag","nesting","token_meta","start","canSplitWord","max","marker","lastChar","pos","count","nextChar","isLastPunctChar","isMdAsciiPunct","isPunctChar","isNextPunctChar","isLastWhiteSpace","isWhiteSpace","isNextWhiteSpace","left_flanking","right_flanking"],"mappings":"4EAKA,SAASA,EAAaC,EAAKC,EAAIC,EAAKC,EAAW,CAC7C,KAAK,IAAMH,EACX,KAAK,IAAME,EACX,KAAK,GAAKD,EACV,KAAK,OAASE,EACd,KAAK,YAAc,MAAMA,EAAU,MAAM,EAEzC,KAAK,IAAM,EACX,KAAK,OAAS,KAAK,IAAI,OACvB,KAAK,MAAQ,EACb,KAAK,QAAU,GACf,KAAK,aAAe,EAIpB,KAAK,MAAQ,CAAE,EAGf,KAAK,WAAa,CAAE,EAGpB,KAAK,iBAAmB,CAAE,EAG1B,KAAK,UAAY,CAAE,EACnB,KAAK,iBAAmB,GAIxB,KAAK,UAAY,CACnB,CAIAJ,EAAY,UAAU,YAAc,UAAY,CAC9C,MAAMK,EAAQ,IAAIC,EAAM,OAAQ,GAAI,CAAC,EACrCD,OAAAA,EAAM,QAAU,KAAK,QACrBA,EAAM,MAAQ,KAAK,aACnB,KAAK,OAAO,KAAKA,CAAK,EACtB,KAAK,QAAU,GACRA,CACT,EAKAL,EAAY,UAAU,KAAO,SAAUO,EAAMC,EAAKC,EAAS,CACrD,KAAK,SACP,KAAK,YAAa,EAGpB,MAAMJ,EAAQ,IAAIC,EAAMC,EAAMC,EAAKC,CAAO,EAC1C,IAAIC,EAAa,KAEjB,OAAID,EAAU,IAEZ,KAAK,QACL,KAAK,WAAa,KAAK,iBAAiB,IAAK,GAG/CJ,EAAM,MAAQ,KAAK,MAEfI,EAAU,IAEZ,KAAK,QACL,KAAK,iBAAiB,KAAK,KAAK,UAAU,EAC1C,KAAK,WAAa,CAAE,EACpBC,EAAa,CAAE,WAAY,KAAK,UAAY,GAG9C,KAAK,aAAe,KAAK,MACzB,KAAK,OAAO,KAAKL,CAAK,EACtB,KAAK,YAAY,KAAKK,CAAU,EACzBL,CACT,EAQAL,EAAY,UAAU,WAAa,SAAUW,EAAOC,EAAc,CAChE,MAAMC,EAAM,KAAK,OACXC,EAAS,KAAK,IAAI,WAAWH,CAAK,EAGlCI,EAAWJ,EAAQ,EAAI,KAAK,IAAI,WAAWA,EAAQ,CAAC,EAAI,GAE9D,IAAIK,EAAML,EACV,KAAOK,EAAMH,GAAO,KAAK,IAAI,WAAWG,CAAG,IAAMF,GAAUE,IAE3D,MAAMC,EAAQD,EAAML,EAGdO,EAAWF,EAAMH,EAAM,KAAK,IAAI,WAAWG,CAAG,EAAI,GAElDG,EAAkBC,EAAc,eAACL,CAAQ,GAAKM,EAAW,YAAC,OAAO,aAAaN,CAAQ,CAAC,EACvFO,EAAkBF,EAAc,eAACF,CAAQ,GAAKG,EAAW,YAAC,OAAO,aAAaH,CAAQ,CAAC,EAEvFK,EAAmBC,EAAY,aAACT,CAAQ,EACxCU,EAAmBD,EAAY,aAACN,CAAQ,EAExCQ,EACJ,CAACD,IAAqB,CAACH,GAAmBC,GAAoBJ,GAC1DQ,EACJ,CAACJ,IAAqB,CAACJ,GAAmBM,GAAoBH,GAKhE,MAAO,CAAE,SAHSI,IAAmBd,GAAgB,CAACe,GAAkBR,GAGrD,UAFDQ,IAAmBf,GAAgB,CAACc,GAAkBJ,GAE1C,OAAQL,CAAO,CAC/C,EAGAjB,EAAY,UAAU,MAAQM","x_google_ignoreList":[0]}