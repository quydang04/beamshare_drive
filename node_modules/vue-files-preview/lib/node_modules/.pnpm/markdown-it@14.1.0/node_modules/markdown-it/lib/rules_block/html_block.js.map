{"version":3,"file":"html_block.js","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/html_block.mjs"],"sourcesContent":["// HTML block\n\nimport block_names from '../common/html_blocks.mjs'\nimport { HTML_OPEN_CLOSE_TAG_RE } from '../common/html_re.mjs'\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nconst HTML_SEQUENCES = [\n  [/^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true],\n  [/^<!--/,        /-->/,   true],\n  [/^<\\?/,         /\\?>/,   true],\n  [/^<![A-Z]/,     />/,     true],\n  [/^<!\\[CDATA\\[/, /\\]\\]>/, true],\n  [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true],\n  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false]\n]\n\nexport default function html_block (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (!state.md.options.html) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false }\n\n  let lineText = state.src.slice(pos, max)\n\n  let i = 0\n  for (; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break }\n  }\n  if (i === HTML_SEQUENCES.length) { return false }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2]\n  }\n\n  let nextLine = startLine + 1\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine]\n      max = state.eMarks[nextLine]\n      lineText = state.src.slice(pos, max)\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++ }\n        break\n      }\n    }\n  }\n\n  state.line = nextLine\n\n  const token   = state.push('html_block', '', 0)\n  token.map     = [startLine, nextLine]\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true)\n\n  return true\n}\n"],"names":["HTML_SEQUENCES","block_names","HTML_OPEN_CLOSE_TAG_RE","html_block","state","startLine","endLine","silent","pos","max","lineText","i","nextLine","token"],"mappings":"2FAQMA,EAAiB,CACrB,CAAC,6CAA8C,mCAAoC,EAAI,EACvF,CAAC,QAAgB,MAAS,EAAI,EAC9B,CAAC,OAAgB,MAAS,EAAI,EAC9B,CAAC,WAAgB,IAAS,EAAI,EAC9B,CAAC,eAAgB,QAAS,EAAI,EAC9B,CAAC,IAAI,OAAO,QAAUC,EAAY,KAAK,GAAG,EAAI,mBAAoB,GAAG,EAAG,KAAM,EAAI,EAClF,CAAC,IAAI,OAAOC,yBAAuB,OAAS,OAAO,EAAI,KAAM,EAAK,CACpE,EAEe,SAASC,EAAYC,EAAOC,EAAWC,EAASC,EAAQ,CACrE,IAAIC,EAAMJ,EAAM,OAAOC,CAAS,EAAID,EAAM,OAAOC,CAAS,EACtDI,EAAML,EAAM,OAAOC,CAAS,EAOhC,GAJID,EAAM,OAAOC,CAAS,EAAID,EAAM,WAAa,GAE7C,CAACA,EAAM,GAAG,QAAQ,MAElBA,EAAM,IAAI,WAAWI,CAAG,IAAM,GAAe,MAAO,GAExD,IAAIE,EAAWN,EAAM,IAAI,MAAMI,EAAKC,CAAG,EAEnCE,EAAI,EACR,KAAOA,EAAIX,EAAe,QACpB,CAAAA,EAAeW,CAAC,EAAE,CAAC,EAAE,KAAKD,CAAQ,EADNC,IAChC,CAEF,GAAIA,IAAMX,EAAe,OAAU,MAAO,GAE1C,GAAIO,EAEF,OAAOP,EAAeW,CAAC,EAAE,CAAC,EAG5B,IAAIC,EAAWP,EAAY,EAI3B,GAAI,CAACL,EAAeW,CAAC,EAAE,CAAC,EAAE,KAAKD,CAAQ,GACrC,KAAOE,EAAWN,GACZ,EAAAF,EAAM,OAAOQ,CAAQ,EAAIR,EAAM,WADVQ,IAOzB,GAJAJ,EAAMJ,EAAM,OAAOQ,CAAQ,EAAIR,EAAM,OAAOQ,CAAQ,EACpDH,EAAML,EAAM,OAAOQ,CAAQ,EAC3BF,EAAWN,EAAM,IAAI,MAAMI,EAAKC,CAAG,EAE/BT,EAAeW,CAAC,EAAE,CAAC,EAAE,KAAKD,CAAQ,EAAG,CACnCA,EAAS,SAAW,GAAKE,IAC7B,KACD,EAILR,EAAM,KAAOQ,EAEb,MAAMC,EAAUT,EAAM,KAAK,aAAc,GAAI,CAAC,EAC9C,OAAAS,EAAM,IAAU,CAACR,EAAWO,CAAQ,EACpCC,EAAM,QAAUT,EAAM,SAASC,EAAWO,EAAUR,EAAM,UAAW,EAAI,EAElE,EACT","x_google_ignoreList":[0]}