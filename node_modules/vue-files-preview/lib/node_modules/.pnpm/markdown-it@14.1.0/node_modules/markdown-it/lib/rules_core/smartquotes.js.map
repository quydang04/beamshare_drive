{"version":3,"file":"smartquotes.js","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/smartquotes.mjs"],"sourcesContent":["// Convert straight quotation marks to typographic ones\n//\n\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs'\n\nconst QUOTE_TEST_RE = /['\"]/\nconst QUOTE_RE = /['\"]/g\nconst APOSTROPHE = '\\u2019' /* â€™ */\n\nfunction replaceAt (str, index, ch) {\n  return str.slice(0, index) + ch + str.slice(index + 1)\n}\n\nfunction process_inlines (tokens, state) {\n  let j\n\n  const stack = []\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n\n    const thisLevel = tokens[i].level\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break }\n    }\n    stack.length = j + 1\n\n    if (token.type !== 'text') { continue }\n\n    let text = token.content\n    let pos = 0\n    let max = text.length\n\n    /* eslint no-labels:0,block-scoped-var:0 */\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos\n      const t = QUOTE_RE.exec(text)\n      if (!t) { break }\n\n      let canOpen = true\n      let canClose = true\n      pos = t.index + 1\n      const isSingle = (t[0] === \"'\")\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      let lastChar = 0x20\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1)\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break // lastChar defaults to 0x20\n          if (!tokens[j].content) continue // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1)\n          break\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      let nextChar = 0x20\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos)\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break // nextChar defaults to 0x20\n          if (!tokens[j].content) continue // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0)\n          break\n        }\n      }\n\n      const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))\n      const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))\n\n      const isLastWhiteSpace = isWhiteSpace(lastChar)\n      const isNextWhiteSpace = isWhiteSpace(nextChar)\n\n      if (isNextWhiteSpace) {\n        canOpen = false\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar\n        canClose = isNextPunctChar\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE)\n        }\n        continue\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          let item = stack[j]\n          if (stack[j].level < thisLevel) { break }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j]\n\n            let openQuote\n            let closeQuote\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2]\n              closeQuote = state.md.options.quotes[3]\n            } else {\n              openQuote = state.md.options.quotes[0]\n              closeQuote = state.md.options.quotes[1]\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote)\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote)\n\n            pos += closeQuote.length - 1\n            if (item.token === i) { pos += openQuote.length - 1 }\n\n            text = token.content\n            max = text.length\n\n            stack.length = j\n            continue OUTER\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        })\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE)\n      }\n    }\n  }\n}\n\nexport default function smartquotes (state) {\n  /* eslint max-depth:0 */\n  if (!state.md.options.typographer) { return }\n\n  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state)\n  }\n}\n"],"names":["QUOTE_TEST_RE","QUOTE_RE","APOSTROPHE","replaceAt","str","index","ch","process_inlines","tokens","state","j","stack","i","token","thisLevel","text","pos","max","OUTER","t","canOpen","canClose","isSingle","lastChar","nextChar","isLastPunctChar","isMdAsciiPunct","isPunctChar","isNextPunctChar","isLastWhiteSpace","isWhiteSpace","isNextWhiteSpace","item","openQuote","closeQuote","smartquotes","blkIdx"],"mappings":"mDAKMA,EAAgB,OAChBC,EAAW,QACXC,EAAa,IAEnB,SAASC,EAAWC,EAAKC,EAAOC,EAAI,CAClC,OAAOF,EAAI,MAAM,EAAGC,CAAK,EAAIC,EAAKF,EAAI,MAAMC,EAAQ,CAAC,CACvD,CAEA,SAASE,EAAiBC,EAAQC,EAAO,CACvC,IAAIC,EAEJ,MAAMC,EAAQ,CAAE,EAEhB,QAASC,EAAI,EAAGA,EAAIJ,EAAO,OAAQI,IAAK,CACtC,MAAMC,EAAQL,EAAOI,CAAC,EAEhBE,EAAYN,EAAOI,CAAC,EAAE,MAE5B,IAAKF,EAAIC,EAAM,OAAS,EAAGD,GAAK,GAC1B,EAAAC,EAAMD,CAAC,EAAE,OAASI,GADWJ,IACjC,CAIF,GAFAC,EAAM,OAASD,EAAI,EAEfG,EAAM,OAAS,OAAU,SAE7B,IAAIE,EAAOF,EAAM,QACbG,EAAM,EACNC,EAAMF,EAAK,OAGfG,EACA,KAAOF,EAAMC,GAAK,CAChBhB,EAAS,UAAYe,EACrB,MAAMG,EAAIlB,EAAS,KAAKc,CAAI,EAC5B,GAAI,CAACI,EAAK,MAEV,IAAIC,EAAU,GACVC,EAAW,GACfL,EAAMG,EAAE,MAAQ,EAChB,MAAMG,EAAYH,EAAE,CAAC,IAAM,IAK3B,IAAII,EAAW,GAEf,GAAIJ,EAAE,MAAQ,GAAK,EACjBI,EAAWR,EAAK,WAAWI,EAAE,MAAQ,CAAC,MAEtC,KAAKT,EAAIE,EAAI,EAAGF,GAAK,GACf,EAAAF,EAAOE,CAAC,EAAE,OAAS,aAAeF,EAAOE,CAAC,EAAE,OAAS,aADnCA,IAEtB,GAAKF,EAAOE,CAAC,EAAE,QAEf,CAAAa,EAAWf,EAAOE,CAAC,EAAE,QAAQ,WAAWF,EAAOE,CAAC,EAAE,QAAQ,OAAS,CAAC,EACpE,MAOJ,IAAIc,EAAW,GAEf,GAAIR,EAAMC,EACRO,EAAWT,EAAK,WAAWC,CAAG,MAE9B,KAAKN,EAAIE,EAAI,EAAGF,EAAIF,EAAO,QACrB,EAAAA,EAAOE,CAAC,EAAE,OAAS,aAAeF,EAAOE,CAAC,EAAE,OAAS,aADxBA,IAEjC,GAAKF,EAAOE,CAAC,EAAE,QAEf,CAAAc,EAAWhB,EAAOE,CAAC,EAAE,QAAQ,WAAW,CAAC,EACzC,MAIJ,MAAMe,EAAkBC,EAAc,eAACH,CAAQ,GAAKI,EAAW,YAAC,OAAO,aAAaJ,CAAQ,CAAC,EACvFK,EAAkBF,EAAc,eAACF,CAAQ,GAAKG,EAAW,YAAC,OAAO,aAAaH,CAAQ,CAAC,EAEvFK,EAAmBC,EAAY,aAACP,CAAQ,EACxCQ,EAAmBD,EAAY,aAACN,CAAQ,EAqC9C,GAnCIO,EACFX,EAAU,GACDQ,IACHC,GAAoBJ,IACxBL,EAAU,KAIVS,EACFR,EAAW,GACFI,IACHM,GAAoBH,IACxBP,EAAW,KAIXG,IAAa,IAAgBL,EAAE,CAAC,IAAM,KACpCI,GAAY,IAAgBA,GAAY,KAE1CF,EAAWD,EAAU,IAIrBA,GAAWC,IAQbD,EAAUK,EACVJ,EAAWO,GAGT,CAACR,GAAW,CAACC,EAAU,CAErBC,IACFT,EAAM,QAAUV,EAAUU,EAAM,QAASM,EAAE,MAAOjB,CAAU,GAE9D,QACD,CAED,GAAImB,EAEF,IAAKX,EAAIC,EAAM,OAAS,EAAGD,GAAK,EAAGA,IAAK,CACtC,IAAIsB,EAAOrB,EAAMD,CAAC,EAClB,GAAIC,EAAMD,CAAC,EAAE,MAAQI,EAAa,MAClC,GAAIkB,EAAK,SAAWV,GAAYX,EAAMD,CAAC,EAAE,QAAUI,EAAW,CAC5DkB,EAAOrB,EAAMD,CAAC,EAEd,IAAIuB,EACAC,EACAZ,GACFW,EAAYxB,EAAM,GAAG,QAAQ,OAAO,CAAC,EACrCyB,EAAazB,EAAM,GAAG,QAAQ,OAAO,CAAC,IAEtCwB,EAAYxB,EAAM,GAAG,QAAQ,OAAO,CAAC,EACrCyB,EAAazB,EAAM,GAAG,QAAQ,OAAO,CAAC,GAMxCI,EAAM,QAAUV,EAAUU,EAAM,QAASM,EAAE,MAAOe,CAAU,EAC5D1B,EAAOwB,EAAK,KAAK,EAAE,QAAU7B,EAC3BK,EAAOwB,EAAK,KAAK,EAAE,QAASA,EAAK,IAAKC,CAAS,EAEjDjB,GAAOkB,EAAW,OAAS,EACvBF,EAAK,QAAUpB,IAAKI,GAAOiB,EAAU,OAAS,GAElDlB,EAAOF,EAAM,QACbI,EAAMF,EAAK,OAEXJ,EAAM,OAASD,EACf,SAASQ,CACV,CACF,CAGCE,EACFT,EAAM,KAAK,CACT,MAAOC,EACP,IAAKO,EAAE,MACP,OAAQG,EACR,MAAOR,CACjB,CAAS,EACQO,GAAYC,IACrBT,EAAM,QAAUV,EAAUU,EAAM,QAASM,EAAE,MAAOjB,CAAU,EAE/D,CACF,CACH,CAEe,SAASiC,EAAa1B,EAAO,CAE1C,GAAKA,EAAM,GAAG,QAAQ,YAEtB,QAAS2B,EAAS3B,EAAM,OAAO,OAAS,EAAG2B,GAAU,EAAGA,IAClD3B,EAAM,OAAO2B,CAAM,EAAE,OAAS,UAC9B,CAACpC,EAAc,KAAKS,EAAM,OAAO2B,CAAM,EAAE,OAAO,GAIpD7B,EAAgBE,EAAM,OAAO2B,CAAM,EAAE,SAAU3B,CAAK,CAExD","x_google_ignoreList":[0]}