{"version":3,"file":"parser_block.js","sources":["../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/parser_block.mjs"],"sourcesContent":["/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n\nimport Ruler from './ruler.mjs'\nimport StateBlock from './rules_block/state_block.mjs'\n\nimport r_table from './rules_block/table.mjs'\nimport r_code from './rules_block/code.mjs'\nimport r_fence from './rules_block/fence.mjs'\nimport r_blockquote from './rules_block/blockquote.mjs'\nimport r_hr from './rules_block/hr.mjs'\nimport r_list from './rules_block/list.mjs'\nimport r_reference from './rules_block/reference.mjs'\nimport r_html_block from './rules_block/html_block.mjs'\nimport r_heading from './rules_block/heading.mjs'\nimport r_lheading from './rules_block/lheading.mjs'\nimport r_paragraph from './rules_block/paragraph.mjs'\n\nconst _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  ['table',      r_table,      ['paragraph', 'reference']],\n  ['code',       r_code],\n  ['fence',      r_fence,      ['paragraph', 'reference', 'blockquote', 'list']],\n  ['blockquote', r_blockquote, ['paragraph', 'reference', 'blockquote', 'list']],\n  ['hr',         r_hr,         ['paragraph', 'reference', 'blockquote', 'list']],\n  ['list',       r_list,       ['paragraph', 'reference', 'blockquote']],\n  ['reference',  r_reference],\n  ['html_block', r_html_block, ['paragraph', 'reference', 'blockquote']],\n  ['heading',    r_heading,    ['paragraph', 'reference', 'blockquote']],\n  ['lheading',   r_lheading],\n  ['paragraph',  r_paragraph]\n]\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock () {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler()\n\n  for (let i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() })\n  }\n}\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  const rules = this.ruler.getRules('')\n  const len = rules.length\n  const maxNesting = state.md.options.maxNesting\n  let line = startLine\n  let hasEmptyLines = false\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line)\n    if (line >= endLine) { break }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine\n      break\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n    const prevLine = state.line\n    let ok = false\n\n    for (let i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false)\n      if (ok) {\n        if (prevLine >= state.line) {\n          throw new Error(\"block rule didn't increment state.line\")\n        }\n        break\n      }\n    }\n\n    // this can only happen if user disables paragraph rule\n    if (!ok) throw new Error('none of the block rules matched')\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true\n    }\n\n    line = state.line\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true\n      line++\n      state.line = line\n    }\n  }\n}\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  if (!src) { return }\n\n  const state = new this.State(src, md, env, outTokens)\n\n  this.tokenize(state, state.line, state.lineMax)\n}\n\nParserBlock.prototype.State = StateBlock\n\nexport default ParserBlock\n"],"names":["_rules","r_table","r_code","r_fence","r_blockquote","r_hr","r_list","r_reference","r_html_block","r_heading","r_lheading","r_paragraph","ParserBlock","Ruler","i","state","startLine","endLine","rules","len","maxNesting","line","hasEmptyLines","prevLine","ok","src","md","env","outTokens","StateBlock"],"mappings":"mfAqBMA,EAAS,CAGb,CAAC,QAAcC,EAAc,CAAC,YAAa,WAAW,CAAC,EACvD,CAAC,OAAcC,CAAM,EACrB,CAAC,QAAcC,EAAc,CAAC,YAAa,YAAa,aAAc,MAAM,CAAC,EAC7E,CAAC,aAAcC,EAAc,CAAC,YAAa,YAAa,aAAc,MAAM,CAAC,EAC7E,CAAC,KAAcC,EAAc,CAAC,YAAa,YAAa,aAAc,MAAM,CAAC,EAC7E,CAAC,OAAcC,EAAc,CAAC,YAAa,YAAa,YAAY,CAAC,EACrE,CAAC,YAAcC,CAAW,EAC1B,CAAC,aAAcC,EAAc,CAAC,YAAa,YAAa,YAAY,CAAC,EACrE,CAAC,UAAcC,EAAc,CAAC,YAAa,YAAa,YAAY,CAAC,EACrE,CAAC,WAAcC,CAAU,EACzB,CAAC,YAAcC,CAAW,CAC5B,EAKA,SAASC,GAAe,CAMtB,KAAK,MAAQ,IAAIC,EAEjB,QAASC,EAAI,EAAGA,EAAId,EAAO,OAAQc,IACjC,KAAK,MAAM,KAAKd,EAAOc,CAAC,EAAE,CAAC,EAAGd,EAAOc,CAAC,EAAE,CAAC,EAAG,CAAE,KAAMd,EAAOc,CAAC,EAAE,CAAC,GAAK,CAAA,GAAI,MAAK,EAAI,CAErF,CAIAF,EAAY,UAAU,SAAW,SAAUG,EAAOC,EAAWC,EAAS,CACpE,MAAMC,EAAQ,KAAK,MAAM,SAAS,EAAE,EAC9BC,EAAMD,EAAM,OACZE,EAAaL,EAAM,GAAG,QAAQ,WACpC,IAAIM,EAAOL,EACPM,EAAgB,GAEpB,KAAOD,EAAOJ,IACZF,EAAM,KAAOM,EAAON,EAAM,eAAeM,CAAI,EACzC,EAAAA,GAAQJ,GAIRF,EAAM,OAAOM,CAAI,EAAIN,EAAM,aANV,CAUrB,GAAIA,EAAM,OAASK,EAAY,CAC7BL,EAAM,KAAOE,EACb,KACD,CAQD,MAAMM,EAAWR,EAAM,KACvB,IAAIS,EAAK,GAET,QAASV,EAAI,EAAGA,EAAIK,EAAKL,IAEvB,GADAU,EAAKN,EAAMJ,CAAC,EAAEC,EAAOM,EAAMJ,EAAS,EAAK,EACrCO,EAAI,CACN,GAAID,GAAYR,EAAM,KACpB,MAAM,IAAI,MAAM,wCAAwC,EAE1D,KACD,CAIH,GAAI,CAACS,EAAI,MAAM,IAAI,MAAM,iCAAiC,EAI1DT,EAAM,MAAQ,CAACO,EAGXP,EAAM,QAAQA,EAAM,KAAO,CAAC,IAC9BO,EAAgB,IAGlBD,EAAON,EAAM,KAETM,EAAOJ,GAAWF,EAAM,QAAQM,CAAI,IACtCC,EAAgB,GAChBD,IACAN,EAAM,KAAOM,EAEhB,CACH,EAOAT,EAAY,UAAU,MAAQ,SAAUa,EAAKC,EAAIC,EAAKC,EAAW,CAC/D,GAAI,CAACH,EAAO,OAEZ,MAAMV,EAAQ,IAAI,KAAK,MAAMU,EAAKC,EAAIC,EAAKC,CAAS,EAEpD,KAAK,SAASb,EAAOA,EAAM,KAAMA,EAAM,OAAO,CAChD,EAEAH,EAAY,UAAU,MAAQiB","x_google_ignoreList":[0]}