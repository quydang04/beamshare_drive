{"version":3,"file":"blockquote.js","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/blockquote.mjs"],"sourcesContent":["// Block quotes\n\nimport { isSpace } from '../common/utils.mjs'\n\nexport default function blockquote (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  const oldLineMax = state.lineMax\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos) !== 0x3E/* > */) { return false }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true }\n\n  const oldBMarks  = []\n  const oldBSCount = []\n  const oldSCount  = []\n  const oldTShift  = []\n\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const oldParentType = state.parentType\n  state.parentType = 'blockquote'\n  let lastLineEmpty = false\n  let nextLine\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    const isOutdented = state.sCount[nextLine] < state.blkIndent\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {\n      // This line is inside the blockquote.\n\n      // set offset past spaces and \">\"\n      let initial = state.sCount[nextLine] + 1\n      let spaceAfterMarker\n      let adjustTab\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++\n        initial++\n        adjustTab = false\n        spaceAfterMarker = true\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true\n\n        if ((state.bsCount[nextLine] + initial) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++\n          initial++\n          adjustTab = false\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true\n        }\n      } else {\n        spaceAfterMarker = false\n      }\n\n      let offset = initial\n      oldBMarks.push(state.bMarks[nextLine])\n      state.bMarks[nextLine] = pos\n\n      while (pos < max) {\n        const ch = state.src.charCodeAt(pos)\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4\n          } else {\n            offset++\n          }\n        } else {\n          break\n        }\n\n        pos++\n      }\n\n      lastLineEmpty = pos >= max\n\n      oldBSCount.push(state.bsCount[nextLine])\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0)\n\n      oldSCount.push(state.sCount[nextLine])\n      state.sCount[nextLine] = offset - initial\n\n      oldTShift.push(state.tShift[nextLine])\n      state.tShift[nextLine] = pos - state.bMarks[nextLine]\n      continue\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break }\n\n    // Case 3: another tag found.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine])\n        oldBSCount.push(state.bsCount[nextLine])\n        oldTShift.push(state.tShift[nextLine])\n        oldSCount.push(state.sCount[nextLine])\n        state.sCount[nextLine] -= state.blkIndent\n      }\n\n      break\n    }\n\n    oldBMarks.push(state.bMarks[nextLine])\n    oldBSCount.push(state.bsCount[nextLine])\n    oldTShift.push(state.tShift[nextLine])\n    oldSCount.push(state.sCount[nextLine])\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1\n  }\n\n  const oldIndent = state.blkIndent\n  state.blkIndent = 0\n\n  const token_o  = state.push('blockquote_open', 'blockquote', 1)\n  token_o.markup = '>'\n  const lines = [startLine, 0]\n  token_o.map    = lines\n\n  state.md.block.tokenize(state, startLine, nextLine)\n\n  const token_c  = state.push('blockquote_close', 'blockquote', -1)\n  token_c.markup = '>'\n\n  state.lineMax = oldLineMax\n  state.parentType = oldParentType\n  lines[1] = state.line\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (let i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i]\n    state.tShift[i + startLine] = oldTShift[i]\n    state.sCount[i + startLine] = oldSCount[i]\n    state.bsCount[i + startLine] = oldBSCount[i]\n  }\n  state.blkIndent = oldIndent\n\n  return true\n}\n"],"names":["blockquote","state","startLine","endLine","silent","pos","max","oldLineMax","oldBMarks","oldBSCount","oldSCount","oldTShift","terminatorRules","oldParentType","lastLineEmpty","nextLine","isOutdented","initial","spaceAfterMarker","adjustTab","offset","ch","isSpace","terminate","i","l","oldIndent","token_o","lines","token_c"],"mappings":"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","x_google_ignoreList":[0]}