{"version":3,"file":"reference.js","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/reference.mjs"],"sourcesContent":["import { isSpace, normalizeReference } from '../common/utils.mjs'\n\nexport default function reference (state, startLine, _endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n  let nextLine = startLine + 1\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false }\n\n  function getNextLine (nextLine) {\n    const endLine = state.lineMax\n\n    if (nextLine >= endLine || state.isEmpty(nextLine)) {\n      // empty line or end of input\n      return null\n    }\n\n    let isContinuation = false\n\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { isContinuation = true }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { isContinuation = true }\n\n    if (!isContinuation) {\n      const terminatorRules = state.md.block.ruler.getRules('reference')\n      const oldParentType = state.parentType\n      state.parentType = 'reference'\n\n      // Some tags can terminate paragraph without empty line.\n      let terminate = false\n      for (let i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true\n          break\n        }\n      }\n\n      state.parentType = oldParentType\n      if (terminate) {\n        // terminated by another block\n        return null\n      }\n    }\n\n    const pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    const max = state.eMarks[nextLine]\n\n    // max + 1 explicitly includes the newline\n    return state.src.slice(pos, max + 1)\n  }\n\n  let str = state.src.slice(pos, max + 1)\n\n  max = str.length\n  let labelEnd = -1\n\n  for (pos = 1; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x5B /* [ */) {\n      return false\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos\n      break\n    } else if (ch === 0x0A /* \\n */) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (ch === 0x5C /* \\ */) {\n      pos++\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        const lineContent = getNextLine(nextLine)\n        if (lineContent !== null) {\n          str += lineContent\n          max = str.length\n          nextLine++\n        }\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  const destRes = state.md.helpers.parseLinkDestination(str, pos, max)\n  if (!destRes.ok) { return false }\n\n  const href = state.md.normalizeLink(destRes.str)\n  if (!state.md.validateLink(href)) { return false }\n\n  pos = destRes.pos\n\n  // save cursor state, we could require to rollback later\n  const destEndPos = pos\n  const destEndLineNo = nextLine\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  const start = pos\n  for (; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max)\n  while (titleRes.can_continue) {\n    const lineContent = getNextLine(nextLine)\n    if (lineContent === null) break\n    str += lineContent\n    pos = max\n    max = str.length\n    nextLine++\n    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes)\n  }\n  let title\n\n  if (pos < max && start !== pos && titleRes.ok) {\n    title = titleRes.str\n    pos = titleRes.pos\n  } else {\n    title = ''\n    pos = destEndPos\n    nextLine = destEndLineNo\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    const ch = str.charCodeAt(pos)\n    if (!isSpace(ch)) { break }\n    pos++\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = ''\n      pos = destEndPos\n      nextLine = destEndLineNo\n      while (pos < max) {\n        const ch = str.charCodeAt(pos)\n        if (!isSpace(ch)) { break }\n        pos++\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false\n  }\n\n  const label = normalizeReference(str.slice(1, labelEnd))\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /* istanbul ignore if */\n  if (silent) { return true }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {}\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title, href }\n  }\n\n  state.line = nextLine\n  return true\n}\n"],"names":["reference","state","startLine","_endLine","silent","pos","max","nextLine","getNextLine","endLine","isContinuation","terminatorRules","oldParentType","terminate","i","l","str","labelEnd","ch","lineContent","isSpace","destRes","href","destEndPos","destEndLineNo","start","titleRes","title","label","normalizeReference"],"mappings":"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","x_google_ignoreList":[0]}