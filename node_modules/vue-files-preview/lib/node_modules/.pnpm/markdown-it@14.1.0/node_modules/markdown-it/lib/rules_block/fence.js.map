{"version":3,"file":"fence.js","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/fence.mjs"],"sourcesContent":["// fences (``` lang, ~~~ lang)\n\nexport default function fence (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (pos + 3 > max) { return false }\n\n  const marker = state.src.charCodeAt(pos)\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false\n  }\n\n  // scan marker length\n  let mem = pos\n  pos = state.skipChars(pos, marker)\n\n  let len = pos - mem\n\n  if (len < 3) { return false }\n\n  const markup = state.src.slice(mem, pos)\n  const params = state.src.slice(pos, max)\n\n  if (marker === 0x60 /* ` */) {\n    if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n      return false\n    }\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true }\n\n  // search end of block\n  let nextLine = startLine\n  let haveEndMarker = false\n\n  for (;;) {\n    nextLine++\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue\n    }\n\n    pos = state.skipChars(pos, marker)\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos)\n\n    if (pos < max) { continue }\n\n    haveEndMarker = true\n    // found!\n    break\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine]\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0)\n\n  const token   = state.push('fence', 'code', 0)\n  token.info    = params\n  token.content = state.getLines(startLine + 1, nextLine, len, true)\n  token.markup  = markup\n  token.map     = [startLine, state.line]\n\n  return true\n}\n"],"names":["fence","state","startLine","endLine","silent","pos","max","marker","mem","len","markup","params","nextLine","haveEndMarker","token"],"mappings":"aAEe,SAASA,EAAOC,EAAOC,EAAWC,EAASC,EAAQ,CAChE,IAAIC,EAAMJ,EAAM,OAAOC,CAAS,EAAID,EAAM,OAAOC,CAAS,EACtDI,EAAML,EAAM,OAAOC,CAAS,EAKhC,GAFID,EAAM,OAAOC,CAAS,EAAID,EAAM,WAAa,GAE7CI,EAAM,EAAIC,EAAO,MAAO,GAE5B,MAAMC,EAASN,EAAM,IAAI,WAAWI,CAAG,EAEvC,GAAIE,IAAW,KAAeA,IAAW,GACvC,MAAO,GAIT,IAAIC,EAAMH,EACVA,EAAMJ,EAAM,UAAUI,EAAKE,CAAM,EAEjC,IAAIE,EAAMJ,EAAMG,EAEhB,GAAIC,EAAM,EAAK,MAAO,GAEtB,MAAMC,EAAST,EAAM,IAAI,MAAMO,EAAKH,CAAG,EACjCM,EAASV,EAAM,IAAI,MAAMI,EAAKC,CAAG,EAEvC,GAAIC,IAAW,IACTI,EAAO,QAAQ,OAAO,aAAaJ,CAAM,CAAC,GAAK,EACjD,MAAO,GAKX,GAAIH,EAAU,MAAO,GAGrB,IAAIQ,EAAWV,EACXW,EAAgB,GAEpB,KACED,IACI,EAAAA,GAAYT,IAMhBE,EAAMG,EAAMP,EAAM,OAAOW,CAAQ,EAAIX,EAAM,OAAOW,CAAQ,EAC1DN,EAAML,EAAM,OAAOW,CAAQ,EAEvBP,EAAMC,GAAOL,EAAM,OAAOW,CAAQ,EAAIX,EAAM,aAOhD,GAAIA,EAAM,IAAI,WAAWI,CAAG,IAAME,GAE9B,EAAAN,EAAM,OAAOW,CAAQ,EAAIX,EAAM,WAAa,KAKhDI,EAAMJ,EAAM,UAAUI,EAAKE,CAAM,EAG7B,EAAAF,EAAMG,EAAMC,KAGhBJ,EAAMJ,EAAM,WAAWI,CAAG,EAEtB,EAAAA,EAAMC,KAEV,CAAAO,EAAgB,GAEhB,MAIFJ,EAAMR,EAAM,OAAOC,CAAS,EAE5BD,EAAM,KAAOW,GAAYC,EAAgB,EAAI,GAE7C,MAAMC,EAAUb,EAAM,KAAK,QAAS,OAAQ,CAAC,EAC7C,OAAAa,EAAM,KAAUH,EAChBG,EAAM,QAAUb,EAAM,SAASC,EAAY,EAAGU,EAAUH,EAAK,EAAI,EACjEK,EAAM,OAAUJ,EAChBI,EAAM,IAAU,CAACZ,EAAWD,EAAM,IAAI,EAE/B,EACT","x_google_ignoreList":[0]}