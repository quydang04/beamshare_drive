{"version":3,"file":"table.js","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/table.mjs"],"sourcesContent":["// GFM table, https://github.github.com/gfm/#tables-extension-\n\nimport { isSpace } from '../common/utils.mjs'\n\n// Limit the amount of empty autocompleted cells in a table,\n// see https://github.com/markdown-it/markdown-it/issues/1000,\n//\n// Both pulldown-cmark and commonmark-hs limit the number of cells this way to ~200k.\n// We set it to 65k, which can expand user input by a factor of x370\n// (256x256 square is 1.8kB expanded into 650kB).\nconst MAX_AUTOCOMPLETED_CELLS = 0x10000\n\nfunction getLine (state, line) {\n  const pos = state.bMarks[line] + state.tShift[line]\n  const max = state.eMarks[line]\n\n  return state.src.slice(pos, max)\n}\n\nfunction escapedSplit (str) {\n  const result = []\n  const max = str.length\n\n  let pos = 0\n  let ch = str.charCodeAt(pos)\n  let isEscaped = false\n  let lastPos = 0\n  let current = ''\n\n  while (pos < max) {\n    if (ch === 0x7c/* | */) {\n      if (!isEscaped) {\n        // pipe separating cells, '|'\n        result.push(current + str.substring(lastPos, pos))\n        current = ''\n        lastPos = pos + 1\n      } else {\n        // escaped pipe, '\\|'\n        current += str.substring(lastPos, pos - 1)\n        lastPos = pos\n      }\n    }\n\n    isEscaped = (ch === 0x5c/* \\ */)\n    pos++\n\n    ch = str.charCodeAt(pos)\n  }\n\n  result.push(current + str.substring(lastPos))\n\n  return result\n}\n\nexport default function table (state, startLine, endLine, silent) {\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false }\n\n  let nextLine = startLine + 1\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  let pos = state.bMarks[nextLine] + state.tShift[nextLine]\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const firstCh = state.src.charCodeAt(pos++)\n  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false }\n\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const secondCh = state.src.charCodeAt(pos++)\n  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace(secondCh)) {\n    return false\n  }\n\n  // if first character is '-', then second character must not be a space\n  // (due to parsing ambiguity with list)\n  if (firstCh === 0x2D/* - */ && isSpace(secondCh)) { return false }\n\n  while (pos < state.eMarks[nextLine]) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false }\n\n    pos++\n  }\n\n  let lineText = getLine(state, startLine + 1)\n  let columns = lineText.split('|')\n  const aligns = []\n  for (let i = 0; i < columns.length; i++) {\n    const t = columns[i].trim()\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue\n      } else {\n        return false\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right')\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left')\n    } else {\n      aligns.push('')\n    }\n  }\n\n  lineText = getLine(state, startLine).trim()\n  if (lineText.indexOf('|') === -1) { return false }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n  columns = escapedSplit(lineText)\n  if (columns.length && columns[0] === '') columns.shift()\n  if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n  // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n  const columnCount = columns.length\n  if (columnCount === 0 || columnCount !== aligns.length) { return false }\n\n  if (silent) { return true }\n\n  const oldParentType = state.parentType\n  state.parentType = 'table'\n\n  // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const token_to = state.push('table_open', 'table', 1)\n  const tableLines = [startLine, 0]\n  token_to.map = tableLines\n\n  const token_tho = state.push('thead_open', 'thead', 1)\n  token_tho.map = [startLine, startLine + 1]\n\n  const token_htro = state.push('tr_open', 'tr', 1)\n  token_htro.map = [startLine, startLine + 1]\n\n  for (let i = 0; i < columns.length; i++) {\n    const token_ho = state.push('th_open', 'th', 1)\n    if (aligns[i]) {\n      token_ho.attrs  = [['style', 'text-align:' + aligns[i]]]\n    }\n\n    const token_il = state.push('inline', '', 0)\n    token_il.content  = columns[i].trim()\n    token_il.children = []\n\n    state.push('th_close', 'th', -1)\n  }\n\n  state.push('tr_close', 'tr', -1)\n  state.push('thead_close', 'thead', -1)\n\n  let tbodyLines\n  let autocompletedCells = 0\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) { break }\n    lineText = getLine(state, nextLine).trim()\n    if (!lineText) { break }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n    columns = escapedSplit(lineText)\n    if (columns.length && columns[0] === '') columns.shift()\n    if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n    // note: autocomplete count can be negative if user specifies more columns than header,\n    // but that does not affect intended use (which is limiting expansion)\n    autocompletedCells += columnCount - columns.length\n    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) { break }\n\n    if (nextLine === startLine + 2) {\n      const token_tbo = state.push('tbody_open', 'tbody', 1)\n      token_tbo.map = tbodyLines = [startLine + 2, 0]\n    }\n\n    const token_tro = state.push('tr_open', 'tr', 1)\n    token_tro.map = [nextLine, nextLine + 1]\n\n    for (let i = 0; i < columnCount; i++) {\n      const token_tdo = state.push('td_open', 'td', 1)\n      if (aligns[i]) {\n        token_tdo.attrs  = [['style', 'text-align:' + aligns[i]]]\n      }\n\n      const token_il = state.push('inline', '', 0)\n      token_il.content  = columns[i] ? columns[i].trim() : ''\n      token_il.children = []\n\n      state.push('td_close', 'td', -1)\n    }\n    state.push('tr_close', 'tr', -1)\n  }\n\n  if (tbodyLines) {\n    state.push('tbody_close', 'tbody', -1)\n    tbodyLines[1] = nextLine\n  }\n\n  state.push('table_close', 'table', -1)\n  tableLines[1] = nextLine\n\n  state.parentType = oldParentType\n  state.line = nextLine\n  return true\n}\n"],"names":["MAX_AUTOCOMPLETED_CELLS","getLine","state","line","pos","max","escapedSplit","str","result","ch","isEscaped","lastPos","current","table","startLine","endLine","silent","nextLine","firstCh","secondCh","isSpace","lineText","columns","aligns","i","t","columnCount","oldParentType","terminatorRules","token_to","tableLines","token_tho","token_htro","token_ho","token_il","tbodyLines","autocompletedCells","terminate","l","token_tbo","token_tro","token_tdo"],"mappings":"mDAUMA,EAA0B,MAEhC,SAASC,EAASC,EAAOC,EAAM,CAC7B,MAAMC,EAAMF,EAAM,OAAOC,CAAI,EAAID,EAAM,OAAOC,CAAI,EAC5CE,EAAMH,EAAM,OAAOC,CAAI,EAE7B,OAAOD,EAAM,IAAI,MAAME,EAAKC,CAAG,CACjC,CAEA,SAASC,EAAcC,EAAK,CAC1B,MAAMC,EAAS,CAAE,EACXH,EAAME,EAAI,OAEhB,IAAIH,EAAM,EACNK,EAAKF,EAAI,WAAWH,CAAG,EACvBM,EAAY,GACZC,EAAU,EACVC,EAAU,GAEd,KAAOR,EAAMC,GACPI,IAAO,MACJC,GAOHE,GAAWL,EAAI,UAAUI,EAASP,EAAM,CAAC,EACzCO,EAAUP,IANVI,EAAO,KAAKI,EAAUL,EAAI,UAAUI,EAASP,CAAG,CAAC,EACjDQ,EAAU,GACVD,EAAUP,EAAM,IAQpBM,EAAaD,IAAO,GACpBL,IAEAK,EAAKF,EAAI,WAAWH,CAAG,EAGzB,OAAAI,EAAO,KAAKI,EAAUL,EAAI,UAAUI,CAAO,CAAC,EAErCH,CACT,CAEe,SAASK,EAAOX,EAAOY,EAAWC,EAASC,EAAQ,CAEhE,GAAIF,EAAY,EAAIC,EAAW,MAAO,GAEtC,IAAIE,EAAWH,EAAY,EAK3B,GAHIZ,EAAM,OAAOe,CAAQ,EAAIf,EAAM,WAG/BA,EAAM,OAAOe,CAAQ,EAAIf,EAAM,WAAa,EAAK,MAAO,GAM5D,IAAIE,EAAMF,EAAM,OAAOe,CAAQ,EAAIf,EAAM,OAAOe,CAAQ,EACxD,GAAIb,GAAOF,EAAM,OAAOe,CAAQ,EAAK,MAAO,GAE5C,MAAMC,EAAUhB,EAAM,IAAI,WAAWE,GAAK,EAG1C,GAFIc,IAAY,KAAeA,IAAY,IAAeA,IAAY,IAElEd,GAAOF,EAAM,OAAOe,CAAQ,EAAK,MAAO,GAE5C,MAAME,EAAWjB,EAAM,IAAI,WAAWE,GAAK,EAO3C,GANIe,IAAa,KAAeA,IAAa,IAAeA,IAAa,IAAe,CAACC,UAAQD,CAAQ,GAMrGD,IAAY,IAAeE,EAAAA,QAAQD,CAAQ,EAAK,MAAO,GAE3D,KAAOf,EAAMF,EAAM,OAAOe,CAAQ,GAAG,CACnC,MAAMR,EAAKP,EAAM,IAAI,WAAWE,CAAG,EAEnC,GAAIK,IAAO,KAAeA,IAAO,IAAeA,IAAO,IAAe,CAACW,UAAQX,CAAE,EAAK,MAAO,GAE7FL,GACD,CAED,IAAIiB,EAAWpB,EAAQC,EAAOY,EAAY,CAAC,EACvCQ,EAAUD,EAAS,MAAM,GAAG,EAChC,MAAME,EAAS,CAAE,EACjB,QAASC,EAAI,EAAGA,EAAIF,EAAQ,OAAQE,IAAK,CACvC,MAAMC,EAAIH,EAAQE,CAAC,EAAE,KAAM,EAC3B,GAAI,CAACC,EAAG,CAGN,GAAID,IAAM,GAAKA,IAAMF,EAAQ,OAAS,EACpC,SAEA,MAAO,EAEV,CAED,GAAI,CAAC,WAAW,KAAKG,CAAC,EAAK,MAAO,GAC9BA,EAAE,WAAWA,EAAE,OAAS,CAAC,IAAM,GACjCF,EAAO,KAAKE,EAAE,WAAW,CAAC,IAAM,GAAc,SAAW,OAAO,EACvDA,EAAE,WAAW,CAAC,IAAM,GAC7BF,EAAO,KAAK,MAAM,EAElBA,EAAO,KAAK,EAAE,CAEjB,CAID,GAFAF,EAAWpB,EAAQC,EAAOY,CAAS,EAAE,KAAM,EACvCO,EAAS,QAAQ,GAAG,IAAM,IAC1BnB,EAAM,OAAOY,CAAS,EAAIZ,EAAM,WAAa,EAAK,MAAO,GAC7DoB,EAAUhB,EAAae,CAAQ,EAC3BC,EAAQ,QAAUA,EAAQ,CAAC,IAAM,IAAIA,EAAQ,MAAO,EACpDA,EAAQ,QAAUA,EAAQA,EAAQ,OAAS,CAAC,IAAM,IAAIA,EAAQ,IAAK,EAIvE,MAAMI,EAAcJ,EAAQ,OAC5B,GAAII,IAAgB,GAAKA,IAAgBH,EAAO,OAAU,MAAO,GAEjE,GAAIP,EAAU,MAAO,GAErB,MAAMW,EAAgBzB,EAAM,WAC5BA,EAAM,WAAa,QAInB,MAAM0B,EAAkB1B,EAAM,GAAG,MAAM,MAAM,SAAS,YAAY,EAE5D2B,EAAW3B,EAAM,KAAK,aAAc,QAAS,CAAC,EAC9C4B,EAAa,CAAChB,EAAW,CAAC,EAChCe,EAAS,IAAMC,EAEf,MAAMC,EAAY7B,EAAM,KAAK,aAAc,QAAS,CAAC,EACrD6B,EAAU,IAAM,CAACjB,EAAWA,EAAY,CAAC,EAEzC,MAAMkB,EAAa9B,EAAM,KAAK,UAAW,KAAM,CAAC,EAChD8B,EAAW,IAAM,CAAClB,EAAWA,EAAY,CAAC,EAE1C,QAASU,EAAI,EAAGA,EAAIF,EAAQ,OAAQE,IAAK,CACvC,MAAMS,EAAW/B,EAAM,KAAK,UAAW,KAAM,CAAC,EAC1CqB,EAAOC,CAAC,IACVS,EAAS,MAAS,CAAC,CAAC,QAAS,cAAgBV,EAAOC,CAAC,CAAC,CAAC,GAGzD,MAAMU,EAAWhC,EAAM,KAAK,SAAU,GAAI,CAAC,EAC3CgC,EAAS,QAAWZ,EAAQE,CAAC,EAAE,KAAM,EACrCU,EAAS,SAAW,CAAE,EAEtBhC,EAAM,KAAK,WAAY,KAAM,EAAE,CAChC,CAEDA,EAAM,KAAK,WAAY,KAAM,EAAE,EAC/BA,EAAM,KAAK,cAAe,QAAS,EAAE,EAErC,IAAIiC,EACAC,EAAqB,EAEzB,IAAKnB,EAAWH,EAAY,EAAGG,EAAWF,GACpC,EAAAb,EAAM,OAAOe,CAAQ,EAAIf,EAAM,WADce,IAAY,CAG7D,IAAIoB,EAAY,GAChB,QAASb,EAAI,EAAGc,EAAIV,EAAgB,OAAQJ,EAAIc,EAAGd,IACjD,GAAII,EAAgBJ,CAAC,EAAEtB,EAAOe,EAAUF,EAAS,EAAI,EAAG,CACtDsB,EAAY,GACZ,KACD,CAcH,GAXIA,IACJhB,EAAWpB,EAAQC,EAAOe,CAAQ,EAAE,KAAM,EACtC,CAACI,IACDnB,EAAM,OAAOe,CAAQ,EAAIf,EAAM,WAAa,IAChDoB,EAAUhB,EAAae,CAAQ,EAC3BC,EAAQ,QAAUA,EAAQ,CAAC,IAAM,IAAIA,EAAQ,MAAO,EACpDA,EAAQ,QAAUA,EAAQA,EAAQ,OAAS,CAAC,IAAM,IAAIA,EAAQ,IAAK,EAIvEc,GAAsBV,EAAcJ,EAAQ,OACxCc,EAAqBpC,GAA2B,MAEpD,GAAIiB,IAAaH,EAAY,EAAG,CAC9B,MAAMyB,EAAYrC,EAAM,KAAK,aAAc,QAAS,CAAC,EACrDqC,EAAU,IAAMJ,EAAa,CAACrB,EAAY,EAAG,CAAC,CAC/C,CAED,MAAM0B,EAAYtC,EAAM,KAAK,UAAW,KAAM,CAAC,EAC/CsC,EAAU,IAAM,CAACvB,EAAUA,EAAW,CAAC,EAEvC,QAASO,EAAI,EAAGA,EAAIE,EAAaF,IAAK,CACpC,MAAMiB,EAAYvC,EAAM,KAAK,UAAW,KAAM,CAAC,EAC3CqB,EAAOC,CAAC,IACViB,EAAU,MAAS,CAAC,CAAC,QAAS,cAAgBlB,EAAOC,CAAC,CAAC,CAAC,GAG1D,MAAMU,EAAWhC,EAAM,KAAK,SAAU,GAAI,CAAC,EAC3CgC,EAAS,QAAWZ,EAAQE,CAAC,EAAIF,EAAQE,CAAC,EAAE,KAAI,EAAK,GACrDU,EAAS,SAAW,CAAE,EAEtBhC,EAAM,KAAK,WAAY,KAAM,EAAE,CAChC,CACDA,EAAM,KAAK,WAAY,KAAM,EAAE,CAChC,CAED,OAAIiC,IACFjC,EAAM,KAAK,cAAe,QAAS,EAAE,EACrCiC,EAAW,CAAC,EAAIlB,GAGlBf,EAAM,KAAK,cAAe,QAAS,EAAE,EACrC4B,EAAW,CAAC,EAAIb,EAEhBf,EAAM,WAAayB,EACnBzB,EAAM,KAAOe,EACN,EACT","x_google_ignoreList":[0]}