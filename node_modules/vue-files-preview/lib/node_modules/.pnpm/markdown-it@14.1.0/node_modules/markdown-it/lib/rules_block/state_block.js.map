{"version":3,"file":"state_block.js","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/state_block.mjs"],"sourcesContent":["// Parser state class\n\nimport Token from '../token.mjs'\nimport { isSpace } from '../common/utils.mjs'\n\nfunction StateBlock (src, md, env, tokens) {\n  this.src = src\n\n  // link to parser instance\n  this.md     = md\n\n  this.env = env\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens\n\n  this.bMarks = []  // line begin offsets for fast jumps\n  this.eMarks = []  // line end offsets for fast jumps\n  this.tShift = []  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = []  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = []\n\n  // block parser variables\n\n  // required block content indent (for example, if we are\n  // inside a list, it would be positioned after list marker)\n  this.blkIndent  = 0\n  this.line       = 0 // line index in src\n  this.lineMax    = 0 // lines count\n  this.tight      = false  // loose/tight mode for lists\n  this.ddIndent   = -1 // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1 // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root'\n\n  this.level = 0\n\n  // Create caches\n  // Generate markers.\n  const s = this.src\n\n  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {\n    const ch = s.charCodeAt(pos)\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4\n        } else {\n          offset++\n        }\n        continue\n      } else {\n        indent_found = true\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++ }\n      this.bMarks.push(start)\n      this.eMarks.push(pos)\n      this.tShift.push(indent)\n      this.sCount.push(offset)\n      this.bsCount.push(0)\n\n      indent_found = false\n      indent = 0\n      offset = 0\n      start = pos + 1\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length)\n  this.eMarks.push(s.length)\n  this.tShift.push(0)\n  this.sCount.push(0)\n  this.bsCount.push(0)\n\n  this.lineMax = this.bMarks.length - 1 // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  const token = new Token(type, tag, nesting)\n  token.block = true\n\n  if (nesting < 0) this.level-- // closing tag\n  token.level = this.level\n  if (nesting > 0) this.level++ // opening tag\n\n  this.tokens.push(token)\n  return token\n}\n\nStateBlock.prototype.isEmpty = function isEmpty (line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line]\n}\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines (from) {\n  for (let max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break\n    }\n  }\n  return from\n}\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces (pos) {\n  for (let max = this.src.length; pos < max; pos++) {\n    const ch = this.src.charCodeAt(pos)\n    if (!isSpace(ch)) { break }\n  }\n  return pos\n}\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack (pos, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1 }\n  }\n  return pos\n}\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars (pos, code) {\n  for (let max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break }\n  }\n  return pos\n}\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack (pos, code, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1 }\n  }\n  return pos\n}\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines (begin, end, indent, keepLastLF) {\n  if (begin >= end) {\n    return ''\n  }\n\n  const queue = new Array(end - begin)\n\n  for (let i = 0, line = begin; line < end; line++, i++) {\n    let lineIndent = 0\n    const lineStart = this.bMarks[line]\n    let first = lineStart\n    let last\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1\n    } else {\n      last = this.eMarks[line]\n    }\n\n    while (first < last && lineIndent < indent) {\n      const ch = this.src.charCodeAt(first)\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4\n        } else {\n          lineIndent++\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++\n      } else {\n        break\n      }\n\n      first++\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last)\n    } else {\n      queue[i] = this.src.slice(first, last)\n    }\n  }\n\n  return queue.join('')\n}\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token\n\nexport default StateBlock\n"],"names":["StateBlock","src","md","env","tokens","s","start","pos","indent","offset","len","indent_found","ch","isSpace","type","tag","nesting","token","Token","line","from","max","min","code","begin","end","keepLastLF","queue","i","lineIndent","lineStart","first","last"],"mappings":"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","x_google_ignoreList":[0]}