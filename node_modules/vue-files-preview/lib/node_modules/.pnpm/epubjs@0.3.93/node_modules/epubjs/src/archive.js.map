{"version":3,"file":"archive.js","sources":["../../../../../../../../node_modules/.pnpm/epubjs@0.3.93/node_modules/epubjs/src/archive.js"],"sourcesContent":["import {defer, isXml, parse} from \"./utils/core\";\nimport request from \"./utils/request\";\nimport mime from \"./utils/mime\";\nimport Path from \"./utils/path\";\nimport JSZip from \"jszip/dist/jszip\";\n\n/**\n * Handles Unzipping a requesting files from an Epub Archive\n * @class\n */\nclass Archive {\n\n\tconstructor() {\n\t\tthis.zip = undefined;\n\t\tthis.urlCache = {};\n\n\t\tthis.checkRequirements();\n\n\t}\n\n\t/**\n\t * Checks to see if JSZip exists in global namspace,\n\t * Requires JSZip if it isn't there\n\t * @private\n\t */\n\tcheckRequirements(){\n\t\ttry {\n\t\t\tthis.zip = new JSZip();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"JSZip lib not loaded\");\n\t\t}\n\t}\n\n\t/**\n\t * Open an archive\n\t * @param  {binary} input\n\t * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n\t * @return {Promise} zipfile\n\t */\n\topen(input, isBase64){\n\t\treturn this.zip.loadAsync(input, {\"base64\": isBase64});\n\t}\n\n\t/**\n\t * Load and Open an archive\n\t * @param  {string} zipUrl\n\t * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n\t * @return {Promise} zipfile\n\t */\n\topenUrl(zipUrl, isBase64){\n\t\treturn request(zipUrl, \"binary\")\n\t\t\t.then(function(data){\n\t\t\t\treturn this.zip.loadAsync(data, {\"base64\": isBase64});\n\t\t\t}.bind(this));\n\t}\n\n\t/**\n\t * Request a url from the archive\n\t * @param  {string} url  a url to request from the archive\n\t * @param  {string} [type] specify the type of the returned result\n\t * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n\t */\n\trequest(url, type){\n\t\tvar deferred = new defer();\n\t\tvar response;\n\t\tvar path = new Path(url);\n\n\t\t// If type isn't set, determine it from the file extension\n\t\tif(!type) {\n\t\t\ttype = path.extension;\n\t\t}\n\n\t\tif(type == \"blob\"){\n\t\t\tresponse = this.getBlob(url);\n\t\t} else {\n\t\t\tresponse = this.getText(url);\n\t\t}\n\n\t\tif (response) {\n\t\t\tresponse.then(function (r) {\n\t\t\t\tlet result = this.handleResponse(r, type);\n\t\t\t\tdeferred.resolve(result);\n\t\t\t}.bind(this));\n\t\t} else {\n\t\t\tdeferred.reject({\n\t\t\t\tmessage : \"File not found in the epub: \" + url,\n\t\t\t\tstack : new Error().stack\n\t\t\t});\n\t\t}\n\t\treturn deferred.promise;\n\t}\n\n\t/**\n\t * Handle the response from request\n\t * @private\n\t * @param  {any} response\n\t * @param  {string} [type]\n\t * @return {any} the parsed result\n\t */\n\thandleResponse(response, type){\n\t\tvar r;\n\n\t\tif(type == \"json\") {\n\t\t\tr = JSON.parse(response);\n\t\t}\n\t\telse\n\t\tif(isXml(type)) {\n\t\t\tr = parse(response, \"text/xml\");\n\t\t}\n\t\telse\n\t\tif(type == \"xhtml\") {\n\t\t\tr = parse(response, \"application/xhtml+xml\");\n\t\t}\n\t\telse\n\t\tif(type == \"html\" || type == \"htm\") {\n\t\t\tr = parse(response, \"text/html\");\n\t\t } else {\n\t\t\t r = response;\n\t\t }\n\n\t\treturn r;\n\t}\n\n\t/**\n\t * Get a Blob from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [mimeType]\n\t * @return {Blob}\n\t */\n\tgetBlob(url, mimeType){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\tmimeType = mimeType || mime.lookup(entry.name);\n\t\t\treturn entry.async(\"uint8array\").then(function(uint8array) {\n\t\t\t\treturn new Blob([uint8array], {type : mimeType});\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get Text from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [encoding]\n\t * @return {string}\n\t */\n\tgetText(url, encoding){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\treturn entry.async(\"string\").then(function(text) {\n\t\t\t\treturn text;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get a base64 encoded result from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [mimeType]\n\t * @return {string} base64 encoded\n\t */\n\tgetBase64(url, mimeType){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\tmimeType = mimeType || mime.lookup(entry.name);\n\t\t\treturn entry.async(\"base64\").then(function(data) {\n\t\t\t\treturn \"data:\" + mimeType + \";base64,\" + data;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create a Url from an unarchived item\n\t * @param  {string} url\n\t * @param  {object} [options.base64] use base64 encoding or blob url\n\t * @return {Promise} url promise with Url string\n\t */\n\tcreateUrl(url, options){\n\t\tvar deferred = new defer();\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tvar tempUrl;\n\t\tvar response;\n\t\tvar useBase64 = options && options.base64;\n\n\t\tif(url in this.urlCache) {\n\t\t\tdeferred.resolve(this.urlCache[url]);\n\t\t\treturn deferred.promise;\n\t\t}\n\n\t\tif (useBase64) {\n\t\t\tresponse = this.getBase64(url);\n\n\t\t\tif (response) {\n\t\t\t\tresponse.then(function(tempUrl) {\n\n\t\t\t\t\tthis.urlCache[url] = tempUrl;\n\t\t\t\t\tdeferred.resolve(tempUrl);\n\n\t\t\t\t}.bind(this));\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tresponse = this.getBlob(url);\n\n\t\t\tif (response) {\n\t\t\t\tresponse.then(function(blob) {\n\n\t\t\t\t\ttempUrl = _URL.createObjectURL(blob);\n\t\t\t\t\tthis.urlCache[url] = tempUrl;\n\t\t\t\t\tdeferred.resolve(tempUrl);\n\n\t\t\t\t}.bind(this));\n\n\t\t\t}\n\t\t}\n\n\n\t\tif (!response) {\n\t\t\tdeferred.reject({\n\t\t\t\tmessage : \"File not found in the epub: \" + url,\n\t\t\t\tstack : new Error().stack\n\t\t\t});\n\t\t}\n\n\t\treturn deferred.promise;\n\t}\n\n\t/**\n\t * Revoke Temp Url for a archive item\n\t * @param  {string} url url of the item in the archive\n\t */\n\trevokeUrl(url){\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tvar fromCache = this.urlCache[url];\n\t\tif(fromCache) _URL.revokeObjectURL(fromCache);\n\t}\n\n\tdestroy() {\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tfor (let fromCache in this.urlCache) {\n\t\t\t_URL.revokeObjectURL(fromCache);\n\t\t}\n\t\tthis.zip = undefined;\n\t\tthis.urlCache = {};\n\t}\n}\n\nexport default Archive;\n"],"names":["Archive","JSZip","input","isBase64","zipUrl","request","data","url","type","deferred","defer","response","path","Path","r","result","isXml","parse","mimeType","decodededUrl","entry","mime","uint8array","encoding","text","options","_URL","tempUrl","useBase64","blob","fromCache"],"mappings":"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","x_google_ignoreList":[0]}