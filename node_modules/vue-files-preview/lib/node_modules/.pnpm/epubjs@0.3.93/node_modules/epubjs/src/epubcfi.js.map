{"version":3,"file":"epubcfi.js","sources":["../../../../../../../../node_modules/.pnpm/epubjs@0.3.93/node_modules/epubjs/src/epubcfi.js"],"sourcesContent":["import {extend, type, findChildren, RangeObject, isNumber} from \"./utils/core\";\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\n\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\nclass EpubCFI {\n\tconstructor(cfiFrom, base, ignoreClass){\n\t\tvar type;\n\n\t\tthis.str = \"\";\n\n\t\tthis.base = {};\n\t\tthis.spinePos = 0; // For compatibility\n\n\t\tthis.range = false; // true || false;\n\n\t\tthis.path = {};\n\t\tthis.start = null;\n\t\tthis.end = null;\n\n\t\t// Allow instantiation without the \"new\" keyword\n\t\tif (!(this instanceof EpubCFI)) {\n\t\t\treturn new EpubCFI(cfiFrom, base, ignoreClass);\n\t\t}\n\n\t\tif(typeof base === \"string\") {\n\t\t\tthis.base = this.parseComponent(base);\n\t\t} else if(typeof base === \"object\" && base.steps) {\n\t\t\tthis.base = base;\n\t\t}\n\n\t\ttype = this.checkType(cfiFrom);\n\n\n\t\tif(type === \"string\") {\n\t\t\tthis.str = cfiFrom;\n\t\t\treturn extend(this, this.parse(cfiFrom));\n\t\t} else if (type === \"range\") {\n\t\t\treturn extend(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"node\") {\n\t\t\treturn extend(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"EpubCFI\" && cfiFrom.path) {\n\t\t\treturn cfiFrom;\n\t\t} else if (!cfiFrom) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new TypeError(\"not a valid argument for EpubCFI\");\n\t\t}\n\n\t}\n\n\t/**\n\t * Check the type of constructor input\n\t * @private\n\t */\n\tcheckType(cfi) {\n\n\t\tif (this.isCfiString(cfi)) {\n\t\t\treturn \"string\";\n\t\t// Is a range object\n\t\t} else if (cfi && typeof cfi === \"object\" && (type(cfi) === \"Range\" || typeof(cfi.startContainer) != \"undefined\")){\n\t\t\treturn \"range\";\n\t\t} else if (cfi && typeof cfi === \"object\" && typeof(cfi.nodeType) != \"undefined\" ){ // || typeof cfi === \"function\"\n\t\t\treturn \"node\";\n\t\t} else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI){\n\t\t\treturn \"EpubCFI\";\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a cfi string to a CFI object representation\n\t * @param {string} cfiStr\n\t * @returns {object} cfi\n\t */\n\tparse(cfiStr) {\n\t\tvar cfi = {\n\t\t\tspinePos: -1,\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\t\tvar baseComponent, pathComponent, range;\n\n\t\tif(typeof cfiStr !== \"string\") {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tif(cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length-1] === \")\") {\n\t\t\t// Remove initial epubcfi( and ending )\n\t\t\tcfiStr = cfiStr.slice(8, cfiStr.length-1);\n\t\t}\n\n\t\tbaseComponent = this.getChapterComponent(cfiStr);\n\n\t\t// Make sure this is a valid cfi or return\n\t\tif(!baseComponent) {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tcfi.base = this.parseComponent(baseComponent);\n\n\t\tpathComponent = this.getPathComponent(cfiStr);\n\t\tcfi.path = this.parseComponent(pathComponent);\n\n\t\trange = this.getRange(cfiStr);\n\n\t\tif(range) {\n\t\t\tcfi.range = true;\n\t\t\tcfi.start = this.parseComponent(range[0]);\n\t\t\tcfi.end = this.parseComponent(range[1]);\n\t\t}\n\n\t\t// Get spine node position\n\t\t// cfi.spineSegment = cfi.base.steps[1];\n\n\t\t// Chapter segment is always the second step\n\t\tcfi.spinePos = cfi.base.steps[1].index;\n\n\t\treturn cfi;\n\t}\n\n\tparseComponent(componentStr){\n\t\tvar component = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar parts = componentStr.split(\":\");\n\t\tvar steps = parts[0].split(\"/\");\n\t\tvar terminal;\n\n\t\tif(parts.length > 1) {\n\t\t\tterminal = parts[1];\n\t\t\tcomponent.terminal = this.parseTerminal(terminal);\n\t\t}\n\n\t\tif (steps[0] === \"\") {\n\t\t\tsteps.shift(); // Ignore the first slash\n\t\t}\n\n\t\tcomponent.steps = steps.map(function(step){\n\t\t\treturn this.parseStep(step);\n\t\t}.bind(this));\n\n\t\treturn component;\n\t}\n\n\tparseStep(stepStr){\n\t\tvar type, num, index, has_brackets, id;\n\n\t\thas_brackets = stepStr.match(/\\[(.*)\\]/);\n\t\tif(has_brackets && has_brackets[1]){\n\t\t\tid = has_brackets[1];\n\t\t}\n\n\t\t//-- Check if step is a text node or element\n\t\tnum = parseInt(stepStr);\n\n\t\tif(isNaN(num)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(num % 2 === 0) { // Even = is an element\n\t\t\ttype = \"element\";\n\t\t\tindex = num / 2 - 1;\n\t\t} else {\n\t\t\ttype = \"text\";\n\t\t\tindex = (num - 1 ) / 2;\n\t\t}\n\n\t\treturn {\n\t\t\t\"type\" : type,\n\t\t\t\"index\" : index,\n\t\t\t\"id\" : id || null\n\t\t};\n\t}\n\n\tparseTerminal(termialStr){\n\t\tvar characterOffset, textLocationAssertion;\n\t\tvar assertion = termialStr.match(/\\[(.*)\\]/);\n\n\t\tif(assertion && assertion[1]){\n\t\t\tcharacterOffset = parseInt(termialStr.split(\"[\")[0]);\n\t\t\ttextLocationAssertion = assertion[1];\n\t\t} else {\n\t\t\tcharacterOffset = parseInt(termialStr);\n\t\t}\n\n\t\tif (!isNumber(characterOffset)) {\n\t\t\tcharacterOffset = null;\n\t\t}\n\n\t\treturn {\n\t\t\t\"offset\": characterOffset,\n\t\t\t\"assertion\": textLocationAssertion\n\t\t};\n\n\t}\n\n\tgetChapterComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\treturn indirection[0];\n\t}\n\n\tgetPathComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\tif(indirection[1]) {\n\t\t\tlet ranges = indirection[1].split(\",\");\n\t\t\treturn ranges[0];\n\t\t}\n\n\t}\n\n\tgetRange(cfiStr) {\n\n\t\tvar ranges = cfiStr.split(\",\");\n\n\t\tif(ranges.length === 3){\n\t\t\treturn [\n\t\t\t\tranges[1],\n\t\t\t\tranges[2]\n\t\t\t];\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetCharecterOffsetComponent(cfiStr) {\n\t\tvar splitStr = cfiStr.split(\":\");\n\t\treturn splitStr[1] || \"\";\n\t}\n\n\tjoinSteps(steps) {\n\t\tif(!steps) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn steps.map(function(part){\n\t\t\tvar segment = \"\";\n\n\t\t\tif(part.type === \"element\") {\n\t\t\t\tsegment += (part.index + 1) * 2;\n\t\t\t}\n\n\t\t\tif(part.type === \"text\") {\n\t\t\t\tsegment += 1 + (2 * part.index); // TODO: double check that this is odd\n\t\t\t}\n\n\t\t\tif(part.id) {\n\t\t\t\tsegment += \"[\" + part.id + \"]\";\n\t\t\t}\n\n\t\t\treturn segment;\n\n\t\t}).join(\"/\");\n\n\t}\n\n\tsegmentString(segment) {\n\t\tvar segmentString = \"/\";\n\n\t\tsegmentString += this.joinSteps(segment.steps);\n\n\t\tif(segment.terminal && segment.terminal.offset != null){\n\t\t\tsegmentString += \":\" + segment.terminal.offset;\n\t\t}\n\n\t\tif(segment.terminal && segment.terminal.assertion != null){\n\t\t\tsegmentString += \"[\" + segment.terminal.assertion + \"]\";\n\t\t}\n\n\t\treturn segmentString;\n\t}\n\n\t/**\n\t * Convert CFI to a epubcfi(...) string\n\t * @returns {string} epubcfi\n\t */\n\ttoString() {\n\t\tvar cfiString = \"epubcfi(\";\n\n\t\tcfiString += this.segmentString(this.base);\n\n\t\tcfiString += \"!\";\n\t\tcfiString += this.segmentString(this.path);\n\n\t\t// Add Range, if present\n\t\tif(this.range && this.start) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.start);\n\t\t}\n\n\t\tif(this.range && this.end) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.end);\n\t\t}\n\n\t\tcfiString += \")\";\n\n\t\treturn cfiString;\n\t}\n\n\n\t/**\n\t * Compare which of two CFIs is earlier in the text\n\t * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n\t */\n\tcompare(cfiOne, cfiTwo) {\n\t\tvar stepsA, stepsB;\n\t\tvar terminalA, terminalB;\n\n\t\tvar rangeAStartSteps, rangeAEndSteps;\n\t\tvar rangeBEndSteps, rangeBEndSteps;\n\t\tvar rangeAStartTerminal, rangeAEndTerminal;\n\t\tvar rangeBStartTerminal, rangeBEndTerminal;\n\n\t\tif(typeof cfiOne === \"string\") {\n\t\t\tcfiOne = new EpubCFI(cfiOne);\n\t\t}\n\t\tif(typeof cfiTwo === \"string\") {\n\t\t\tcfiTwo = new EpubCFI(cfiTwo);\n\t\t}\n\t\t// Compare Spine Positions\n\t\tif(cfiOne.spinePos > cfiTwo.spinePos) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(cfiOne.spinePos < cfiTwo.spinePos) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (cfiOne.range) {\n\t\t\tstepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n\t\t\tterminalA = cfiOne.start.terminal;\n\t\t} else {\n\t\t\tstepsA = cfiOne.path.steps;\n\t\t\tterminalA = cfiOne.path.terminal;\n\t\t}\n\n\t\tif (cfiTwo.range) {\n\t\t\tstepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n\t\t\tterminalB = cfiTwo.start.terminal;\n\t\t} else {\n\t\t\tstepsB = cfiTwo.path.steps;\n\t\t\tterminalB = cfiTwo.path.terminal;\n\t\t}\n\n\t\t// Compare Each Step in the First item\n\t\tfor (var i = 0; i < stepsA.length; i++) {\n\t\t\tif(!stepsA[i]) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(!stepsB[i]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index > stepsB[i].index) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index < stepsB[i].index) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// Otherwise continue checking\n\t\t}\n\n\t\t// All steps in First equal to Second and First is Less Specific\n\t\tif(stepsA.length < stepsB.length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Compare the character offset of the text node\n\t\tif(terminalA.offset > terminalB.offset) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(terminalA.offset < terminalB.offset) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// CFI's are equal\n\t\treturn 0;\n\t}\n\n\tstep(node) {\n\t\tvar nodeType = (node.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : node.id,\n\t\t\t\"tagName\" : node.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.position(node)\n\t\t};\n\t}\n\n\tfilteredStep(node, ignoreClass) {\n\t\tvar filteredNode = this.filter(node, ignoreClass);\n\t\tvar nodeType;\n\n\t\t// Node filtered, so ignore\n\t\tif (!filteredNode) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise add the filter node in\n\t\tnodeType = (filteredNode.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : filteredNode.id,\n\t\t\t\"tagName\" : filteredNode.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.filteredPosition(filteredNode, ignoreClass)\n\t\t};\n\t}\n\n\tpathTo(node, offset, ignoreClass) {\n\t\tvar segment = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar currentNode = node;\n\t\tvar step;\n\n\t\twhile(currentNode && currentNode.parentNode &&\n\t\t\t\t\tcurrentNode.parentNode.nodeType != DOCUMENT_NODE) {\n\n\t\t\tif (ignoreClass) {\n\t\t\t\tstep = this.filteredStep(currentNode, ignoreClass);\n\t\t\t} else {\n\t\t\t\tstep = this.step(currentNode);\n\t\t\t}\n\n\t\t\tif (step) {\n\t\t\t\tsegment.steps.unshift(step);\n\t\t\t}\n\n\t\t\tcurrentNode = currentNode.parentNode;\n\n\t\t}\n\n\t\tif (offset != null && offset >= 0) {\n\n\t\t\tsegment.terminal.offset = offset;\n\n\t\t\t// Make sure we are getting to a textNode if there is an offset\n\t\t\tif(segment.steps[segment.steps.length-1].type != \"text\") {\n\t\t\t\tsegment.steps.push({\n\t\t\t\t\t\"type\" : \"text\",\n\t\t\t\t\t\"index\" : 0\n\t\t\t\t});\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn segment;\n\t}\n\n\tequalStep(stepA, stepB) {\n\t\tif (!stepA || !stepB) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(stepA.index === stepB.index &&\n\t\t\t stepA.id === stepB.id &&\n\t\t\t stepA.type === stepB.type) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create a CFI object from a Range\n\t * @param {Range} range\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromRange(range, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tvar start = range.startContainer;\n\t\tvar end = range.endContainer;\n\n\t\tvar startOffset = range.startOffset;\n\t\tvar endOffset = range.endOffset;\n\n\t\tvar needsIgnoring = false;\n\n\t\tif (ignoreClass) {\n\t\t\t// Tell pathTo if / what to ignore\n\t\t\tneedsIgnoring = (start.ownerDocument.querySelector(\".\" + ignoreClass) != null);\n\t\t}\n\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tif (range.collapsed) {\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\t\t\tcfi.path = this.pathTo(start, startOffset, ignoreClass);\n\t\t} else {\n\t\t\tcfi.range = true;\n\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.start = this.pathTo(start, startOffset, ignoreClass);\n\t\t\tif (needsIgnoring) {\n\t\t\t\tendOffset = this.patchOffset(end, endOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.end = this.pathTo(end, endOffset, ignoreClass);\n\n\t\t\t// Create a new empty path\n\t\t\tcfi.path = {\n\t\t\t\tsteps: [],\n\t\t\t\tterminal: null\n\t\t\t};\n\n\t\t\t// Push steps that are shared between start and end to the common path\n\t\t\tvar len = cfi.start.steps.length;\n\t\t\tvar i;\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n\t\t\t\t\tif(i === len-1) {\n\t\t\t\t\t\t// Last step is equal, check terminals\n\t\t\t\t\t\tif(cfi.start.terminal === cfi.end.terminal) {\n\t\t\t\t\t\t\t// CFI's are equal\n\t\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t\t\t// Not a range\n\t\t\t\t\t\t\tcfi.range = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n\t\t\tcfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);\n\n\t\t\t// TODO: Add Sanity check to make sure that the end if greater than the start\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Create a CFI object from a Node\n\t * @param {Node} anchor\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromNode(anchor, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tcfi.path = this.pathTo(anchor, null, ignoreClass);\n\n\t\treturn cfi;\n\t}\n\n\tfilter(anchor, ignoreClass) {\n\t\tvar needsIgnoring;\n\t\tvar sibling; // to join with\n\t\tvar parent, previousSibling, nextSibling;\n\t\tvar isText = false;\n\n\t\tif (anchor.nodeType === TEXT_NODE) {\n\t\t\tisText = true;\n\t\t\tparent = anchor.parentNode;\n\t\t\tneedsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n\t\t} else {\n\t\t\tisText = false;\n\t\t\tneedsIgnoring = anchor.classList.contains(ignoreClass);\n\t\t}\n\n\t\tif (needsIgnoring && isText) {\n\t\t\tpreviousSibling = parent.previousSibling;\n\t\t\tnextSibling = parent.nextSibling;\n\n\t\t\t// If the sibling is a text node, join the nodes\n\t\t\tif (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = previousSibling;\n\t\t\t} else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = nextSibling;\n\t\t\t}\n\n\t\t\tif (sibling) {\n\t\t\t\treturn sibling;\n\t\t\t} else {\n\t\t\t\t// Parent will be ignored on next step\n\t\t\t\treturn anchor;\n\t\t\t}\n\n\t\t} else if (needsIgnoring && !isText) {\n\t\t\t// Otherwise just skip the element node\n\t\t\treturn false;\n\t\t} else {\n\t\t\t// No need to filter\n\t\t\treturn anchor;\n\t\t}\n\n\t}\n\n\tpatchOffset(anchor, offset, ignoreClass) {\n\t\tif (anchor.nodeType != TEXT_NODE) {\n\t\t\tthrow new Error(\"Anchor must be a text node\");\n\t\t}\n\n\t\tvar curr = anchor;\n\t\tvar totalOffset = offset;\n\n\t\t// If the parent is a ignored node, get offset from it's start\n\t\tif (anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\tcurr = anchor.parentNode;\n\t\t}\n\n\t\twhile (curr.previousSibling) {\n\t\t\tif(curr.previousSibling.nodeType === ELEMENT_NODE) {\n\t\t\t\t// Originally a text node, so join\n\t\t\t\tif(curr.previousSibling.classList.contains(ignoreClass)){\n\t\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t\t} else {\n\t\t\t\t\tbreak; // Normal node, dont join\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If the previous sibling is a text node, join the nodes\n\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t}\n\n\t\t\tcurr = curr.previousSibling;\n\t\t}\n\n\t\treturn totalOffset;\n\n\t}\n\n\tnormalizedMap(children, nodeType, ignoreClass) {\n\t\tvar output = {};\n\t\tvar prevIndex = -1;\n\t\tvar i, len = children.length;\n\t\tvar currNodeType;\n\t\tvar prevNodeType;\n\n\t\tfor (i = 0; i < len; i++) {\n\n\t\t\tcurrNodeType = children[i].nodeType;\n\n\t\t\t// Check if needs ignoring\n\t\t\tif (currNodeType === ELEMENT_NODE &&\n\t\t\t\t\tchildren[i].classList.contains(ignoreClass)) {\n\t\t\t\tcurrNodeType = TEXT_NODE;\n\t\t\t}\n\n\t\t\tif (i > 0 &&\n\t\t\t\t\tcurrNodeType === TEXT_NODE &&\n\t\t\t\t\tprevNodeType === TEXT_NODE) {\n\t\t\t\t// join text nodes\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t} else if (nodeType === currNodeType){\n\t\t\t\tprevIndex = prevIndex + 1;\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t}\n\n\t\t\tprevNodeType = currNodeType;\n\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tposition(anchor) {\n\t\tvar children, index;\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tif (!children) {\n\t\t\t\tchildren = findChildren(anchor.parentNode);\n\t\t\t}\n\t\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\t\t} else {\n\t\t\tchildren = this.textNodes(anchor.parentNode);\n\t\t\tindex = children.indexOf(anchor);\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfilteredPosition(anchor, ignoreClass) {\n\t\tvar children, index, map;\n\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tmap = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n\t\t} else {\n\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t// Inside an ignored node\n\t\t\tif(anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\t\tanchor = anchor.parentNode;\n\t\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t}\n\t\t\tmap = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\t}\n\n\n\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\n\t\treturn map[index];\n\t}\n\n\tstepsToXpath(steps) {\n\t\tvar xpath = [\".\", \"*\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\txpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\txpath.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\txpath.push(\"*[\" + position + \"]\");\n\t\t\t}\n\t\t});\n\n\t\treturn xpath.join(\"/\");\n\t}\n\n\n\t/*\n\n\tTo get the last step if needed:\n\n\t// Get the terminal step\n\tlastStep = steps[steps.length-1];\n\t// Get the query string\n\tquery = this.stepsToQuery(steps);\n\t// Find the containing element\n\tstartContainerParent = doc.querySelector(query);\n\t// Find the text node within that element\n\tif(startContainerParent && lastStep.type == \"text\") {\n\t\tcontainer = startContainerParent.childNodes[lastStep.index];\n\t}\n\t*/\n\tstepsToQuerySelector(steps) {\n\t\tvar query = [\"html\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\tquery.push(\"#\" + step.id);\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\t// unsupported in querySelector\n\t\t\t\t// query.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\tquery.push(\"*:nth-child(\" + position + \")\");\n\t\t\t}\n\t\t});\n\n\t\treturn query.join(\">\");\n\n\t}\n\n\ttextNodes(container, ignoreClass) {\n\t\treturn Array.prototype.slice.call(container.childNodes).\n\t\t\tfilter(function (node) {\n\t\t\t\tif (node.nodeType === TEXT_NODE) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (ignoreClass && node.classList.contains(ignoreClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t}\n\n\twalkToNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container = doc.documentElement;\n\t\tvar children;\n\t\tvar step;\n\t\tvar len = steps.length;\n\t\tvar i;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tstep = steps[i];\n\n\t\t\tif(step.type === \"element\") {\n\t\t\t\t//better to get a container using id as some times step.index may not be correct\n\t\t\t\t//For ex.https://github.com/futurepress/epub.js/issues/561\n\t\t\t\tif(step.id) {\n\t\t\t\t\tcontainer = doc.getElementById(step.id);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildren = container.children || findChildren(container);\n\t\t\t\t\tcontainer = children[step.index];\n\t\t\t\t}\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\tcontainer = this.textNodes(container, ignoreClass)[step.index];\n\t\t\t}\n\t\t\tif(!container) {\n\t\t\t\t//Break the for loop as due to incorrect index we can get error if\n\t\t\t\t//container is undefined so that other functionailties works fine\n\t\t\t\t//like navigation\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfindNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container;\n\t\tvar xpath;\n\n\t\tif(!ignoreClass && typeof doc.evaluate != \"undefined\") {\n\t\t\txpath = this.stepsToXpath(steps);\n\t\t\tcontainer = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\t\t} else if(ignoreClass) {\n\t\t\tcontainer = this.walkToNode(steps, doc, ignoreClass);\n\t\t} else {\n\t\t\tcontainer = this.walkToNode(steps, doc);\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfixMiss(steps, offset, _doc, ignoreClass) {\n\t\tvar container = this.findNode(steps.slice(0,-1), _doc, ignoreClass);\n\t\tvar children = container.childNodes;\n\t\tvar map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\tvar child;\n\t\tvar len;\n\t\tvar lastStepIndex = steps[steps.length-1].index;\n\n\t\tfor (let childIndex in map) {\n\t\t\tif (!map.hasOwnProperty(childIndex)) return;\n\n\t\t\tif(map[childIndex] === lastStepIndex) {\n\t\t\t\tchild = children[childIndex];\n\t\t\t\tlen = child.textContent.length;\n\t\t\t\tif(offset > len) {\n\t\t\t\t\toffset = offset - len;\n\t\t\t\t} else {\n\t\t\t\t\tif (child.nodeType === ELEMENT_NODE) {\n\t\t\t\t\t\tcontainer = child.childNodes[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainer = child;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcontainer: container,\n\t\t\toffset: offset\n\t\t};\n\n\t}\n\n\t/**\n\t * Creates a DOM range representing a CFI\n\t * @param {document} _doc document referenced in the base\n\t * @param {string} [ignoreClass]\n\t * @return {Range}\n\t */\n\ttoRange(_doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar range;\n\t\tvar start, end, startContainer, endContainer;\n\t\tvar cfi = this;\n\t\tvar startSteps, endSteps;\n\t\tvar needsIgnoring = ignoreClass ? (doc.querySelector(\".\" + ignoreClass) != null) : false;\n\t\tvar missed;\n\n\t\tif (typeof(doc.createRange) !== \"undefined\") {\n\t\t\trange = doc.createRange();\n\t\t} else {\n\t\t\trange = new RangeObject();\n\t\t}\n\n\t\tif (cfi.range) {\n\t\t\tstart = cfi.start;\n\t\t\tstartSteps = cfi.path.steps.concat(start.steps);\n\t\t\tstartContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t\tend = cfi.end;\n\t\t\tendSteps = cfi.path.steps.concat(end.steps);\n\t\t\tendContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t} else {\n\t\t\tstart = cfi.path;\n\t\t\tstartSteps = cfi.path.steps;\n\t\t\tstartContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n\t\t}\n\n\t\tif(startContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(start.terminal.offset != null) {\n\t\t\t\t\trange.setStart(startContainer, start.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setStart(startContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setStart(missed.container, missed.offset);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log(\"No startContainer found for\", this.toString());\n\t\t\t// No start found\n\t\t\treturn null;\n\t\t}\n\n\t\tif (endContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(end.terminal.offset != null) {\n\t\t\t\t\trange.setEnd(endContainer, end.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setEnd(endContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setEnd(missed.container, missed.offset);\n\t\t\t}\n\t\t}\n\n\n\t\t// doc.defaultView.getSelection().addRange(range);\n\t\treturn range;\n\t}\n\n\t/**\n\t * Check if a string is wrapped with \"epubcfi()\"\n\t * @param {string} str\n\t * @returns {boolean}\n\t */\n\tisCfiString(str) {\n\t\tif(typeof str === \"string\" &&\n\t\t\tstr.indexOf(\"epubcfi(\") === 0 &&\n\t\t\tstr[str.length-1] === \")\") {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgenerateChapterComponent(_spineNodeIndex, _pos, id) {\n\t\tvar pos = parseInt(_pos),\n\t\t\t\tspineNodeIndex = (_spineNodeIndex + 1) * 2,\n\t\t\t\tcfi = \"/\"+spineNodeIndex+\"/\";\n\n\t\tcfi += (pos + 1) * 2;\n\n\t\tif(id) {\n\t\t\tcfi += \"[\" + id + \"]\";\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Collapse a CFI Range to a single CFI Position\n\t * @param {boolean} [toStart=false]\n\t */\n\tcollapse(toStart) {\n\t\tif (!this.range) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.range = false;\n\n\t\tif (toStart) {\n\t\t\tthis.path.steps = this.path.steps.concat(this.start.steps);\n\t\t\tthis.path.terminal = this.start.terminal;\n\t\t} else {\n\t\t\tthis.path.steps = this.path.steps.concat(this.end.steps);\n\t\t\tthis.path.terminal = this.end.terminal;\n\t\t}\n\n\t}\n}\n\nexport default EpubCFI;\n"],"names":["ELEMENT_NODE","TEXT_NODE","DOCUMENT_NODE","EpubCFI","cfiFrom","base","ignoreClass","type","extend","cfi","cfiStr","baseComponent","pathComponent","range","componentStr","component","parts","steps","terminal","step","stepStr","num","index","has_brackets","id","termialStr","characterOffset","textLocationAssertion","assertion","isNumber","indirection","ranges","splitStr","part","segment","segmentString","cfiString","cfiOne","cfiTwo","stepsA","stepsB","terminalA","terminalB","i","node","nodeType","filteredNode","offset","currentNode","stepA","stepB","start","end","startOffset","endOffset","needsIgnoring","len","anchor","sibling","parent","previousSibling","nextSibling","isText","curr","totalOffset","children","output","prevIndex","currNodeType","prevNodeType","findChildren","map","xpath","position","query","container","_doc","doc","child","lastStepIndex","childIndex","startContainer","endContainer","startSteps","endSteps","missed","RangeObject","str","_spineNodeIndex","_pos","pos","spineNodeIndex","toStart"],"mappings":"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","x_google_ignoreList":[0]}