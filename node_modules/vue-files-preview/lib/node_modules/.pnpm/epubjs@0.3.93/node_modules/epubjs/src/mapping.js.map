{"version":3,"file":"mapping.js","sources":["../../../../../../../../node_modules/.pnpm/epubjs@0.3.93/node_modules/epubjs/src/mapping.js"],"sourcesContent":["import EpubCFI from \"./epubcfi\";\nimport { nodeBounds } from \"./utils/core\";\n\n/**\n * Map text locations to CFI ranges\n * @class\n * @param {Layout} layout Layout to apply\n * @param {string} [direction=\"ltr\"] Text direction\n * @param {string} [axis=\"horizontal\"] vertical or horizontal axis\n * @param {boolean} [dev] toggle developer highlighting\n */\nclass Mapping {\n\tconstructor(layout, direction, axis, dev=false) {\n\t\tthis.layout = layout;\n\t\tthis.horizontal = (axis === \"horizontal\") ? true : false;\n\t\tthis.direction = direction || \"ltr\";\n\t\tthis._dev = dev;\n\t}\n\n\t/**\n\t * Find CFI pairs for entire section at once\n\t */\n\tsection(view) {\n\t\tvar ranges = this.findRanges(view);\n\t\tvar map = this.rangeListToCfiList(view.section.cfiBase, ranges);\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Find CFI pairs for a page\n\t * @param {Contents} contents Contents from view\n\t * @param {string} cfiBase string of the base for a cfi\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t */\n\tpage(contents, cfiBase, start, end) {\n\t\tvar root = contents && contents.document ? contents.document.body : false;\n\t\tvar result;\n\n\t\tif (!root) {\n\t\t\treturn;\n\t\t}\n\n\t\tresult = this.rangePairToCfiPair(cfiBase, {\n\t\t\tstart: this.findStart(root, start, end),\n\t\t\tend: this.findEnd(root, start, end)\n\t\t});\n\n\t\tif (this._dev === true) {\n\t\t\tlet doc = contents.document;\n\t\t\tlet startRange = new EpubCFI(result.start).toRange(doc);\n\t\t\tlet endRange = new EpubCFI(result.end).toRange(doc);\n\n\t\t\tlet selection = doc.defaultView.getSelection();\n\t\t\tlet r = doc.createRange();\n\t\t\tselection.removeAllRanges();\n\t\t\tr.setStart(startRange.startContainer, startRange.startOffset);\n\t\t\tr.setEnd(endRange.endContainer, endRange.endOffset);\n\t\t\tselection.addRange(r);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Walk a node, preforming a function on each node it finds\n\t * @private\n\t * @param {Node} root Node to walkToNode\n\t * @param {function} func walk function\n\t * @return {*} returns the result of the walk function\n\t */\n\twalk(root, func) {\n\t\t// IE11 has strange issue, if root is text node IE throws exception on\n\t\t// calling treeWalker.nextNode(), saying\n\t\t// Unexpected call to method or property access instead of returning null value\n\t\tif(root && root.nodeType === Node.TEXT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\t// safeFilter is required so that it can work in IE as filter is a function for IE\n\t\t// and for other browser filter is an object.\n\t\tvar filter = {\n\t\t\tacceptNode: function(node) {\n\t\t\t\tif (node.data.trim().length > 0) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t} else {\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tvar safeFilter = filter.acceptNode;\n\t\tsafeFilter.acceptNode = filter.acceptNode;\n\n\t\tvar treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);\n\t\tvar node;\n\t\tvar result;\n\t\twhile ((node = treeWalker.nextNode())) {\n\t\t\tresult = func(node);\n\t\t\tif(result) break;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfindRanges(view){\n\t\tvar columns = [];\n\t\tvar scrollWidth = view.contents.scrollWidth();\n\t\tvar spreads = Math.ceil( scrollWidth / this.layout.spreadWidth);\n\t\tvar count = spreads * this.layout.divisor;\n\t\tvar columnWidth = this.layout.columnWidth;\n\t\tvar gap = this.layout.gap;\n\t\tvar start, end;\n\n\t\tfor (var i = 0; i < count.pages; i++) {\n\t\t\tstart = (columnWidth + gap) * i;\n\t\t\tend = (columnWidth * (i+1)) + (gap * i);\n\t\t\tcolumns.push({\n\t\t\t\tstart: this.findStart(view.document.body, start, end),\n\t\t\t\tend: this.findEnd(view.document.body, start, end)\n\t\t\t});\n\t\t}\n\n\t\treturn columns;\n\t}\n\n\t/**\n\t * Find Start Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindStart(root, start, end){\n\t\tvar stack = [root];\n\t\tvar $el;\n\t\tvar found;\n\t\tvar $prev = root;\n\n\t\twhile (stack.length) {\n\n\t\t\t$el = stack.shift();\n\n\t\t\tfound = this.walk($el, (node) => {\n\t\t\t\tvar left, right, top, bottom;\n\t\t\t\tvar elPos;\n\t\t\t\tvar elRange;\n\n\n\t\t\t\telPos = nodeBounds(node);\n\n\t\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\t\tleft = this.horizontal ? elPos.left : elPos.top;\n\t\t\t\t\tright = this.horizontal ? elPos.right : elPos.bottom;\n\n\t\t\t\t\tif( left >= start && left <= end ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (right > start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\t\tleft = elPos.left;\n\t\t\t\t\tright = elPos.right;\n\n\t\t\t\t\tif( right <= end && right >= start ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (left < end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttop = elPos.top;\n\t\t\t\t\tbottom = elPos.bottom;\n\n\t\t\t\t\tif( top >= start && top <= end ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (bottom > start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t});\n\n\t\t\tif(found) {\n\t\t\t\treturn this.findTextStartRange(found, start, end);\n\t\t\t}\n\n\t\t}\n\n\t\t// Return last element\n\t\treturn this.findTextStartRange($prev, start, end);\n\t}\n\n\t/**\n\t * Find End Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindEnd(root, start, end){\n\t\tvar stack = [root];\n\t\tvar $el;\n\t\tvar $prev = root;\n\t\tvar found;\n\n\t\twhile (stack.length) {\n\n\t\t\t$el = stack.shift();\n\n\t\t\tfound = this.walk($el, (node) => {\n\n\t\t\t\tvar left, right, top, bottom;\n\t\t\t\tvar elPos;\n\t\t\t\tvar elRange;\n\n\t\t\t\telPos = nodeBounds(node);\n\n\t\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\t\tleft = Math.round(elPos.left);\n\t\t\t\t\tright = Math.round(elPos.right);\n\n\t\t\t\t\tif(left > end && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(right > end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\t\tleft = Math.round(this.horizontal ? elPos.left : elPos.top);\n\t\t\t\t\tright = Math.round(this.horizontal ? elPos.right : elPos.bottom);\n\n\t\t\t\t\tif(right < start && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(left < start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttop = Math.round(elPos.top);\n\t\t\t\t\tbottom = Math.round(elPos.bottom);\n\n\t\t\t\t\tif(top > end && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(bottom > end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t});\n\n\n\t\t\tif(found){\n\t\t\t\treturn this.findTextEndRange(found, start, end);\n\t\t\t}\n\n\t\t}\n\n\t\t// end of chapter\n\t\treturn this.findTextEndRange($prev, start, end);\n\t}\n\n\t/**\n\t * Find Text Start Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindTextStartRange(node, start, end){\n\t\tvar ranges = this.splitTextNodeIntoRanges(node);\n\t\tvar range;\n\t\tvar pos;\n\t\tvar left, top, right;\n\n\t\tfor (var i = 0; i < ranges.length; i++) {\n\t\t\trange = ranges[i];\n\n\t\t\tpos = range.getBoundingClientRect();\n\n\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\tleft = pos.left;\n\t\t\t\tif( left >= start ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\tright = pos.right;\n\t\t\t\tif( right <= end ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttop = pos.top;\n\t\t\t\tif( top >= start ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// prev = range;\n\n\t\t}\n\n\t\treturn ranges[0];\n\t}\n\n\t/**\n\t * Find Text End Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindTextEndRange(node, start, end){\n\t\tvar ranges = this.splitTextNodeIntoRanges(node);\n\t\tvar prev;\n\t\tvar range;\n\t\tvar pos;\n\t\tvar left, right, top, bottom;\n\n\t\tfor (var i = 0; i < ranges.length; i++) {\n\t\t\trange = ranges[i];\n\n\t\t\tpos = range.getBoundingClientRect();\n\n\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\tleft = pos.left;\n\t\t\t\tright = pos.right;\n\n\t\t\t\tif(left > end && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(right > end) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\tleft = pos.left\n\t\t\t\tright = pos.right;\n\n\t\t\t\tif(right < start && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(left < start) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttop = pos.top;\n\t\t\t\tbottom = pos.bottom;\n\n\t\t\t\tif(top > end && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(bottom > end) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tprev = range;\n\n\t\t}\n\n\t\t// Ends before limit\n\t\treturn ranges[ranges.length-1];\n\n\t}\n\n\t/**\n\t * Split up a text node into ranges for each word\n\t * @private\n\t * @param {Node} root root node\n\t * @param {string} [_splitter] what to split on\n\t * @return {Range[]}\n\t */\n\tsplitTextNodeIntoRanges(node, _splitter){\n\t\tvar ranges = [];\n\t\tvar textContent = node.textContent || \"\";\n\t\tvar text = textContent.trim();\n\t\tvar range;\n\t\tvar doc = node.ownerDocument;\n\t\tvar splitter = _splitter || \" \";\n\n\t\tvar pos = text.indexOf(splitter);\n\n\t\tif(pos === -1 || node.nodeType != Node.TEXT_NODE) {\n\t\t\trange = doc.createRange();\n\t\t\trange.selectNodeContents(node);\n\t\t\treturn [range];\n\t\t}\n\n\t\trange = doc.createRange();\n\t\trange.setStart(node, 0);\n\t\trange.setEnd(node, pos);\n\t\tranges.push(range);\n\t\trange = false;\n\n\t\twhile ( pos != -1 ) {\n\n\t\t\tpos = text.indexOf(splitter, pos + 1);\n\t\t\tif(pos > 0) {\n\n\t\t\t\tif(range) {\n\t\t\t\t\trange.setEnd(node, pos);\n\t\t\t\t\tranges.push(range);\n\t\t\t\t}\n\n\t\t\t\trange = doc.createRange();\n\t\t\t\trange.setStart(node, pos+1);\n\t\t\t}\n\t\t}\n\n\t\tif(range) {\n\t\t\trange.setEnd(node, text.length);\n\t\t\tranges.push(range);\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\n\t/**\n\t * Turn a pair of ranges into a pair of CFIs\n\t * @private\n\t * @param {string} cfiBase base string for an EpubCFI\n\t * @param {object} rangePair { start: Range, end: Range }\n\t * @return {object} { start: \"epubcfi(...)\", end: \"epubcfi(...)\" }\n\t */\n\trangePairToCfiPair(cfiBase, rangePair){\n\n\t\tvar startRange = rangePair.start;\n\t\tvar endRange = rangePair.end;\n\n\t\tstartRange.collapse(true);\n\t\tendRange.collapse(false);\n\n\t\tlet startCfi = new EpubCFI(startRange, cfiBase).toString();\n\t\tlet endCfi = new EpubCFI(endRange, cfiBase).toString();\n\n\t\treturn {\n\t\t\tstart: startCfi,\n\t\t\tend: endCfi\n\t\t};\n\n\t}\n\n\trangeListToCfiList(cfiBase, columns){\n\t\tvar map = [];\n\t\tvar cifPair;\n\n\t\tfor (var i = 0; i < columns.length; i++) {\n\t\t\tcifPair = this.rangePairToCfiPair(cfiBase, columns[i]);\n\n\t\t\tmap.push(cifPair);\n\n\t\t}\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Set the axis for mapping\n\t * @param {string} axis horizontal | vertical\n\t * @return {boolean} is it horizontal?\n\t */\n\taxis(axis) {\n\t\tif (axis) {\n\t\t\tthis.horizontal = (axis === \"horizontal\") ? true : false;\n\t\t}\n\t\treturn this.horizontal;\n\t}\n}\n\nexport default Mapping;\n"],"names":["Mapping","layout","direction","axis","dev","view","ranges","map","contents","cfiBase","start","end","root","result","doc","startRange","EpubCFI","endRange","selection","r","func","filter","node","safeFilter","treeWalker","columns","scrollWidth","spreads","count","columnWidth","gap","i","stack","$el","found","$prev","left","right","top","bottom","elPos","nodeBounds","range","pos","prev","_splitter","textContent","text","splitter","rangePair","startCfi","endCfi","cifPair"],"mappings":"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","x_google_ignoreList":[0]}