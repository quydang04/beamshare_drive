{"version":3,"file":"index.js","sources":["../../../../../../../node_modules/.pnpm/markdown-it-container@4.0.0/node_modules/markdown-it-container/index.mjs"],"sourcesContent":["// Process block-level custom containers\n//\nexport default function container_plugin (md, name, options) {\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault (params/*, markup */) {\n    return params.trim().split(' ', 2)[0] === name\n  }\n\n  function renderDefault (tokens, idx, _options, env, slf) {\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name)\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf)\n  }\n\n  options = options || {}\n\n  const min_markers = 3\n  const marker_str  = options.marker || ':'\n  const marker_char = marker_str.charCodeAt(0)\n  const marker_len  = marker_str.length\n  const validate    = options.validate || validateDefault\n  const render      = options.render || renderDefault\n\n  function container (state, startLine, endLine, silent) {\n    let pos\n    let auto_closed = false\n    let start = state.bMarks[startLine] + state.tShift[startLine]\n    let max = state.eMarks[startLine]\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) { return false }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break\n      }\n    }\n\n    const marker_count = Math.floor((pos - start) / marker_len)\n    if (marker_count < min_markers) { return false }\n    pos -= (pos - start) % marker_len\n\n    const markup = state.src.slice(start, pos)\n    const params = state.src.slice(pos, max)\n    if (!validate(params, markup)) { return false }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true }\n\n    // Search for the end of the block\n    //\n    let nextLine = startLine\n\n    for (;;) {\n      nextLine++\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine]\n      max = state.eMarks[nextLine]\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) { continue }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) { continue }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len\n      pos = state.skipSpaces(pos)\n\n      if (pos < max) { continue }\n\n      // found!\n      auto_closed = true\n      break\n    }\n\n    const old_parent = state.parentType\n    const old_line_max = state.lineMax\n    state.parentType = 'container'\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine\n\n    const token_o  = state.push('container_' + name + '_open', 'div', 1)\n    token_o.markup = markup\n    token_o.block  = true\n    token_o.info   = params\n    token_o.map    = [startLine, nextLine]\n\n    state.md.block.tokenize(state, startLine + 1, nextLine)\n\n    const token_c  = state.push('container_' + name + '_close', 'div', -1)\n    token_c.markup = state.src.slice(start, pos)\n    token_c.block  = true\n\n    state.parentType = old_parent\n    state.lineMax = old_line_max\n    state.line = nextLine + (auto_closed ? 1 : 0)\n\n    return true\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  })\n  md.renderer.rules['container_' + name + '_open'] = render\n  md.renderer.rules['container_' + name + '_close'] = render\n};\n"],"names":["container_plugin","md","name","options","validateDefault","params","renderDefault","tokens","idx","_options","env","slf","min_markers","marker_str","marker_char","marker_len","validate","render","container","state","startLine","endLine","silent","pos","auto_closed","start","max","marker_count","markup","nextLine","old_parent","old_line_max","token_o","token_c"],"mappings":"aAEe,SAASA,EAAkBC,EAAIC,EAAMC,EAAS,CAG3D,SAASC,EAAiBC,EAAqB,CAC7C,OAAOA,EAAO,KAAI,EAAG,MAAM,IAAK,CAAC,EAAE,CAAC,IAAMH,CAC3C,CAED,SAASI,EAAeC,EAAQC,EAAKC,EAAUC,EAAKC,EAAK,CAEvD,OAAIJ,EAAOC,CAAG,EAAE,UAAY,GAC1BD,EAAOC,CAAG,EAAE,SAAS,QAASN,CAAI,EAG7BS,EAAI,YAAYJ,EAAQC,EAAKC,EAAUC,EAAKC,CAAG,CACvD,CAEDR,EAAUA,GAAW,CAAE,EAEvB,MAAMS,EAAc,EACdC,EAAcV,EAAQ,QAAU,IAChCW,EAAcD,EAAW,WAAW,CAAC,EACrCE,EAAcF,EAAW,OACzBG,EAAcb,EAAQ,UAAYC,EAClCa,EAAcd,EAAQ,QAAUG,EAEtC,SAASY,EAAWC,EAAOC,EAAWC,EAASC,EAAQ,CACrD,IAAIC,EACAC,EAAc,GACdC,EAAQN,EAAM,OAAOC,CAAS,EAAID,EAAM,OAAOC,CAAS,EACxDM,EAAMP,EAAM,OAAOC,CAAS,EAKhC,GAAIN,IAAgBK,EAAM,IAAI,WAAWM,CAAK,EAAK,MAAO,GAI1D,IAAKF,EAAME,EAAQ,EAAGF,GAAOG,GACvBb,GAAYU,EAAME,GAASV,CAAU,IAAMI,EAAM,IAAII,CAAG,EAD5BA,IAChC,CAKF,MAAMI,EAAe,KAAK,OAAOJ,EAAME,GAASV,CAAU,EAC1D,GAAIY,EAAef,EAAe,MAAO,GACzCW,IAAQA,EAAME,GAASV,EAEvB,MAAMa,EAAST,EAAM,IAAI,MAAMM,EAAOF,CAAG,EACnClB,EAASc,EAAM,IAAI,MAAMI,EAAKG,CAAG,EACvC,GAAI,CAACV,EAASX,EAAQuB,CAAM,EAAK,MAAO,GAIxC,GAAIN,EAAU,MAAO,GAIrB,IAAIO,EAAWT,EAEf,KACES,IACI,EAAAA,GAAYR,IAMhBI,EAAQN,EAAM,OAAOU,CAAQ,EAAIV,EAAM,OAAOU,CAAQ,EACtDH,EAAMP,EAAM,OAAOU,CAAQ,EAEvBJ,EAAQC,GAAOP,EAAM,OAAOU,CAAQ,EAAIV,EAAM,aAOlD,GAAIL,IAAgBK,EAAM,IAAI,WAAWM,CAAK,GAE1C,EAAAN,EAAM,OAAOU,CAAQ,EAAIV,EAAM,WAAa,GAKhD,KAAKI,EAAME,EAAQ,EAAGF,GAAOG,GACvBb,GAAYU,EAAME,GAASV,CAAU,IAAMI,EAAM,IAAII,CAAG,EAD5BA,IAChC,CAMF,GAAI,OAAK,OAAOA,EAAME,GAASV,CAAU,EAAIY,KAG7CJ,IAAQA,EAAME,GAASV,EACvBQ,EAAMJ,EAAM,WAAWI,CAAG,EAEtB,EAAAA,EAAMG,IAGV,CAAAF,EAAc,GACd,OAGF,MAAMM,EAAaX,EAAM,WACnBY,EAAeZ,EAAM,QAC3BA,EAAM,WAAa,YAGnBA,EAAM,QAAUU,EAEhB,MAAMG,EAAWb,EAAM,KAAK,aAAejB,EAAO,QAAS,MAAO,CAAC,EACnE8B,EAAQ,OAASJ,EACjBI,EAAQ,MAAS,GACjBA,EAAQ,KAAS3B,EACjB2B,EAAQ,IAAS,CAACZ,EAAWS,CAAQ,EAErCV,EAAM,GAAG,MAAM,SAASA,EAAOC,EAAY,EAAGS,CAAQ,EAEtD,MAAMI,EAAWd,EAAM,KAAK,aAAejB,EAAO,SAAU,MAAO,EAAE,EACrE,OAAA+B,EAAQ,OAASd,EAAM,IAAI,MAAMM,EAAOF,CAAG,EAC3CU,EAAQ,MAAS,GAEjBd,EAAM,WAAaW,EACnBX,EAAM,QAAUY,EAChBZ,EAAM,KAAOU,GAAYL,EAAc,EAAI,GAEpC,EACR,CAEDvB,EAAG,MAAM,MAAM,OAAO,QAAS,aAAeC,EAAMgB,EAAW,CAC7D,IAAK,CAAC,YAAa,YAAa,aAAc,MAAM,CACxD,CAAG,EACDjB,EAAG,SAAS,MAAM,aAAeC,EAAO,OAAO,EAAIe,EACnDhB,EAAG,SAAS,MAAM,aAAeC,EAAO,QAAQ,EAAIe,CACtD","x_google_ignoreList":[0]}