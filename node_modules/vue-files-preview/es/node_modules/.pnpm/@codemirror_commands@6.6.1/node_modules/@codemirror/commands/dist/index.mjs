import { EditorSelection as h, countColumn as $, Facet as re, combineConfig as ze, StateField as He, Transaction as V, ChangeSet as qe, ChangeDesc as Ke, StateEffect as oe, Text as le, Annotation as ce, findClusterBreak as E } from "../../../../../@codemirror_state@6.4.1/node_modules/@codemirror/state/dist/index.mjs";
import { EditorView as D, Direction as $e } from "../../../../../@codemirror_view@6.33.0/node_modules/@codemirror/view/dist/index.mjs";
import { indentUnit as We, indentString as R, getIndentUnit as G, IndentContext as se, getIndentation as ie, matchBrackets as x, syntaxTree as W } from "../../../../../@codemirror_language@6.10.2/node_modules/@codemirror/language/dist/index.mjs";
import { NodeProp as F } from "../../../../../@lezer_common@1.2.1/node_modules/@lezer/common/dist/index.mjs";
const Qe = (e) => {
  let { state: t } = e, r = t.doc.lineAt(t.selection.main.from), n = X(e.state, r.from);
  return n.line ? Xe(e) : n.block ? Ze(e) : !1;
};
function Q(e, t) {
  return ({ state: r, dispatch: n }) => {
    if (r.readOnly)
      return !1;
    let l = e(t, r);
    return l ? (n(r.update(l)), !0) : !1;
  };
}
const Xe = /* @__PURE__ */ Q(
  we,
  0
  /* CommentOption.Toggle */
), Ye = /* @__PURE__ */ Q(
  ue,
  0
  /* CommentOption.Toggle */
), Ze = /* @__PURE__ */ Q(
  (e, t) => ue(e, t, je(t)),
  0
  /* CommentOption.Toggle */
);
function X(e, t) {
  let r = e.languageDataAt("commentTokens", t);
  return r.length ? r[0] : {};
}
const M = 50;
function _e(e, { open: t, close: r }, n, l) {
  let o = e.sliceDoc(n - M, n), c = e.sliceDoc(l, l + M), s = /\s*$/.exec(o)[0].length, i = /^\s*/.exec(c)[0].length, f = o.length - s;
  if (o.slice(f - t.length, f) == t && c.slice(i, i + r.length) == r)
    return {
      open: { pos: n - s, margin: s && 1 },
      close: { pos: l + i, margin: i && 1 }
    };
  let u, a;
  l - n <= 2 * M ? u = a = e.sliceDoc(n, l) : (u = e.sliceDoc(n, n + M), a = e.sliceDoc(l - M, l));
  let p = /^\s*/.exec(u)[0].length, T = /\s*$/.exec(a)[0].length, C = a.length - T - r.length;
  return u.slice(p, p + t.length) == t && a.slice(C, C + r.length) == r ? {
    open: {
      pos: n + p + t.length,
      margin: /\s/.test(u.charAt(p + t.length)) ? 1 : 0
    },
    close: {
      pos: l - T - r.length,
      margin: /\s/.test(a.charAt(C - 1)) ? 1 : 0
    }
  } : null;
}
function je(e) {
  let t = [];
  for (let r of e.selection.ranges) {
    let n = e.doc.lineAt(r.from), l = r.to <= n.to ? n : e.doc.lineAt(r.to), o = t.length - 1;
    o >= 0 && t[o].to > n.from ? t[o].to = l.to : t.push({ from: n.from + /^\s*/.exec(n.text)[0].length, to: l.to });
  }
  return t;
}
function ue(e, t, r = t.selection.ranges) {
  let n = r.map((o) => X(t, o.from).block);
  if (!n.every((o) => o))
    return null;
  let l = r.map((o, c) => _e(t, n[c], o.from, o.to));
  if (e != 2 && !l.every((o) => o))
    return { changes: t.changes(r.map((o, c) => l[c] ? [] : [{ from: o.from, insert: n[c].open + " " }, { from: o.to, insert: " " + n[c].close }])) };
  if (e != 1 && l.some((o) => o)) {
    let o = [];
    for (let c = 0, s; c < l.length; c++)
      if (s = l[c]) {
        let i = n[c], { open: f, close: u } = s;
        o.push({ from: f.pos - i.open.length, to: f.pos + f.margin }, { from: u.pos - u.margin, to: u.pos + i.close.length });
      }
    return { changes: o };
  }
  return null;
}
function we(e, t, r = t.selection.ranges) {
  let n = [], l = -1;
  for (let { from: o, to: c } of r) {
    let s = n.length, i = 1e9, f = X(t, o).line;
    if (f) {
      for (let u = o; u <= c; ) {
        let a = t.doc.lineAt(u);
        if (a.from > l && (o == c || c > a.from)) {
          l = a.from;
          let p = /^\s*/.exec(a.text)[0].length, T = p == a.length, C = a.text.slice(p, p + f.length) == f ? p : -1;
          p < a.text.length && p < i && (i = p), n.push({ line: a, comment: C, token: f, indent: p, empty: T, single: !1 });
        }
        u = a.to + 1;
      }
      if (i < 1e9)
        for (let u = s; u < n.length; u++)
          n[u].indent < n[u].line.text.length && (n[u].indent = i);
      n.length == s + 1 && (n[s].single = !0);
    }
  }
  if (e != 2 && n.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: s, token: i, indent: f, empty: u, single: a } of n)
      (a || !u) && o.push({ from: s.from + f, insert: i + " " });
    let c = t.changes(o);
    return { changes: c, selection: t.selection.map(c, 1) };
  } else if (e != 1 && n.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: c, comment: s, token: i } of n)
      if (s >= 0) {
        let f = c.from + s, u = f + i.length;
        c.text[u - c.from] == " " && u++, o.push({ from: f, to: u });
      }
    return { changes: o };
  }
  return null;
}
const z = /* @__PURE__ */ ce.define(), et = /* @__PURE__ */ ce.define(), tt = /* @__PURE__ */ re.define(), fe = /* @__PURE__ */ re.define({
  combine(e) {
    return ze(e, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (t, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (t, r) => (n, l) => t(n, l) || r(n, l)
    });
  }
}), ae = /* @__PURE__ */ He.define({
  create() {
    return A.empty;
  },
  update(e, t) {
    let r = t.state.facet(fe), n = t.annotation(z);
    if (n) {
      let i = m.fromTransaction(t, n.selection), f = n.side, u = f == 0 ? e.undone : e.done;
      return i ? u = I(u, u.length, r.minDepth, i) : u = me(u, t.startState.selection), new A(f == 0 ? n.rest : u, f == 0 ? u : n.rest);
    }
    let l = t.annotation(et);
    if ((l == "full" || l == "before") && (e = e.isolate()), t.annotation(V.addToHistory) === !1)
      return t.changes.empty ? e : e.addMapping(t.changes.desc);
    let o = m.fromTransaction(t), c = t.annotation(V.time), s = t.annotation(V.userEvent);
    return o ? e = e.addChanges(o, c, s, r, t) : t.selection && (e = e.addSelection(t.startState.selection, c, s, r.newGroupDelay)), (l == "full" || l == "after") && (e = e.isolate()), e;
  },
  toJSON(e) {
    return { done: e.done.map((t) => t.toJSON()), undone: e.undone.map((t) => t.toJSON()) };
  },
  fromJSON(e) {
    return new A(e.done.map(m.fromJSON), e.undone.map(m.fromJSON));
  }
});
function ln(e = {}) {
  return [
    ae,
    fe.of(e),
    D.domEventHandlers({
      beforeinput(t, r) {
        let n = t.inputType == "historyUndo" ? he : t.inputType == "historyRedo" ? H : null;
        return n ? (t.preventDefault(), n(r)) : !1;
      }
    })
  ];
}
function v(e, t) {
  return function({ state: r, dispatch: n }) {
    if (!t && r.readOnly)
      return !1;
    let l = r.field(ae, !1);
    if (!l)
      return !1;
    let o = l.pop(e, r, t);
    return o ? (n(o), !0) : !1;
  };
}
const he = /* @__PURE__ */ v(0, !1), H = /* @__PURE__ */ v(1, !1), nt = /* @__PURE__ */ v(0, !0), rt = /* @__PURE__ */ v(1, !0);
class m {
  constructor(t, r, n, l, o) {
    this.changes = t, this.effects = r, this.mapped = n, this.startSelection = l, this.selectionsAfter = o;
  }
  setSelAfter(t) {
    return new m(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, r, n;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((l) => l.toJSON())
    };
  }
  static fromJSON(t) {
    return new m(t.changes && qe.fromJSON(t.changes), [], t.mapped && Ke.fromJSON(t.mapped), t.startSelection && h.fromJSON(t.startSelection), t.selectionsAfter.map(h.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, r) {
    let n = g;
    for (let l of t.startState.facet(tt)) {
      let o = l(t);
      o.length && (n = n.concat(o));
    }
    return !n.length && t.changes.empty ? null : new m(t.changes.invert(t.startState.doc), n, void 0, r || t.startState.selection, g);
  }
  static selection(t) {
    return new m(void 0, g, void 0, void 0, t);
  }
}
function I(e, t, r, n) {
  let l = t + 1 > r + 20 ? t - r - 1 : 0, o = e.slice(l, t);
  return o.push(n), o;
}
function ot(e, t) {
  let r = [], n = !1;
  return e.iterChangedRanges((l, o) => r.push(l, o)), t.iterChangedRanges((l, o, c, s) => {
    for (let i = 0; i < r.length; ) {
      let f = r[i++], u = r[i++];
      s >= f && c <= u && (n = !0);
    }
  }), n;
}
function lt(e, t) {
  return e.ranges.length == t.ranges.length && e.ranges.filter((r, n) => r.empty != t.ranges[n].empty).length === 0;
}
function de(e, t) {
  return e.length ? t.length ? e.concat(t) : e : t;
}
const g = [], ct = 200;
function me(e, t) {
  if (e.length) {
    let r = e[e.length - 1], n = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - ct));
    return n.length && n[n.length - 1].eq(t) ? e : (n.push(t), I(e, e.length - 1, 1e9, r.setSelAfter(n)));
  } else
    return [m.selection([t])];
}
function st(e) {
  let t = e[e.length - 1], r = e.slice();
  return r[e.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), r;
}
function J(e, t) {
  if (!e.length)
    return e;
  let r = e.length, n = g;
  for (; r; ) {
    let l = it(e[r - 1], t, n);
    if (l.changes && !l.changes.empty || l.effects.length) {
      let o = e.slice(0, r);
      return o[r - 1] = l, o;
    } else
      t = l.mapped, r--, n = l.selectionsAfter;
  }
  return n.length ? [m.selection(n)] : g;
}
function it(e, t, r) {
  let n = de(e.selectionsAfter.length ? e.selectionsAfter.map((s) => s.map(t)) : g, r);
  if (!e.changes)
    return m.selection(n);
  let l = e.changes.map(t), o = t.mapDesc(e.changes, !0), c = e.mapped ? e.mapped.composeDesc(o) : o;
  return new m(l, oe.mapEffects(e.effects, t), c, e.startSelection.map(o), n);
}
const ut = /^(input\.type|delete)($|\.)/;
class A {
  constructor(t, r, n = 0, l = void 0) {
    this.done = t, this.undone = r, this.prevTime = n, this.prevUserEvent = l;
  }
  isolate() {
    return this.prevTime ? new A(this.done, this.undone) : this;
  }
  addChanges(t, r, n, l, o) {
    let c = this.done, s = c[c.length - 1];
    return s && s.changes && !s.changes.empty && t.changes && (!n || ut.test(n)) && (!s.selectionsAfter.length && r - this.prevTime < l.newGroupDelay && l.joinToEvent(o, ot(s.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    n == "input.type.compose") ? c = I(c, c.length - 1, l.minDepth, new m(t.changes.compose(s.changes), de(oe.mapEffects(t.effects, s.changes), s.effects), s.mapped, s.startSelection, g)) : c = I(c, c.length, l.minDepth, t), new A(c, g, r, n);
  }
  addSelection(t, r, n, l) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : g;
    return o.length > 0 && r - this.prevTime < l && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && lt(o[o.length - 1], t) ? this : new A(me(this.done, t), this.undone, r, n);
  }
  addMapping(t) {
    return new A(J(this.done, t), J(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, r, n) {
    let l = t == 0 ? this.done : this.undone;
    if (l.length == 0)
      return null;
    let o = l[l.length - 1], c = o.selectionsAfter[0] || r.selection;
    if (n && o.selectionsAfter.length)
      return r.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: z.of({ side: t, rest: st(l), selection: c }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (o.changes) {
      let s = l.length == 1 ? g : l.slice(0, l.length - 1);
      return o.mapped && (s = J(s, o.mapped)), r.update({
        changes: o.changes,
        selection: o.startSelection,
        effects: o.effects,
        annotations: z.of({ side: t, rest: s, selection: c }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
A.empty = /* @__PURE__ */ new A(g, g);
const cn = [
  { key: "Mod-z", run: he, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: H, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: H, preventDefault: !0 },
  { key: "Mod-u", run: nt, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: rt, preventDefault: !0 }
];
function L(e, t) {
  return h.create(e.ranges.map(t), e.mainIndex);
}
function B(e, t) {
  return e.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
function k({ state: e, dispatch: t }, r) {
  let n = L(e.selection, r);
  return n.eq(e.selection, !0) ? !1 : (t(B(e, n)), !0);
}
function N(e, t) {
  return h.cursor(t ? e.to : e.from);
}
function pe(e, t) {
  return k(e, (r) => r.empty ? e.moveByChar(r, t) : N(r, t));
}
function d(e) {
  return e.textDirectionAt(e.state.selection.main.head) == $e.LTR;
}
const ge = (e) => pe(e, !d(e)), ye = (e) => pe(e, d(e));
function ke(e, t) {
  return k(e, (r) => r.empty ? e.moveByGroup(r, t) : N(r, t));
}
const ft = (e) => ke(e, !d(e)), at = (e) => ke(e, d(e));
function ht(e, t, r) {
  if (t.type.prop(r))
    return !0;
  let n = t.to - t.from;
  return n && (n > 2 || /[^\s,.;:]/.test(e.sliceDoc(t.from, t.to))) || t.firstChild;
}
function P(e, t, r) {
  let n = W(e).resolveInner(t.head), l = r ? F.closedBy : F.openedBy;
  for (let i = t.head; ; ) {
    let f = r ? n.childAfter(i) : n.childBefore(i);
    if (!f)
      break;
    ht(e, f, l) ? n = f : i = r ? f.to : f.from;
  }
  let o = n.type.prop(l), c, s;
  return o && (c = r ? x(e, n.from, 1) : x(e, n.to, -1)) && c.matched ? s = r ? c.end.to : c.end.from : s = r ? n.to : n.from, h.cursor(s, r ? -1 : 1);
}
const dt = (e) => k(e, (t) => P(e.state, t, !d(e))), mt = (e) => k(e, (t) => P(e.state, t, d(e)));
function Ae(e, t) {
  return k(e, (r) => {
    if (!r.empty)
      return N(r, t);
    let n = e.moveVertically(r, t);
    return n.head != r.head ? n : e.moveToLineBoundary(r, t);
  });
}
const Be = (e) => Ae(e, !1), Se = (e) => Ae(e, !0);
function xe(e) {
  let t = e.scrollDOM.clientHeight < e.scrollDOM.scrollHeight - 2, r = 0, n = 0, l;
  if (t) {
    for (let o of e.state.facet(D.scrollMargins)) {
      let c = o(e);
      c != null && c.top && (r = Math.max(c == null ? void 0 : c.top, r)), c != null && c.bottom && (n = Math.max(c == null ? void 0 : c.bottom, n));
    }
    l = e.scrollDOM.clientHeight - r - n;
  } else
    l = (e.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: n,
    selfScroll: t,
    height: Math.max(e.defaultLineHeight, l - 5)
  };
}
function De(e, t) {
  let r = xe(e), { state: n } = e, l = L(n.selection, (c) => c.empty ? e.moveVertically(c, t, r.height) : N(c, t));
  if (l.eq(n.selection))
    return !1;
  let o;
  if (r.selfScroll) {
    let c = e.coordsAtPos(n.selection.main.head), s = e.scrollDOM.getBoundingClientRect(), i = s.top + r.marginTop, f = s.bottom - r.marginBottom;
    c && c.top > i && c.bottom < f && (o = D.scrollIntoView(l.main.head, { y: "start", yMargin: c.top - i }));
  }
  return e.dispatch(B(n, l), { effects: o }), !0;
}
const Z = (e) => De(e, !1), q = (e) => De(e, !0);
function S(e, t, r) {
  let n = e.lineBlockAt(t.head), l = e.moveToLineBoundary(t, r);
  if (l.head == t.head && l.head != (r ? n.to : n.from) && (l = e.moveToLineBoundary(t, r, !1)), !r && l.head == n.from && n.length) {
    let o = /^\s*/.exec(e.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    o && t.head != n.from + o && (l = h.cursor(n.from + o));
  }
  return l;
}
const pt = (e) => k(e, (t) => S(e, t, !0)), gt = (e) => k(e, (t) => S(e, t, !1)), yt = (e) => k(e, (t) => S(e, t, !d(e))), kt = (e) => k(e, (t) => S(e, t, d(e))), At = (e) => k(e, (t) => h.cursor(e.lineBlockAt(t.head).from, 1)), Bt = (e) => k(e, (t) => h.cursor(e.lineBlockAt(t.head).to, -1));
function St(e, t, r) {
  let n = !1, l = L(e.selection, (o) => {
    let c = x(e, o.head, -1) || x(e, o.head, 1) || o.head > 0 && x(e, o.head - 1, 1) || o.head < e.doc.length && x(e, o.head + 1, -1);
    if (!c || !c.end)
      return o;
    n = !0;
    let s = c.start.from == o.head ? c.end.to : c.end.from;
    return h.cursor(s);
  });
  return n ? (t(B(e, l)), !0) : !1;
}
const xt = ({ state: e, dispatch: t }) => St(e, t);
function y(e, t) {
  let r = L(e.state.selection, (n) => {
    let l = t(n);
    return h.range(n.anchor, l.head, l.goalColumn, l.bidiLevel || void 0);
  });
  return r.eq(e.state.selection) ? !1 : (e.dispatch(B(e.state, r)), !0);
}
function Le(e, t) {
  return y(e, (r) => e.moveByChar(r, t));
}
const Ce = (e) => Le(e, !d(e)), Me = (e) => Le(e, d(e));
function Ee(e, t) {
  return y(e, (r) => e.moveByGroup(r, t));
}
const Dt = (e) => Ee(e, !d(e)), Lt = (e) => Ee(e, d(e)), Ct = (e) => y(e, (t) => P(e.state, t, !d(e))), Mt = (e) => y(e, (t) => P(e.state, t, d(e)));
function Oe(e, t) {
  return y(e, (r) => e.moveVertically(r, t));
}
const Te = (e) => Oe(e, !1), be = (e) => Oe(e, !0);
function Re(e, t) {
  return y(e, (r) => e.moveVertically(r, t, xe(e).height));
}
const _ = (e) => Re(e, !1), j = (e) => Re(e, !0), Et = (e) => y(e, (t) => S(e, t, !0)), Ot = (e) => y(e, (t) => S(e, t, !1)), Tt = (e) => y(e, (t) => S(e, t, !d(e))), bt = (e) => y(e, (t) => S(e, t, d(e))), Rt = (e) => y(e, (t) => h.cursor(e.lineBlockAt(t.head).from)), It = (e) => y(e, (t) => h.cursor(e.lineBlockAt(t.head).to)), w = ({ state: e, dispatch: t }) => (t(B(e, { anchor: 0 })), !0), ee = ({ state: e, dispatch: t }) => (t(B(e, { anchor: e.doc.length })), !0), te = ({ state: e, dispatch: t }) => (t(B(e, { anchor: e.selection.main.anchor, head: 0 })), !0), ne = ({ state: e, dispatch: t }) => (t(B(e, { anchor: e.selection.main.anchor, head: e.doc.length })), !0), vt = ({ state: e, dispatch: t }) => (t(e.update({ selection: { anchor: 0, head: e.doc.length }, userEvent: "select" })), !0), Nt = ({ state: e, dispatch: t }) => {
  let r = U(e).map(({ from: n, to: l }) => h.range(n, Math.min(l + 1, e.doc.length)));
  return t(e.update({ selection: h.create(r), userEvent: "select" })), !0;
}, Pt = ({ state: e, dispatch: t }) => {
  let r = L(e.selection, (n) => {
    var l;
    let o = W(e).resolveStack(n.from, 1);
    for (let c = o; c; c = c.next) {
      let { node: s } = c;
      if ((s.from < n.from && s.to >= n.to || s.to > n.to && s.from <= n.from) && (!((l = s.parent) === null || l === void 0) && l.parent))
        return h.range(s.to, s.from);
    }
    return n;
  });
  return t(B(e, r)), !0;
}, Ut = ({ state: e, dispatch: t }) => {
  let r = e.selection, n = null;
  return r.ranges.length > 1 ? n = h.create([r.main]) : r.main.empty || (n = h.create([h.cursor(r.main.head)])), n ? (t(B(e, n)), !0) : !1;
};
function O(e, t) {
  if (e.state.readOnly)
    return !1;
  let r = "delete.selection", { state: n } = e, l = n.changeByRange((o) => {
    let { from: c, to: s } = o;
    if (c == s) {
      let i = t(o);
      i < c ? (r = "delete.backward", i = b(e, i, !1)) : i > c && (r = "delete.forward", i = b(e, i, !0)), c = Math.min(c, i), s = Math.max(s, i);
    } else
      c = b(e, c, !1), s = b(e, s, !0);
    return c == s ? { range: o } : { changes: { from: c, to: s }, range: h.cursor(c, c < o.head ? -1 : 1) };
  });
  return l.changes.empty ? !1 : (e.dispatch(n.update(l, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? D.announce.of(n.phrase("Selection deleted")) : void 0
  })), !0);
}
function b(e, t, r) {
  if (e instanceof D)
    for (let n of e.state.facet(D.atomicRanges).map((l) => l(e)))
      n.between(t, t, (l, o) => {
        l < t && o > t && (t = r ? o : l);
      });
  return t;
}
const Ie = (e, t, r) => O(e, (n) => {
  let l = n.from, { state: o } = e, c = o.doc.lineAt(l), s, i;
  if (r && !t && l > c.from && l < c.from + 200 && !/[^ \t]/.test(s = c.text.slice(0, l - c.from))) {
    if (s[s.length - 1] == "	")
      return l - 1;
    let f = $(s, o.tabSize), u = f % G(o) || G(o);
    for (let a = 0; a < u && s[s.length - 1 - a] == " "; a++)
      l--;
    i = l;
  } else
    i = E(c.text, l - c.from, t, t) + c.from, i == l && c.number != (t ? o.doc.lines : 1) ? i += t ? 1 : -1 : !t && /[\ufe00-\ufe0f]/.test(c.text.slice(i - c.from, l - c.from)) && (i = E(c.text, i - c.from, !1, !1) + c.from);
  return i;
}), K = (e) => Ie(e, !1, !0), ve = (e) => Ie(e, !0, !1), Ne = (e, t) => O(e, (r) => {
  let n = r.head, { state: l } = e, o = l.doc.lineAt(n), c = l.charCategorizer(n);
  for (let s = null; ; ) {
    if (n == (t ? o.to : o.from)) {
      n == r.head && o.number != (t ? l.doc.lines : 1) && (n += t ? 1 : -1);
      break;
    }
    let i = E(o.text, n - o.from, t) + o.from, f = o.text.slice(Math.min(n, i) - o.from, Math.max(n, i) - o.from), u = c(f);
    if (s != null && u != s)
      break;
    (f != " " || n != r.head) && (s = u), n = i;
  }
  return n;
}), Pe = (e) => Ne(e, !1), Vt = (e) => Ne(e, !0), Jt = (e) => O(e, (t) => {
  let r = e.lineBlockAt(t.head).to;
  return t.head < r ? r : Math.min(e.state.doc.length, t.head + 1);
}), Gt = (e) => O(e, (t) => {
  let r = e.moveToLineBoundary(t, !1).head;
  return t.head > r ? r : Math.max(0, t.head - 1);
}), Ft = (e) => O(e, (t) => {
  let r = e.moveToLineBoundary(t, !0).head;
  return t.head < r ? r : Math.min(e.state.doc.length, t.head + 1);
}), zt = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let r = e.changeByRange((n) => ({
    changes: { from: n.from, to: n.to, insert: le.of(["", ""]) },
    range: h.cursor(n.from)
  }));
  return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Ht = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let r = e.changeByRange((n) => {
    if (!n.empty || n.from == 0 || n.from == e.doc.length)
      return { range: n };
    let l = n.from, o = e.doc.lineAt(l), c = l == o.from ? l - 1 : E(o.text, l - o.from, !1) + o.from, s = l == o.to ? l + 1 : E(o.text, l - o.from, !0) + o.from;
    return {
      changes: { from: c, to: s, insert: e.doc.slice(l, s).append(e.doc.slice(c, l)) },
      range: h.cursor(s)
    };
  });
  return r.changes.empty ? !1 : (t(e.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function U(e) {
  let t = [], r = -1;
  for (let n of e.selection.ranges) {
    let l = e.doc.lineAt(n.from), o = e.doc.lineAt(n.to);
    if (!n.empty && n.to == o.from && (o = e.doc.lineAt(n.to - 1)), r >= l.number) {
      let c = t[t.length - 1];
      c.to = o.to, c.ranges.push(n);
    } else
      t.push({ from: l.from, to: o.to, ranges: [n] });
    r = o.number + 1;
  }
  return t;
}
function Ue(e, t, r) {
  if (e.readOnly)
    return !1;
  let n = [], l = [];
  for (let o of U(e)) {
    if (r ? o.to == e.doc.length : o.from == 0)
      continue;
    let c = e.doc.lineAt(r ? o.to + 1 : o.from - 1), s = c.length + 1;
    if (r) {
      n.push({ from: o.to, to: c.to }, { from: o.from, insert: c.text + e.lineBreak });
      for (let i of o.ranges)
        l.push(h.range(Math.min(e.doc.length, i.anchor + s), Math.min(e.doc.length, i.head + s)));
    } else {
      n.push({ from: c.from, to: o.from }, { from: o.to, insert: e.lineBreak + c.text });
      for (let i of o.ranges)
        l.push(h.range(i.anchor - s, i.head - s));
    }
  }
  return n.length ? (t(e.update({
    changes: n,
    scrollIntoView: !0,
    selection: h.create(l, e.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const qt = ({ state: e, dispatch: t }) => Ue(e, t, !1), Kt = ({ state: e, dispatch: t }) => Ue(e, t, !0);
function Ve(e, t, r) {
  if (e.readOnly)
    return !1;
  let n = [];
  for (let l of U(e))
    r ? n.push({ from: l.from, insert: e.doc.slice(l.from, l.to) + e.lineBreak }) : n.push({ from: l.to, insert: e.lineBreak + e.doc.slice(l.from, l.to) });
  return t(e.update({ changes: n, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const $t = ({ state: e, dispatch: t }) => Ve(e, t, !1), Wt = ({ state: e, dispatch: t }) => Ve(e, t, !0), Qt = (e) => {
  if (e.state.readOnly)
    return !1;
  let { state: t } = e, r = t.changes(U(t).map(({ from: l, to: o }) => (l > 0 ? l-- : o < t.doc.length && o++, { from: l, to: o }))), n = L(t.selection, (l) => {
    let o;
    if (e.lineWrapping) {
      let c = e.lineBlockAt(l.head), s = e.coordsAtPos(l.head, l.assoc || 1);
      s && (o = c.bottom + e.documentTop - s.bottom + e.defaultLineHeight / 2);
    }
    return e.moveVertically(l, !0, o);
  }).map(r);
  return e.dispatch({ changes: r, selection: n, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Xt(e, t) {
  if (/\(\)|\[\]|\{\}/.test(e.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let r = W(e).resolveInner(t), n = r.childBefore(t), l = r.childAfter(t), o;
  return n && l && n.to <= t && l.from >= t && (o = n.type.prop(F.closedBy)) && o.indexOf(l.name) > -1 && e.doc.lineAt(n.to).from == e.doc.lineAt(l.from).from && !/\S/.test(e.sliceDoc(n.to, l.from)) ? { from: n.to, to: l.from } : null;
}
const Yt = /* @__PURE__ */ Je(!1), Zt = /* @__PURE__ */ Je(!0);
function Je(e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let n = t.changeByRange((l) => {
      let { from: o, to: c } = l, s = t.doc.lineAt(o), i = !e && o == c && Xt(t, o);
      e && (o = c = (c <= s.to ? s : t.doc.lineAt(c)).to);
      let f = new se(t, { simulateBreak: o, simulateDoubleBreak: !!i }), u = ie(f, o);
      for (u == null && (u = $(/^\s*/.exec(t.doc.lineAt(o).text)[0], t.tabSize)); c < s.to && /\s/.test(s.text[c - s.from]); )
        c++;
      i ? { from: o, to: c } = i : o > s.from && o < s.from + 100 && !/\S/.test(s.text.slice(0, o)) && (o = s.from);
      let a = ["", R(t, u)];
      return i && a.push(R(t, f.lineIndent(s.from, -1))), {
        changes: { from: o, to: c, insert: le.of(a) },
        range: h.cursor(o + 1 + a[1].length)
      };
    });
    return r(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Y(e, t) {
  let r = -1;
  return e.changeByRange((n) => {
    let l = [];
    for (let c = n.from; c <= n.to; ) {
      let s = e.doc.lineAt(c);
      s.number > r && (n.empty || n.to > s.from) && (t(s, l, n), r = s.number), c = s.to + 1;
    }
    let o = e.changes(l);
    return {
      changes: l,
      range: h.range(o.mapPos(n.anchor, 1), o.mapPos(n.head, 1))
    };
  });
}
const _t = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), n = new se(e, { overrideIndentation: (o) => {
    let c = r[o];
    return c ?? -1;
  } }), l = Y(e, (o, c, s) => {
    let i = ie(n, o.from);
    if (i == null)
      return;
    /\S/.test(o.text) || (i = 0);
    let f = /^\s*/.exec(o.text)[0], u = R(e, i);
    (f != u || s.from < o.from + f.length) && (r[o.from] = i, c.push({ from: o.from, to: o.from + f.length, insert: u }));
  });
  return l.changes.empty || t(e.update(l, { userEvent: "indent" })), !0;
}, Ge = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update(Y(e, (r, n) => {
  n.push({ from: r.from, insert: e.facet(We) });
}), { userEvent: "input.indent" })), !0), Fe = ({ state: e, dispatch: t }) => e.readOnly ? !1 : (t(e.update(Y(e, (r, n) => {
  let l = /^\s*/.exec(r.text)[0];
  if (!l)
    return;
  let o = $(l, e.tabSize), c = 0, s = R(e, Math.max(0, o - G(e)));
  for (; c < l.length && c < s.length && l.charCodeAt(c) == s.charCodeAt(c); )
    c++;
  n.push({ from: r.from + c, to: r.from + l.length, insert: s.slice(c) });
}), { userEvent: "delete.dedent" })), !0), jt = (e) => (e.setTabFocusMode(), !0), wt = [
  { key: "Ctrl-b", run: ge, shift: Ce, preventDefault: !0 },
  { key: "Ctrl-f", run: ye, shift: Me },
  { key: "Ctrl-p", run: Be, shift: Te },
  { key: "Ctrl-n", run: Se, shift: be },
  { key: "Ctrl-a", run: At, shift: Rt },
  { key: "Ctrl-e", run: Bt, shift: It },
  { key: "Ctrl-d", run: ve },
  { key: "Ctrl-h", run: K },
  { key: "Ctrl-k", run: Jt },
  { key: "Ctrl-Alt-h", run: Pe },
  { key: "Ctrl-o", run: zt },
  { key: "Ctrl-t", run: Ht },
  { key: "Ctrl-v", run: q }
], en = /* @__PURE__ */ [
  { key: "ArrowLeft", run: ge, shift: Ce, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: ft, shift: Dt, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: yt, shift: Tt, preventDefault: !0 },
  { key: "ArrowRight", run: ye, shift: Me, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: at, shift: Lt, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: kt, shift: bt, preventDefault: !0 },
  { key: "ArrowUp", run: Be, shift: Te, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: w, shift: te },
  { mac: "Ctrl-ArrowUp", run: Z, shift: _ },
  { key: "ArrowDown", run: Se, shift: be, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: ee, shift: ne },
  { mac: "Ctrl-ArrowDown", run: q, shift: j },
  { key: "PageUp", run: Z, shift: _ },
  { key: "PageDown", run: q, shift: j },
  { key: "Home", run: gt, shift: Ot, preventDefault: !0 },
  { key: "Mod-Home", run: w, shift: te },
  { key: "End", run: pt, shift: Et, preventDefault: !0 },
  { key: "Mod-End", run: ee, shift: ne },
  { key: "Enter", run: Yt },
  { key: "Mod-a", run: vt },
  { key: "Backspace", run: K, shift: K },
  { key: "Delete", run: ve },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Pe },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Vt },
  { mac: "Mod-Backspace", run: Gt },
  { mac: "Mod-Delete", run: Ft }
].concat(/* @__PURE__ */ wt.map((e) => ({ mac: e.key, run: e.run, shift: e.shift }))), sn = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: dt, shift: Ct },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: mt, shift: Mt },
  { key: "Alt-ArrowUp", run: qt },
  { key: "Shift-Alt-ArrowUp", run: $t },
  { key: "Alt-ArrowDown", run: Kt },
  { key: "Shift-Alt-ArrowDown", run: Wt },
  { key: "Escape", run: Ut },
  { key: "Mod-Enter", run: Zt },
  { key: "Alt-l", mac: "Ctrl-l", run: Nt },
  { key: "Mod-i", run: Pt, preventDefault: !0 },
  { key: "Mod-[", run: Fe },
  { key: "Mod-]", run: Ge },
  { key: "Mod-Alt-\\", run: _t },
  { key: "Shift-Mod-k", run: Qt },
  { key: "Shift-Mod-\\", run: xt },
  { key: "Mod-/", run: Qe },
  { key: "Alt-A", run: Ye },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: jt }
].concat(en), un = { key: "Tab", run: Ge, shift: Fe };
export {
  Wt as copyLineDown,
  $t as copyLineUp,
  ge as cursorCharLeft,
  ye as cursorCharRight,
  ee as cursorDocEnd,
  w as cursorDocStart,
  ft as cursorGroupLeft,
  at as cursorGroupRight,
  gt as cursorLineBoundaryBackward,
  pt as cursorLineBoundaryForward,
  yt as cursorLineBoundaryLeft,
  kt as cursorLineBoundaryRight,
  Se as cursorLineDown,
  Bt as cursorLineEnd,
  At as cursorLineStart,
  Be as cursorLineUp,
  xt as cursorMatchingBracket,
  q as cursorPageDown,
  Z as cursorPageUp,
  dt as cursorSyntaxLeft,
  mt as cursorSyntaxRight,
  sn as defaultKeymap,
  K as deleteCharBackward,
  ve as deleteCharForward,
  Pe as deleteGroupBackward,
  Vt as deleteGroupForward,
  Qt as deleteLine,
  Gt as deleteLineBoundaryBackward,
  Ft as deleteLineBoundaryForward,
  Jt as deleteToLineEnd,
  wt as emacsStyleKeymap,
  ln as history,
  cn as historyKeymap,
  Fe as indentLess,
  Ge as indentMore,
  _t as indentSelection,
  un as indentWithTab,
  Zt as insertBlankLine,
  Yt as insertNewlineAndIndent,
  tt as invertedEffects,
  et as isolateHistory,
  Kt as moveLineDown,
  qt as moveLineUp,
  H as redo,
  rt as redoSelection,
  vt as selectAll,
  Ce as selectCharLeft,
  Me as selectCharRight,
  ne as selectDocEnd,
  te as selectDocStart,
  Dt as selectGroupLeft,
  Lt as selectGroupRight,
  Nt as selectLine,
  Ot as selectLineBoundaryBackward,
  Et as selectLineBoundaryForward,
  Tt as selectLineBoundaryLeft,
  bt as selectLineBoundaryRight,
  be as selectLineDown,
  It as selectLineEnd,
  Rt as selectLineStart,
  Te as selectLineUp,
  j as selectPageDown,
  _ as selectPageUp,
  Pt as selectParentSyntax,
  Ct as selectSyntaxLeft,
  Mt as selectSyntaxRight,
  Ut as simplifySelection,
  zt as splitLine,
  en as standardKeymap,
  Ye as toggleBlockComment,
  Ze as toggleBlockCommentByLine,
  Qe as toggleComment,
  Xe as toggleLineComment,
  jt as toggleTabFocusMode,
  Ht as transposeChars,
  he as undo,
  nt as undoSelection
};
//# sourceMappingURL=index.mjs.map
