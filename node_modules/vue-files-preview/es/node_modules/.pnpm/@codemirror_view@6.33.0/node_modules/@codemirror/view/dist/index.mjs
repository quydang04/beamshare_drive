import { MapMode as wt, EditorSelection as k, EditorState as Nt, Transaction as Sn, Prec as ii, Facet as M, StateEffect as Dt, RangeValue as hs, RangeSet as V, ChangeSet as as, findClusterBreak as bt, findColumn as Le, Text as Y, Annotation as Cn, codePointAt as cs, codePointSize as Mn, CharCategory as kn, countColumn as fs, combineConfig as si, StateField as ds, RangeSetBuilder as An } from "../../../../../@codemirror_state@6.4.1/node_modules/@codemirror/state/dist/index.mjs";
import { StyleModule as St } from "../../../../../style-mod@4.1.2/node_modules/style-mod/src/style-mod.mjs";
import { keyName as Dn, base as On, shift as Tn } from "../../../../../w3c-keyname@2.2.8/node_modules/w3c-keyname/index.mjs";
function zt(n) {
  let t;
  return n.nodeType == 11 ? t = n.getSelection ? n : n.ownerDocument : t = n, t.getSelection();
}
function Be(n, t) {
  return t ? n == t || n.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
function Rn(n) {
  let t = n.activeElement;
  for (; t && t.shadowRoot; )
    t = t.shadowRoot.activeElement;
  return t;
}
function le(n, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return Be(n, t.anchorNode);
  } catch {
    return !1;
  }
}
function Ct(n) {
  return n.nodeType == 3 ? ut(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function Vt(n, t, e, i) {
  return e ? gi(n, t, e, i, -1) || gi(n, t, e, i, 1) : !1;
}
function dt(n) {
  for (var t = 0; ; t++)
    if (n = n.previousSibling, !n)
      return t;
}
function ue(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
function gi(n, t, e, i, s) {
  for (; ; ) {
    if (n == e && t == i)
      return !0;
    if (t == (s < 0 ? 0 : tt(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let o = n.parentNode;
      if (!o || o.nodeType != 1)
        return !1;
      t = dt(n) + (s < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[t + (s < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      t = s < 0 ? tt(n) : 0;
    } else
      return !1;
  }
}
function tt(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function qt(n, t) {
  let e = t ? n.left : n.right;
  return { left: e, right: e, top: n.top, bottom: n.bottom };
}
function En(n) {
  let t = n.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function us(n, t) {
  let e = t.width / n.offsetWidth, i = t.height / n.offsetHeight;
  return (e > 0.995 && e < 1.005 || !isFinite(e) || Math.abs(t.width - n.offsetWidth) < 1) && (e = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(t.height - n.offsetHeight) < 1) && (i = 1), { scaleX: e, scaleY: i };
}
function Ln(n, t, e, i, s, o, r, l) {
  let h = n.ownerDocument, c = h.defaultView || window;
  for (let a = n, f = !1; a && !f; )
    if (a.nodeType == 1) {
      let d, u = a == h.body, p = 1, g = 1;
      if (u)
        d = En(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(a).position) && (f = !0), a.scrollHeight <= a.clientHeight && a.scrollWidth <= a.clientWidth) {
          a = a.assignedSlot || a.parentNode;
          continue;
        }
        let w = a.getBoundingClientRect();
        ({ scaleX: p, scaleY: g } = us(a, w)), d = {
          left: w.left,
          right: w.left + a.clientWidth * p,
          top: w.top,
          bottom: w.top + a.clientHeight * g
        };
      }
      let b = 0, m = 0;
      if (s == "nearest")
        t.top < d.top ? (m = -(d.top - t.top + r), e > 0 && t.bottom > d.bottom + m && (m = t.bottom - d.bottom + m + r)) : t.bottom > d.bottom && (m = t.bottom - d.bottom + r, e < 0 && t.top - m < d.top && (m = -(d.top + m - t.top + r)));
      else {
        let w = t.bottom - t.top, v = d.bottom - d.top;
        m = (s == "center" && w <= v ? t.top + w / 2 - v / 2 : s == "start" || s == "center" && e < 0 ? t.top - r : t.bottom - v + r) - d.top;
      }
      if (i == "nearest" ? t.left < d.left ? (b = -(d.left - t.left + o), e > 0 && t.right > d.right + b && (b = t.right - d.right + b + o)) : t.right > d.right && (b = t.right - d.right + o, e < 0 && t.left < d.left + b && (b = -(d.left + b - t.left + o))) : b = (i == "center" ? t.left + (t.right - t.left) / 2 - (d.right - d.left) / 2 : i == "start" == l ? t.left - o : t.right - (d.right - d.left) + o) - d.left, b || m)
        if (u)
          c.scrollBy(b, m);
        else {
          let w = 0, v = 0;
          if (m) {
            let x = a.scrollTop;
            a.scrollTop += m / g, v = (a.scrollTop - x) * g;
          }
          if (b) {
            let x = a.scrollLeft;
            a.scrollLeft += b / p, w = (a.scrollLeft - x) * p;
          }
          t = {
            left: t.left - w,
            top: t.top - v,
            right: t.right - w,
            bottom: t.bottom - v
          }, w && Math.abs(w - b) < 1 && (i = "nearest"), v && Math.abs(v - m) < 1 && (s = "nearest");
        }
      if (u)
        break;
      a = a.assignedSlot || a.parentNode;
    } else if (a.nodeType == 11)
      a = a.host;
    else
      break;
}
function Bn(n) {
  let t = n.ownerDocument, e, i;
  for (let s = n.parentNode; s && !(s == t.body || e && i); )
    if (s.nodeType == 1)
      !i && s.scrollHeight > s.clientHeight && (i = s), !e && s.scrollWidth > s.clientWidth && (e = s), s = s.assignedSlot || s.parentNode;
    else if (s.nodeType == 11)
      s = s.host;
    else
      break;
  return { x: e, y: i };
}
class Pn {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: e, focusNode: i } = t;
    this.set(e, Math.min(t.anchorOffset, e ? tt(e) : 0), i, Math.min(t.focusOffset, i ? tt(i) : 0));
  }
  set(t, e, i, s) {
    this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = s;
  }
}
let mt = null;
function ps(n) {
  if (n.setActive)
    return n.setActive();
  if (mt)
    return n.focus(mt);
  let t = [];
  for (let e = n; e && (t.push(e, e.scrollTop, e.scrollLeft), e != e.ownerDocument); e = e.parentNode)
    ;
  if (n.focus(mt == null ? {
    get preventScroll() {
      return mt = { preventScroll: !0 }, !0;
    }
  } : void 0), !mt) {
    mt = !1;
    for (let e = 0; e < t.length; ) {
      let i = t[e++], s = t[e++], o = t[e++];
      i.scrollTop != s && (i.scrollTop = s), i.scrollLeft != o && (i.scrollLeft = o);
    }
  }
}
let mi;
function ut(n, t, e = t) {
  let i = mi || (mi = document.createRange());
  return i.setEnd(n, e), i.setStart(n, t), i;
}
function xt(n, t, e, i) {
  let s = { key: t, code: t, keyCode: e, which: e, cancelable: !0 };
  i && ({ altKey: s.altKey, ctrlKey: s.ctrlKey, shiftKey: s.shiftKey, metaKey: s.metaKey } = i);
  let o = new KeyboardEvent("keydown", s);
  o.synthetic = !0, n.dispatchEvent(o);
  let r = new KeyboardEvent("keyup", s);
  return r.synthetic = !0, n.dispatchEvent(r), o.defaultPrevented || r.defaultPrevented;
}
function Hn(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function gs(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function Nn(n, t) {
  let e = t.focusNode, i = t.focusOffset;
  if (!e || t.anchorNode != e || t.anchorOffset != i)
    return !1;
  for (i = Math.min(i, tt(e)); ; )
    if (i) {
      if (e.nodeType != 1)
        return !1;
      let s = e.childNodes[i - 1];
      s.contentEditable == "false" ? i-- : (e = s, i = tt(e));
    } else {
      if (e == n)
        return !0;
      i = dt(e), e = e.parentNode;
    }
}
function ms(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
function bs(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i > 0)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i - 1], i = tt(e);
    } else if (e.parentNode && !ue(e))
      i = dt(e), e = e.parentNode;
    else
      return null;
  }
}
function ys(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i < e.nodeValue.length)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i], i = 0;
    } else if (e.parentNode && !ue(e))
      i = dt(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
class N {
  constructor(t, e, i = !0) {
    this.node = t, this.offset = e, this.precise = i;
  }
  static before(t, e) {
    return new N(t.parentNode, dt(t), e);
  }
  static after(t, e) {
    return new N(t.parentNode, dt(t) + 1, e);
  }
}
const ni = [];
class O {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let e = this.posAtStart;
    for (let i of this.children) {
      if (i == t)
        return e;
      e += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  sync(t, e) {
    if (this.flags & 2) {
      let i = this.dom, s = null, o;
      for (let r of this.children) {
        if (r.flags & 7) {
          if (!r.dom && (o = s ? s.nextSibling : i.firstChild)) {
            let l = O.get(o);
            (!l || !l.parent && l.canReuseDOM(r)) && r.reuseDOM(o);
          }
          r.sync(t, e), r.flags &= -8;
        }
        if (o = s ? s.nextSibling : i.firstChild, e && !e.written && e.node == i && o != r.dom && (e.written = !0), r.dom.parentNode == i)
          for (; o && o != r.dom; )
            o = bi(o);
        else
          i.insertBefore(r.dom, o);
        s = r.dom;
      }
      for (o = s ? s.nextSibling : i.firstChild, o && e && e.node == i && (e.written = !0); o; )
        o = bi(o);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(t, e), i.flags &= -8);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, e) {
    let i;
    if (t == this.dom)
      i = this.dom.childNodes[e];
    else {
      let s = tt(t) == 0 ? 0 : e == 0 ? -1 : 1;
      for (; ; ) {
        let o = t.parentNode;
        if (o == this.dom)
          break;
        s == 0 && o.firstChild != o.lastChild && (t == o.firstChild ? s = -1 : s = 1), t = o;
      }
      s < 0 ? i = t : i = t.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !O.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let s = 0, o = 0; ; s++) {
      let r = this.children[s];
      if (r.dom == i)
        return o;
      o += r.length + r.breakAfter;
    }
  }
  domBoundsAround(t, e, i = 0) {
    let s = -1, o = -1, r = -1, l = -1;
    for (let h = 0, c = i, a = i; h < this.children.length; h++) {
      let f = this.children[h], d = c + f.length;
      if (c < t && d > e)
        return f.domBoundsAround(t, e, c);
      if (d >= t && s == -1 && (s = h, o = c), c > e && f.dom.parentNode == this.dom) {
        r = h, l = a;
        break;
      }
      a = d, c = d + f.breakAfter;
    }
    return {
      from: o,
      to: l < 0 ? i + this.length : l,
      startDOM: (s ? this.children[s - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: r < this.children.length && r >= 0 ? this.children[r].dom : null
    };
  }
  markDirty(t = !1) {
    this.flags |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let e = this.parent; e; e = e.parent) {
      if (t && (e.flags |= 2), e.flags & 1)
        return;
      e.flags |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom != t && (this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this);
  }
  get rootView() {
    for (let t = this; ; ) {
      let e = t.parent;
      if (!e)
        return t;
      t = e;
    }
  }
  replaceChildren(t, e, i = ni) {
    this.markDirty();
    for (let s = t; s < e; s++) {
      let o = this.children[s];
      o.parent == this && i.indexOf(o) < 0 && o.destroy();
    }
    this.children.splice(t, e - t, ...i);
    for (let s = 0; s < i.length; s++)
      i[s].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new ws(this.children, t, this.children.length);
  }
  childPos(t, e = 1) {
    return this.childCursor().findPos(t, e);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(t, e, i, s, o, r) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor && !((this.flags | t.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let t of this.children)
      t.parent == this && t.destroy();
    this.parent = null;
  }
}
O.prototype.breakAfter = 0;
function bi(n) {
  let t = n.nextSibling;
  return n.parentNode.removeChild(n), t;
}
class ws {
  constructor(t, e, i) {
    this.children = t, this.pos = e, this.i = i, this.off = 0;
  }
  findPos(t, e = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (e > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function xs(n, t, e, i, s, o, r, l, h) {
  let { children: c } = n, a = c.length ? c[t] : null, f = o.length ? o[o.length - 1] : null, d = f ? f.breakAfter : r;
  if (!(t == i && a && !r && !d && o.length < 2 && a.merge(e, s, o.length ? f : null, e == 0, l, h))) {
    if (i < c.length) {
      let u = c[i];
      u && (s < u.length || u.breakAfter && (f != null && f.breakAfter)) ? (t == i && (u = u.split(s), s = 0), !d && f && u.merge(0, s, f, !0, 0, h) ? o[o.length - 1] = u : ((s || u.children.length && !u.children[0].length) && u.merge(0, s, null, !1, 0, h), o.push(u))) : u != null && u.breakAfter && (f ? f.breakAfter = 1 : r = 1), i++;
    }
    for (a && (a.breakAfter = r, e > 0 && (!r && o.length && a.merge(e, a.length, o[0], !1, l, 0) ? a.breakAfter = o.shift().breakAfter : (e < a.length || a.children.length && a.children[a.children.length - 1].length == 0) && a.merge(e, a.length, null, !1, l, 0), t++)); t < i && o.length; )
      if (c[i - 1].become(o[o.length - 1]))
        i--, o.pop(), h = o.length ? 0 : l;
      else if (c[t].become(o[0]))
        t++, o.shift(), l = o.length ? 0 : h;
      else
        break;
    !o.length && t && i < c.length && !c[t - 1].breakAfter && c[i].merge(0, 0, c[t - 1], !1, l, h) && t--, (t < i || o.length) && n.replaceChildren(t, i, o);
  }
}
function vs(n, t, e, i, s, o) {
  let r = n.childCursor(), { i: l, off: h } = r.findPos(e, 1), { i: c, off: a } = r.findPos(t, -1), f = t - e;
  for (let d of i)
    f += d.length;
  n.length += f, xs(n, c, a, l, h, i, 0, s, o);
}
let I = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Pe = typeof document < "u" ? document : { documentElement: { style: {} } };
const He = /* @__PURE__ */ /Edge\/(\d+)/.exec(I.userAgent), Ss = /* @__PURE__ */ /MSIE \d/.test(I.userAgent), Ne = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(I.userAgent), we = !!(Ss || Ne || He), yi = !we && /* @__PURE__ */ /gecko\/(\d+)/i.test(I.userAgent), Se = !we && /* @__PURE__ */ /Chrome\/(\d+)/.exec(I.userAgent), wi = "webkitFontSmoothing" in Pe.documentElement.style, Cs = !we && /* @__PURE__ */ /Apple Computer/.test(I.vendor), xi = Cs && (/* @__PURE__ */ /Mobile\/\w+/.test(I.userAgent) || I.maxTouchPoints > 2);
var y = {
  mac: xi || /* @__PURE__ */ /Mac/.test(I.platform),
  windows: /* @__PURE__ */ /Win/.test(I.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(I.platform),
  ie: we,
  ie_version: Ss ? Pe.documentMode || 6 : Ne ? +Ne[1] : He ? +He[1] : 0,
  gecko: yi,
  gecko_version: yi ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(I.userAgent) || [0, 0])[1] : 0,
  chrome: !!Se,
  chrome_version: Se ? +Se[1] : 0,
  ios: xi,
  android: /* @__PURE__ */ /Android\b/.test(I.userAgent),
  webkit: wi,
  safari: Cs,
  webkit_version: wi ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(I.userAgent) || [0, 0])[1] : 0,
  tabSize: Pe.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const Vn = 256;
class _ extends O {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t, e) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, e, i) {
    return this.flags & 8 || i && (!(i instanceof _) || this.length - (e - t) + i.length > Vn || i.flags & 8) ? !1 : (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(e), this.markDirty(), !0);
  }
  split(t) {
    let e = new _(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), e.flags |= this.flags & 8, e;
  }
  localPosFromDOM(t, e) {
    return t == this.dom ? e : e ? this.text.length : 0;
  }
  domAtPos(t) {
    return new N(this.dom, t);
  }
  domBoundsAround(t, e, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, e) {
    return Fn(this.dom, t, e);
  }
}
class et extends O {
  constructor(t, e = [], i = 0) {
    super(), this.mark = t, this.children = e, this.length = i;
    for (let s of e)
      s.setParent(this);
  }
  setAttrs(t) {
    if (gs(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let e in this.mark.attrs)
        t.setAttribute(e, this.mark.attrs[e]);
    return t;
  }
  canReuseDOM(t) {
    return super.canReuseDOM(t) && !((this.flags | t.flags) & 8);
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, e);
  }
  merge(t, e, i, s, o, r) {
    return i && (!(i instanceof et && i.mark.eq(this.mark)) || t && o <= 0 || e < this.length && r <= 0) ? !1 : (vs(this, t, e, i ? i.children.slice() : [], o - 1, r - 1), this.markDirty(), !0);
  }
  split(t) {
    let e = [], i = 0, s = -1, o = 0;
    for (let l of this.children) {
      let h = i + l.length;
      h > t && e.push(i < t ? l.split(t - i) : l), s < 0 && i >= t && (s = o), i = h, o++;
    }
    let r = this.length - t;
    return this.length = t, s > -1 && (this.children.length = s, this.markDirty()), new et(this.mark, e, r);
  }
  domAtPos(t) {
    return Ms(this, t);
  }
  coordsAt(t, e) {
    return As(this, t, e);
  }
}
function Fn(n, t, e) {
  let i = n.nodeValue.length;
  t > i && (t = i);
  let s = t, o = t, r = 0;
  t == 0 && e < 0 || t == i && e >= 0 ? y.chrome || y.gecko || (t ? (s--, r = 1) : o < i && (o++, r = -1)) : e < 0 ? s-- : o < i && o++;
  let l = ut(n, s, o).getClientRects();
  if (!l.length)
    return null;
  let h = l[(r ? r < 0 : e >= 0) ? 0 : l.length - 1];
  return y.safari && !r && h.width == 0 && (h = Array.prototype.find.call(l, (c) => c.width) || h), r ? qt(h, r < 0) : h || null;
}
class rt extends O {
  static create(t, e, i) {
    return new rt(t, e, i);
  }
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.side = i, this.prevWidget = null;
  }
  split(t) {
    let e = rt.create(this.widget, this.length - t, this.side);
    return this.length -= t, e;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(t, e, i, s, o, r) {
    return i && (!(i instanceof rt) || !this.widget.compare(i.widget) || t > 0 && o <= 0 || e < this.length && r <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  become(t) {
    return t instanceof rt && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Y.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let { view: e } = t, i = e && e.state.doc, s = this.posAtStart;
    return i ? i.slice(s, s + this.length) : Y.empty;
  }
  domAtPos(t) {
    return (this.length ? t == 0 : this.side > 0) ? N.before(this.dom) : N.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, e) {
    let i = this.widget.coordsAt(this.dom, t, e);
    if (i)
      return i;
    let s = this.dom.getClientRects(), o = null;
    if (!s.length)
      return null;
    let r = this.side ? this.side < 0 : t > 0;
    for (let l = r ? s.length - 1 : 0; o = s[l], !(t > 0 ? l == 0 : l == s.length - 1 || o.top < o.bottom); l += r ? -1 : 1)
      ;
    return qt(o, !r);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Mt extends O {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof Mt && t.side == this.side;
  }
  split() {
    return new Mt(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return this.side > 0 ? N.before(this.dom) : N.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Y.empty;
  }
  get isHidden() {
    return !0;
  }
}
_.prototype.children = rt.prototype.children = Mt.prototype.children = ni;
function Ms(n, t) {
  let e = n.dom, { children: i } = n, s = 0;
  for (let o = 0; s < i.length; s++) {
    let r = i[s], l = o + r.length;
    if (!(l == o && r.getSide() <= 0)) {
      if (t > o && t < l && r.dom.parentNode == e)
        return r.domAtPos(t - o);
      if (t <= o)
        break;
      o = l;
    }
  }
  for (let o = s; o > 0; o--) {
    let r = i[o - 1];
    if (r.dom.parentNode == e)
      return r.domAtPos(r.length);
  }
  for (let o = s; o < i.length; o++) {
    let r = i[o];
    if (r.dom.parentNode == e)
      return r.domAtPos(0);
  }
  return new N(e, 0);
}
function ks(n, t, e) {
  let i, { children: s } = n;
  e > 0 && t instanceof et && s.length && (i = s[s.length - 1]) instanceof et && i.mark.eq(t.mark) ? ks(i, t.children[0], e - 1) : (s.push(t), t.setParent(n)), n.length += t.length;
}
function As(n, t, e) {
  let i = null, s = -1, o = null, r = -1;
  function l(c, a) {
    for (let f = 0, d = 0; f < c.children.length && d <= a; f++) {
      let u = c.children[f], p = d + u.length;
      p >= a && (u.children.length ? l(u, a - d) : (!o || o.isHidden && e > 0) && (p > a || d == p && u.getSide() > 0) ? (o = u, r = a - d) : (d < a || d == p && u.getSide() < 0 && !u.isHidden) && (i = u, s = a - d)), d = p;
    }
  }
  l(n, t);
  let h = (e < 0 ? i : o) || i || o;
  return h ? h.coordsAt(Math.max(0, h == i ? s : r), e) : Wn(n);
}
function Wn(n) {
  let t = n.dom.lastChild;
  if (!t)
    return n.dom.getBoundingClientRect();
  let e = Ct(t);
  return e[e.length - 1] || null;
}
function Ve(n, t) {
  for (let e in n)
    e == "class" && t.class ? t.class += " " + n.class : e == "style" && t.style ? t.style += ";" + n.style : t[e] = n[e];
  return t;
}
const vi = /* @__PURE__ */ Object.create(null);
function pe(n, t, e) {
  if (n == t)
    return !0;
  n || (n = vi), t || (t = vi);
  let i = Object.keys(n), s = Object.keys(t);
  if (i.length - (e && i.indexOf(e) > -1 ? 1 : 0) != s.length - (e && s.indexOf(e) > -1 ? 1 : 0))
    return !1;
  for (let o of i)
    if (o != e && (s.indexOf(o) == -1 || n[o] !== t[o]))
      return !1;
  return !0;
}
function Fe(n, t, e) {
  let i = !1;
  if (t)
    for (let s in t)
      e && s in e || (i = !0, s == "style" ? n.style.cssText = "" : n.removeAttribute(s));
  if (e)
    for (let s in e)
      t && t[s] == e[s] || (i = !0, s == "style" ? n.style.cssText = e[s] : n.setAttribute(s, e[s]));
  return i;
}
function zn(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e = 0; e < n.attributes.length; e++) {
    let i = n.attributes[e];
    t[i.name] = i.value;
  }
  return t;
}
class Ot {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, e) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedâ€”less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, e, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}
var F = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(F || (F = {}));
class R extends hs {
  constructor(t, e, i, s) {
    super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new jt(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let e = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block;
    return e += i && !t.inlineOrder ? e > 0 ? 3e8 : -4e8 : e > 0 ? 1e8 : -1e8, new ht(t, e, e, i, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let e = !!t.block, i, s;
    if (t.isBlockGap)
      i = -5e8, s = 4e8;
    else {
      let { start: o, end: r } = Ds(t, e);
      i = (o ? e ? -3e8 : -1 : 5e8) - 1, s = (r ? e ? 2e8 : 1 : -6e8) + 1;
    }
    return new ht(t, i, s, e, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new Yt(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, e = !1) {
    return V.of(t, e);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
R.none = V.empty;
class jt extends R {
  constructor(t) {
    let { start: e, end: i } = Ds(t);
    super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    var e, i;
    return this == t || t instanceof jt && this.tagName == t.tagName && (this.class || ((e = this.attrs) === null || e === void 0 ? void 0 : e.class)) == (t.class || ((i = t.attrs) === null || i === void 0 ? void 0 : i.class)) && pe(this.attrs, t.attrs, "class");
  }
  range(t, e = t) {
    if (t >= e)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, e);
  }
}
jt.prototype.point = !1;
class Yt extends R {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof Yt && this.spec.class == t.spec.class && pe(this.spec.attributes, t.spec.attributes);
  }
  range(t, e = t) {
    if (e != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, e);
  }
}
Yt.prototype.mapMode = wt.TrackBefore;
Yt.prototype.point = !0;
class ht extends R {
  constructor(t, e, i, s, o, r) {
    super(e, i, o, t), this.block = s, this.isReplace = r, this.mapMode = s ? e <= 0 ? wt.TrackBefore : wt.TrackAfter : wt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? F.WidgetRange : this.startSide <= 0 ? F.WidgetBefore : F.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof ht && In(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, e = t) {
    if (this.isReplace && (t > e || t == e && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, e);
  }
}
ht.prototype.point = !0;
function Ds(n, t = !1) {
  let { inclusiveStart: e, inclusiveEnd: i } = n;
  return e == null && (e = n.inclusive), i == null && (i = n.inclusive), { start: e ?? t, end: i ?? t };
}
function In(n, t) {
  return n == t || !!(n && t && n.compare(t));
}
function We(n, t, e, i = 0) {
  let s = e.length - 1;
  s >= 0 && e[s] + i >= n ? e[s] = Math.max(e[s], t) : e.push(n, t);
}
class B extends O {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(t, e, i, s, o, r) {
    if (i) {
      if (!(i instanceof B))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return s && this.setDeco(i ? i.attrs : null), vs(this, t, e, i ? i.children.slice() : [], o, r), !0;
  }
  split(t) {
    let e = new B();
    if (e.breakAfter = this.breakAfter, this.length == 0)
      return e;
    let { i, off: s } = this.childPos(t);
    s && (e.append(this.children[i].split(s), 0), this.children[i].merge(s, this.children[i].length, null, !1, 0, 0), i++);
    for (let o = i; o < this.children.length; o++)
      e.append(this.children[o], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = t, e;
  }
  transferDOM(t) {
    this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    pe(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, e) {
    ks(this, t, e);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(t) {
    let e = t.spec.attributes, i = t.spec.class;
    e && (this.attrs = Ve(e, this.attrs || {})), i && (this.attrs = Ve({ class: i }, this.attrs || {}));
  }
  domAtPos(t) {
    return Ms(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    var i;
    this.dom ? this.flags & 4 && (gs(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Fe(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, e);
    let s = this.dom.lastChild;
    for (; s && O.get(s) instanceof et; )
      s = s.lastChild;
    if (!s || !this.length || s.nodeName != "BR" && ((i = O.get(s)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!y.ios || !this.children.some((o) => o instanceof _))) {
      let o = document.createElement("BR");
      o.cmIgnore = !0, this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0, e;
    for (let i of this.children) {
      if (!(i instanceof _) || /[^ -~]/.test(i.text))
        return null;
      let s = Ct(i.dom);
      if (s.length != 1)
        return null;
      t += s[0].width, e = s[0].height;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length,
      textHeight: e
    } : null;
  }
  coordsAt(t, e) {
    let i = As(this, t, e);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: s } = this.parent.view.viewState, o = i.bottom - i.top;
      if (Math.abs(o - s.lineHeight) < 2 && s.textHeight < o) {
        let r = (o - s.textHeight) / 2;
        return { top: i.top + r, bottom: i.bottom - r, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(t) {
    return t instanceof B && this.children.length == 0 && t.children.length == 0 && pe(this.attrs, t.attrs) && this.breakAfter == t.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(t, e) {
    for (let i = 0, s = 0; i < t.children.length; i++) {
      let o = t.children[i], r = s + o.length;
      if (r >= e) {
        if (o instanceof B)
          return o;
        if (r > e)
          break;
      }
      s = r + o.breakAfter;
    }
    return null;
  }
}
class Z extends O {
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, e, i, s, o, r) {
    return i && (!(i instanceof Z) || !this.widget.compare(i.widget) || t > 0 && o <= 0 || e < this.length && r <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  domAtPos(t) {
    return t == 0 ? N.before(this.dom) : N.after(this.dom, t == this.length);
  }
  split(t) {
    let e = this.length - t;
    this.length = t;
    let i = new Z(this.widget, e, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return ni;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Y.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof Z && t.widget.constructor == this.widget.constructor ? (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(t, e) {
    let i = this.widget.coordsAt(this.dom, t, e);
    return i || (this.widget instanceof ze ? null : qt(this.dom.getBoundingClientRect(), this.length ? t == 0 : e <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t) {
    let { startSide: e, endSide: i } = this.deco;
    return e == i ? !1 : t < 0 ? e < 0 : i > 0;
  }
}
class ze extends Ot {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Ft {
  constructor(t, e, i, s) {
    this.doc = t, this.pos = e, this.end = i, this.disallowBlockEffectsFor = s, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = e;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !(t.breakAfter || t instanceof Z && t.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new B()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Ut(new Mt(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer(), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(t && this.content.length && this.content[this.content.length - 1] instanceof Z) && this.getLine();
  }
  buildText(t, e, i) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: r, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (r) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let s = Math.min(
        this.text.length - this.textOff,
        t,
        512
        /* T.Chunk */
      );
      this.flushBuffer(e.slice(e.length - i)), this.getLine().append(Ut(new _(this.text.slice(this.textOff, this.textOff + s)), e), i), this.atCursorPos = !0, this.textOff += s, t -= s, i = 0;
    }
  }
  span(t, e, i, s) {
    this.buildText(e - t, i, s), this.pos = e, this.openStart < 0 && (this.openStart = s);
  }
  point(t, e, i, s, o, r) {
    if (this.disallowBlockEffectsFor[r] && i instanceof ht) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (e > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = e - t;
    if (i instanceof ht)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Z(i.widget || kt.block, l, i));
      else {
        let h = rt.create(i.widget || kt.inline, l, l ? 0 : i.startSide), c = this.atCursorPos && !h.isEditable && o <= s.length && (t < e || i.startSide > 0), a = !h.isEditable && (t < e || o > s.length || i.startSide <= 0), f = this.getLine();
        this.pendingBuffer == 2 && !c && !h.isEditable && (this.pendingBuffer = 0), this.flushBuffer(s), c && (f.append(Ut(new Mt(1), s), o), o = s.length + Math.max(0, o - s.length)), f.append(Ut(h, s), o), this.atCursorPos = a, this.pendingBuffer = a ? t < e || o > s.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e), this.openStart < 0 && (this.openStart = o);
  }
  static build(t, e, i, s, o) {
    let r = new Ft(t, e, i, o);
    return r.openEnd = V.spans(s, e, i, r), r.openStart < 0 && (r.openStart = r.openEnd), r.finish(r.openEnd), r;
  }
}
function Ut(n, t) {
  for (let e of t)
    n = new et(e, [n], n.length);
  return n;
}
class kt extends Ot {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
kt.inline = /* @__PURE__ */ new kt("span");
kt.block = /* @__PURE__ */ new kt("div");
var L = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(L || (L = {}));
const pt = L.LTR, oi = L.RTL;
function Os(n) {
  let t = [];
  for (let e = 0; e < n.length; e++)
    t.push(1 << +n[e]);
  return t;
}
const Kn = /* @__PURE__ */ Os("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), qn = /* @__PURE__ */ Os("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Ie = /* @__PURE__ */ Object.create(null), G = [];
for (let n of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ n.charCodeAt(0), e = /* @__PURE__ */ n.charCodeAt(1);
  Ie[t] = e, Ie[e] = -t;
}
function Ts(n) {
  return n <= 247 ? Kn[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? qn[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
const jn = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class lt {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? oi : pt;
  }
  /**
  @internal
  */
  constructor(t, e, i) {
    this.from = t, this.to = e, this.level = i;
  }
  /**
  @internal
  */
  side(t, e) {
    return this.dir == e == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, e) {
    return t == (this.dir == e);
  }
  /**
  @internal
  */
  static find(t, e, i, s) {
    let o = -1;
    for (let r = 0; r < t.length; r++) {
      let l = t[r];
      if (l.from <= e && l.to >= e) {
        if (l.level == i)
          return r;
        (o < 0 || (s != 0 ? s < 0 ? l.from < e : l.to > e : t[o].level > l.level)) && (o = r);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
}
function Rs(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++) {
    let i = n[e], s = t[e];
    if (i.from != s.from || i.to != s.to || i.direction != s.direction || !Rs(i.inner, s.inner))
      return !1;
  }
  return !0;
}
const D = [];
function Yn(n, t, e, i, s) {
  for (let o = 0; o <= i.length; o++) {
    let r = o ? i[o - 1].to : t, l = o < i.length ? i[o].from : e, h = o ? 256 : s;
    for (let c = r, a = h, f = h; c < l; c++) {
      let d = Ts(n.charCodeAt(c));
      d == 512 ? d = a : d == 8 && f == 4 && (d = 16), D[c] = d == 4 ? 2 : d, d & 7 && (f = d), a = d;
    }
    for (let c = r, a = h, f = h; c < l; c++) {
      let d = D[c];
      if (d == 128)
        c < l - 1 && a == D[c + 1] && a & 24 ? d = D[c] = a : D[c] = 256;
      else if (d == 64) {
        let u = c + 1;
        for (; u < l && D[u] == 64; )
          u++;
        let p = c && a == 8 || u < e && D[u] == 8 ? f == 1 ? 1 : 8 : 256;
        for (let g = c; g < u; g++)
          D[g] = p;
        c = u - 1;
      } else d == 8 && f == 1 && (D[c] = 1);
      a = d, d & 7 && (f = d);
    }
  }
}
function _n(n, t, e, i, s) {
  let o = s == 1 ? 2 : 1;
  for (let r = 0, l = 0, h = 0; r <= i.length; r++) {
    let c = r ? i[r - 1].to : t, a = r < i.length ? i[r].from : e;
    for (let f = c, d, u, p; f < a; f++)
      if (u = Ie[d = n.charCodeAt(f)])
        if (u < 0) {
          for (let g = l - 3; g >= 0; g -= 3)
            if (G[g + 1] == -u) {
              let b = G[g + 2], m = b & 2 ? s : b & 4 ? b & 1 ? o : s : 0;
              m && (D[f] = D[G[g]] = m), l = g;
              break;
            }
        } else {
          if (G.length == 189)
            break;
          G[l++] = f, G[l++] = d, G[l++] = h;
        }
      else if ((p = D[f]) == 2 || p == 1) {
        let g = p == s;
        h = g ? 0 : 1;
        for (let b = l - 3; b >= 0; b -= 3) {
          let m = G[b + 2];
          if (m & 2)
            break;
          if (g)
            G[b + 2] |= 2;
          else {
            if (m & 4)
              break;
            G[b + 2] |= 4;
          }
        }
      }
  }
}
function Xn(n, t, e, i) {
  for (let s = 0, o = i; s <= e.length; s++) {
    let r = s ? e[s - 1].to : n, l = s < e.length ? e[s].from : t;
    for (let h = r; h < l; ) {
      let c = D[h];
      if (c == 256) {
        let a = h + 1;
        for (; ; )
          if (a == l) {
            if (s == e.length)
              break;
            a = e[s++].to, l = s < e.length ? e[s].from : t;
          } else if (D[a] == 256)
            a++;
          else
            break;
        let f = o == 1, d = (a < t ? D[a] : i) == 1, u = f == d ? f ? 1 : 2 : i;
        for (let p = a, g = s, b = g ? e[g - 1].to : n; p > h; )
          p == b && (p = e[--g].from, b = g ? e[g - 1].to : n), D[--p] = u;
        h = a;
      } else
        o = c, h++;
    }
  }
}
function Ke(n, t, e, i, s, o, r) {
  let l = i % 2 ? 2 : 1;
  if (i % 2 == s % 2)
    for (let h = t, c = 0; h < e; ) {
      let a = !0, f = !1;
      if (c == o.length || h < o[c].from) {
        let g = D[h];
        g != l && (a = !1, f = g == 16);
      }
      let d = !a && l == 1 ? [] : null, u = a ? i : i + 1, p = h;
      t: for (; ; )
        if (c < o.length && p == o[c].from) {
          if (f)
            break t;
          let g = o[c];
          if (!a)
            for (let b = g.to, m = c + 1; ; ) {
              if (b == e)
                break t;
              if (m < o.length && o[m].from == b)
                b = o[m++].to;
              else {
                if (D[b] == l)
                  break t;
                break;
              }
            }
          if (c++, d)
            d.push(g);
          else {
            g.from > h && r.push(new lt(h, g.from, u));
            let b = g.direction == pt != !(u % 2);
            qe(n, b ? i + 1 : i, s, g.inner, g.from, g.to, r), h = g.to;
          }
          p = g.to;
        } else {
          if (p == e || (a ? D[p] != l : D[p] == l))
            break;
          p++;
        }
      d ? Ke(n, h, p, i + 1, s, d, r) : h < p && r.push(new lt(h, p, u)), h = p;
    }
  else
    for (let h = e, c = o.length; h > t; ) {
      let a = !0, f = !1;
      if (!c || h > o[c - 1].to) {
        let g = D[h - 1];
        g != l && (a = !1, f = g == 16);
      }
      let d = !a && l == 1 ? [] : null, u = a ? i : i + 1, p = h;
      t: for (; ; )
        if (c && p == o[c - 1].to) {
          if (f)
            break t;
          let g = o[--c];
          if (!a)
            for (let b = g.from, m = c; ; ) {
              if (b == t)
                break t;
              if (m && o[m - 1].to == b)
                b = o[--m].from;
              else {
                if (D[b - 1] == l)
                  break t;
                break;
              }
            }
          if (d)
            d.push(g);
          else {
            g.to < h && r.push(new lt(g.to, h, u));
            let b = g.direction == pt != !(u % 2);
            qe(n, b ? i + 1 : i, s, g.inner, g.from, g.to, r), h = g.from;
          }
          p = g.from;
        } else {
          if (p == t || (a ? D[p - 1] != l : D[p - 1] == l))
            break;
          p--;
        }
      d ? Ke(n, p, h, i + 1, s, d, r) : p < h && r.push(new lt(p, h, u)), h = p;
    }
}
function qe(n, t, e, i, s, o, r) {
  let l = t % 2 ? 2 : 1;
  Yn(n, s, o, i, l), _n(n, s, o, i, l), Xn(s, o, i, l), Ke(n, s, o, t, e, i, r);
}
function Gn(n, t, e) {
  if (!n)
    return [new lt(0, 0, t == oi ? 1 : 0)];
  if (t == pt && !e.length && !jn.test(n))
    return Es(n.length);
  if (e.length)
    for (; n.length > D.length; )
      D[D.length] = 256;
  let i = [], s = t == pt ? 0 : 1;
  return qe(n, s, s, e, 0, n.length, i), i;
}
function Es(n) {
  return [new lt(0, n, 0)];
}
let Ls = "";
function $n(n, t, e, i, s) {
  var o;
  let r = i.head - n.from, l = lt.find(t, r, (o = i.bidiLevel) !== null && o !== void 0 ? o : -1, i.assoc), h = t[l], c = h.side(s, e);
  if (r == c) {
    let d = l += s ? 1 : -1;
    if (d < 0 || d >= t.length)
      return null;
    h = t[l = d], r = h.side(!s, e), c = h.side(s, e);
  }
  let a = bt(n.text, r, h.forward(s, e));
  (a < h.from || a > h.to) && (a = c), Ls = n.text.slice(Math.min(r, a), Math.max(r, a));
  let f = l == (s ? t.length - 1 : 0) ? null : t[l + (s ? 1 : -1)];
  return f && a == c && f.level + (s ? 0 : 1) < h.level ? k.cursor(f.side(!s, e) + n.from, f.forward(s, e) ? 1 : -1, f.level) : k.cursor(a + n.from, h.forward(s, e) ? -1 : 1, h.level);
}
function Un(n, t, e) {
  for (let i = t; i < e; i++) {
    let s = Ts(n.charCodeAt(i));
    if (s == 1)
      return pt;
    if (s == 2 || s == 4)
      return oi;
  }
  return pt;
}
const Bs = /* @__PURE__ */ M.define(), Ps = /* @__PURE__ */ M.define(), Hs = /* @__PURE__ */ M.define(), Ns = /* @__PURE__ */ M.define(), je = /* @__PURE__ */ M.define(), Vs = /* @__PURE__ */ M.define(), Fs = /* @__PURE__ */ M.define(), ri = /* @__PURE__ */ M.define(), li = /* @__PURE__ */ M.define(), Ws = /* @__PURE__ */ M.define({
  combine: (n) => n.some((t) => t)
}), zs = /* @__PURE__ */ M.define({
  combine: (n) => n.some((t) => t)
}), Is = /* @__PURE__ */ M.define();
class vt {
  constructor(t, e = "nearest", i = "nearest", s = 5, o = 5, r = !1) {
    this.range = t, this.y = e, this.x = i, this.yMargin = s, this.xMargin = o, this.isSnapshot = r;
  }
  map(t) {
    return t.empty ? this : new vt(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new vt(k.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Qt = /* @__PURE__ */ Dt.define({ map: (n, t) => n.map(t) }), Ks = /* @__PURE__ */ Dt.define();
function U(n, t, e) {
  let i = n.facet(Ns);
  i.length ? i[0](t) : window.onerror ? window.onerror(String(t), e, void 0, void 0, t) : e ? console.error(e + ":", t) : console.error(t);
}
const nt = /* @__PURE__ */ M.define({ combine: (n) => n.length ? n[0] : !0 });
let Qn = 0;
const Et = /* @__PURE__ */ M.define();
class z {
  constructor(t, e, i, s, o) {
    this.id = t, this.create = e, this.domEventHandlers = i, this.domEventObservers = s, this.extension = o(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, e) {
    const { eventHandlers: i, eventObservers: s, provide: o, decorations: r } = e || {};
    return new z(Qn++, t, i, s, (l) => {
      let h = [Et.of(l)];
      return r && h.push(It.of((c) => {
        let a = c.plugin(l);
        return a ? r(a) : R.none;
      })), o && h.push(o(l)), h;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, e) {
    return z.define((i) => new t(i), e);
  }
}
class Ce {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let e = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(e);
          } catch (i) {
            if (U(e.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(t);
      } catch (e) {
        U(t.state, e, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var e;
    if (!((e = this.value) === null || e === void 0) && e.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        U(t.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const qs = /* @__PURE__ */ M.define(), hi = /* @__PURE__ */ M.define(), It = /* @__PURE__ */ M.define(), js = /* @__PURE__ */ M.define(), ai = /* @__PURE__ */ M.define(), Ys = /* @__PURE__ */ M.define();
function Si(n, t) {
  let e = n.state.facet(Ys);
  if (!e.length)
    return e;
  let i = e.map((o) => o instanceof Function ? o(n) : o), s = [];
  return V.spans(i, t.from, t.to, {
    point() {
    },
    span(o, r, l, h) {
      let c = o - t.from, a = r - t.from, f = s;
      for (let d = l.length - 1; d >= 0; d--, h--) {
        let u = l[d].spec.bidiIsolate, p;
        if (u == null && (u = Un(t.text, c, a)), h > 0 && f.length && (p = f[f.length - 1]).to == c && p.direction == u)
          p.to = a, f = p.inner;
        else {
          let g = { from: c, to: a, direction: u, inner: [] };
          f.push(g), f = g.inner;
        }
      }
    }
  }), s;
}
const _s = /* @__PURE__ */ M.define();
function Xs(n) {
  let t = 0, e = 0, i = 0, s = 0;
  for (let o of n.state.facet(_s)) {
    let r = o(n);
    r && (r.left != null && (t = Math.max(t, r.left)), r.right != null && (e = Math.max(e, r.right)), r.top != null && (i = Math.max(i, r.top)), r.bottom != null && (s = Math.max(s, r.bottom)));
  }
  return { left: t, right: e, top: i, bottom: s };
}
const Lt = /* @__PURE__ */ M.define();
class q {
  constructor(t, e, i, s) {
    this.fromA = t, this.toA = e, this.fromB = i, this.toB = s;
  }
  join(t) {
    return new q(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let e = t.length, i = this;
    for (; e > 0; e--) {
      let s = t[e - 1];
      if (!(s.fromA > i.toA)) {
        if (s.toA < i.fromA)
          break;
        i = i.join(s), t.splice(e - 1, 1);
      }
    }
    return t.splice(e, 0, i), t;
  }
  static extendWithRanges(t, e) {
    if (e.length == 0)
      return t;
    let i = [];
    for (let s = 0, o = 0, r = 0, l = 0; ; s++) {
      let h = s == t.length ? null : t[s], c = r - l, a = h ? h.fromB : 1e9;
      for (; o < e.length && e[o] < a; ) {
        let f = e[o], d = e[o + 1], u = Math.max(l, f), p = Math.min(a, d);
        if (u <= p && new q(u + c, p + c, u, p).addToSet(i), d > a)
          break;
        o += 2;
      }
      if (!h)
        return i;
      new q(h.fromA, h.toA, h.fromB, h.toB).addToSet(i), r = h.toA, l = h.toB;
    }
  }
}
class ge {
  constructor(t, e, i) {
    this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = as.empty(this.startState.doc.length);
    for (let o of i)
      this.changes = this.changes.compose(o.changes);
    let s = [];
    this.changes.iterChangedRanges((o, r, l, h) => s.push(new q(o, r, l, h))), this.changedRanges = s;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new ge(t, e, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class Ci extends O {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t) {
    super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = R.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new B()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new q(0, 0, 0, t.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(t) {
    var e;
    let i = t.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: c, toA: a }) => a < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t);
    let s = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((e = this.domChanged) === null || e === void 0) && e.newSel ? s = this.domChanged.newSel.head : !no(t.changes, this.hasComposition) && !t.selectionSet && (s = t.state.selection.main.head));
    let o = s > -1 ? Zn(this.view, t.changes, s) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: a } = this.hasComposition;
      i = new q(c, a, t.changes.mapPos(c, -1), t.changes.mapPos(a, 1)).addToSet(i.slice());
    }
    this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, (y.ie || y.chrome) && !o && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let r = this.decorations, l = this.updateDeco(), h = io(r, l, t.changes);
    return i = q.extendWithRanges(i, h), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, t.startState.doc.length, o), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, e, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, e, i);
    let { observer: s } = this.view;
    s.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let r = y.chrome || y.ios ? { node: s.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, r), this.flags &= -8, r && (r.written || s.selectionRange.focusNode != r.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (r) => r.flags &= -9
      /* ViewFlag.Composition */
    );
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let r of this.children)
        r instanceof Z && r.widget instanceof ze && o.push(r.dom);
    s.updateGaps(o);
  }
  updateChildren(t, e, i) {
    let s = i ? i.range.addToSet(t.slice()) : t, o = this.childCursor(e);
    for (let r = s.length - 1; ; r--) {
      let l = r >= 0 ? s[r] : null;
      if (!l)
        break;
      let { fromA: h, toA: c, fromB: a, toB: f } = l, d, u, p, g;
      if (i && i.range.fromB < f && i.range.toB > a) {
        let x = Ft.build(this.view.state.doc, a, i.range.fromB, this.decorations, this.dynamicDecorationMap), S = Ft.build(this.view.state.doc, i.range.toB, f, this.decorations, this.dynamicDecorationMap);
        u = x.breakAtStart, p = x.openStart, g = S.openEnd;
        let C = this.compositionView(i);
        S.breakAtStart ? C.breakAfter = 1 : S.content.length && C.merge(C.length, C.length, S.content[0], !1, S.openStart, 0) && (C.breakAfter = S.content[0].breakAfter, S.content.shift()), x.content.length && C.merge(0, 0, x.content[x.content.length - 1], !0, 0, x.openEnd) && x.content.pop(), d = x.content.concat(C).concat(S.content);
      } else
        ({ content: d, breakAtStart: u, openStart: p, openEnd: g } = Ft.build(this.view.state.doc, a, f, this.decorations, this.dynamicDecorationMap));
      let { i: b, off: m } = o.findPos(c, 1), { i: w, off: v } = o.findPos(h, -1);
      xs(this, w, v, b, m, d, u, p, g);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(t) {
    this.editContextFormatting = this.editContextFormatting.map(t.changes);
    for (let e of t.transactions)
      for (let i of e.effects)
        i.is(Ks) && (this.editContextFormatting = i.value);
  }
  compositionView(t) {
    let e = new _(t.text.nodeValue);
    e.flags |= 8;
    for (let { deco: s } of t.marks)
      e = new et(s, [e], e.length);
    let i = new B();
    return i.append(e, 0), i;
  }
  fixCompositionDOM(t) {
    let e = (o, r) => {
      r.flags |= 8 | (r.children.some(
        (h) => h.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(r);
      let l = O.get(o);
      l && l != r && (l.dom = null), r.setDOM(o);
    }, i = this.childPos(t.range.fromB, 1), s = this.children[i.i];
    e(t.line, s);
    for (let o = t.marks.length - 1; o >= -1; o--)
      i = s.childPos(i.off, 1), s = s.children[i.i], e(o >= 0 ? t.marks[o].node : t.text, s);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, e = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, s = i == this.dom, o = !s && le(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(s || e || o))
      return;
    let r = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, h = this.moveToLine(this.domAtPos(l.anchor)), c = l.empty ? h : this.moveToLine(this.domAtPos(l.head));
    if (y.gecko && l.empty && !this.hasComposition && Jn(h)) {
      let f = document.createTextNode("");
      this.view.observer.ignore(() => h.node.insertBefore(f, h.node.childNodes[h.offset] || null)), h = c = new N(f, 0), r = !0;
    }
    let a = this.view.observer.selectionRange;
    (r || !a.focusNode || (!Vt(h.node, h.offset, a.anchorNode, a.anchorOffset) || !Vt(c.node, c.offset, a.focusNode, a.focusOffset)) && !this.suppressWidgetCursorChange(a, l)) && (this.view.observer.ignore(() => {
      y.android && y.chrome && this.dom.contains(a.focusNode) && so(a.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let f = zt(this.view.root);
      if (f) if (l.empty) {
        if (y.gecko) {
          let d = to(h.node, h.offset);
          if (d && d != 3) {
            let u = (d == 1 ? bs : ys)(h.node, h.offset);
            u && (h = new N(u.node, u.offset));
          }
        }
        f.collapse(h.node, h.offset), l.bidiLevel != null && f.caretBidiLevel !== void 0 && (f.caretBidiLevel = l.bidiLevel);
      } else if (f.extend) {
        f.collapse(h.node, h.offset);
        try {
          f.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let d = document.createRange();
        l.anchor > l.head && ([h, c] = [c, h]), d.setEnd(c.node, c.offset), d.setStart(h.node, h.offset), f.removeAllRanges(), f.addRange(d);
      }
      o && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(h, c)), this.impreciseAnchor = h.precise ? null : new N(a.anchorNode, a.anchorOffset), this.impreciseHead = c.precise ? null : new N(a.focusNode, a.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, e) {
    return this.hasComposition && e.empty && Vt(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == e.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, e = t.state.selection.main, i = zt(t.root), { anchorNode: s, anchorOffset: o } = t.observer.selectionRange;
    if (!i || !e.empty || !e.assoc || !i.modify)
      return;
    let r = B.find(this, e.head);
    if (!r)
      return;
    let l = r.posAtStart;
    if (e.head == l || e.head == l + r.length)
      return;
    let h = this.coordsAt(e.head, -1), c = this.coordsAt(e.head, 1);
    if (!h || !c || h.bottom > c.top)
      return;
    let a = this.domAtPos(e.head + e.assoc);
    i.collapse(a.node, a.offset), i.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let f = t.observer.selectionRange;
    t.docView.posFromDOM(f.anchorNode, f.anchorOffset) != e.from && i.collapse(s, o);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(t) {
    let e = this.dom, i;
    if (t.node != e)
      return t;
    for (let s = t.offset; !i && s < e.childNodes.length; s++) {
      let o = O.get(e.childNodes[s]);
      o instanceof B && (i = o.domAtPos(0));
    }
    for (let s = t.offset - 1; !i && s >= 0; s--) {
      let o = O.get(e.childNodes[s]);
      o instanceof B && (i = o.domAtPos(o.length));
    }
    return i ? new N(i.node, i.offset, !0) : t;
  }
  nearest(t) {
    for (let e = t; e; ) {
      let i = O.get(e);
      if (i && i.rootView == this)
        return i;
      e = e.parentNode;
    }
    return null;
  }
  posFromDOM(t, e) {
    let i = this.nearest(t);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(t, e) + i.posAtStart;
  }
  domAtPos(t) {
    let { i: e, off: i } = this.childCursor().findPos(t, -1);
    for (; e < this.children.length - 1; ) {
      let s = this.children[e];
      if (i < s.length || s instanceof B)
        break;
      e++, i = 0;
    }
    return this.children[e].domAtPos(i);
  }
  coordsAt(t, e) {
    let i = null, s = 0;
    for (let o = this.length, r = this.children.length - 1; r >= 0; r--) {
      let l = this.children[r], h = o - l.breakAfter, c = h - l.length;
      if (h < t)
        break;
      if (c <= t && (c < t || l.covers(-1)) && (h > t || l.covers(1)) && (!i || l instanceof B && !(i instanceof B && e >= 0)))
        i = l, s = c;
      else if (i && c == t && h == t && l instanceof Z && Math.abs(e) < 2) {
        if (l.deco.startSide < 0)
          break;
        r && (i = null);
      }
      o = c;
    }
    return i ? i.coordsAt(t - s, e) : null;
  }
  coordsForChar(t) {
    let { i: e, off: i } = this.childPos(t, 1), s = this.children[e];
    if (!(s instanceof B))
      return null;
    for (; s.children.length; ) {
      let { i: l, off: h } = s.childPos(i, 1);
      for (; ; l++) {
        if (l == s.children.length)
          return null;
        if ((s = s.children[l]).length)
          break;
      }
      i = h;
    }
    if (!(s instanceof _))
      return null;
    let o = bt(s.text, i);
    if (o == i)
      return null;
    let r = ut(s.dom, i, o).getClientRects();
    for (let l = 0; l < r.length; l++) {
      let h = r[l];
      if (l == r.length - 1 || h.top < h.bottom && h.left < h.right)
        return h;
    }
    return null;
  }
  measureVisibleLineHeights(t) {
    let e = [], { from: i, to: s } = t, o = this.view.contentDOM.clientWidth, r = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, h = this.view.textDirection == L.LTR;
    for (let c = 0, a = 0; a < this.children.length; a++) {
      let f = this.children[a], d = c + f.length;
      if (d > s)
        break;
      if (c >= i) {
        let u = f.dom.getBoundingClientRect();
        if (e.push(u.height), r) {
          let p = f.dom.lastChild, g = p ? Ct(p) : [];
          if (g.length) {
            let b = g[g.length - 1], m = h ? b.right - u.left : u.right - b.left;
            m > l && (l = m, this.minWidth = o, this.minWidthFrom = c, this.minWidthTo = d);
          }
        }
      }
      c = d + f.breakAfter;
    }
    return e;
  }
  textDirectionAt(t) {
    let { i: e } = this.childPos(t, 1);
    return getComputedStyle(this.children[e].dom).direction == "rtl" ? L.RTL : L.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof B) {
        let r = o.measureTextSize();
        if (r)
          return r;
      }
    let t = document.createElement("div"), e, i, s;
    return t.className = "cm-line", t.style.width = "99999px", t.style.position = "absolute", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let o = Ct(t.firstChild)[0];
      e = t.getBoundingClientRect().height, i = o ? o.width / 27 : 7, s = o ? o.height : e, t.remove();
    }), { lineHeight: e, charWidth: i, textHeight: s };
  }
  childCursor(t = this.length) {
    let e = this.children.length;
    return e && (t -= this.children[--e].length), new ws(this.children, t, e);
  }
  computeBlockGapDeco() {
    let t = [], e = this.view.viewState;
    for (let i = 0, s = 0; ; s++) {
      let o = s == e.viewports.length ? null : e.viewports[s], r = o ? o.from - 1 : this.length;
      if (r > i) {
        let l = (e.lineBlockAt(r).bottom - e.lineBlockAt(i).top) / this.view.scaleY;
        t.push(R.replace({
          widget: new ze(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, r));
      }
      if (!o)
        break;
      i = o.to + 1;
    }
    return R.set(t);
  }
  updateDeco() {
    let t = 1, e = this.view.state.facet(It).map((o) => (this.dynamicDecorationMap[t++] = typeof o == "function") ? o(this.view) : o), i = !1, s = this.view.state.facet(js).map((o, r) => {
      let l = typeof o == "function";
      return l && (i = !0), l ? o(this.view) : o;
    });
    for (s.length && (this.dynamicDecorationMap[t++] = i, e.push(V.join(s))), this.decorations = [
      this.editContextFormatting,
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    return this.decorations;
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = c.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let c of this.view.state.facet(Is))
      try {
        if (c(this.view, t.range, t))
          return !0;
      } catch (a) {
        U(this.view.state, a, "scroll handler");
      }
    let { range: e } = t, i = this.coordsAt(e.head, e.empty ? e.assoc : e.head > e.anchor ? -1 : 1), s;
    if (!i)
      return;
    !e.empty && (s = this.coordsAt(e.anchor, e.anchor > e.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, s.left),
      top: Math.min(i.top, s.top),
      right: Math.max(i.right, s.right),
      bottom: Math.max(i.bottom, s.bottom)
    });
    let o = Xs(this.view), r = {
      left: i.left - o.left,
      top: i.top - o.top,
      right: i.right + o.right,
      bottom: i.bottom + o.bottom
    }, { offsetWidth: l, offsetHeight: h } = this.view.scrollDOM;
    Ln(this.view.scrollDOM, r, e.head < e.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, l), -l), Math.max(Math.min(t.yMargin, h), -h), this.view.textDirection == L.LTR);
  }
}
function Jn(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
function Gs(n, t) {
  let e = n.observer.selectionRange;
  if (!e.focusNode)
    return null;
  let i = bs(e.focusNode, e.focusOffset), s = ys(e.focusNode, e.focusOffset), o = i || s;
  if (s && i && s.node != i.node) {
    let l = O.get(s.node);
    if (!l || l instanceof _ && l.text != s.node.nodeValue)
      o = s;
    else if (n.docView.lastCompositionAfterCursor) {
      let h = O.get(i.node);
      !h || h instanceof _ && h.text != i.node.nodeValue || (o = s);
    }
  }
  if (n.docView.lastCompositionAfterCursor = o != i, !o)
    return null;
  let r = t - o.offset;
  return { from: r, to: r + o.node.nodeValue.length, node: o.node };
}
function Zn(n, t, e) {
  let i = Gs(n, e);
  if (!i)
    return null;
  let { node: s, from: o, to: r } = i, l = s.nodeValue;
  if (/[\n\r]/.test(l) || n.state.doc.sliceString(i.from, i.to) != l)
    return null;
  let h = t.invertedDesc, c = new q(h.mapPos(o), h.mapPos(r), o, r), a = [];
  for (let f = s.parentNode; ; f = f.parentNode) {
    let d = O.get(f);
    if (d instanceof et)
      a.push({ node: f, deco: d.mark });
    else {
      if (d instanceof B || f.nodeName == "DIV" && f.parentNode == n.contentDOM)
        return { range: c, text: s, marks: a, line: f };
      if (f != n.contentDOM)
        a.push({ node: f, deco: new jt({
          inclusive: !0,
          attributes: zn(f),
          tagName: f.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function to(n, t) {
  return n.nodeType != 1 ? 0 : (t && n.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < n.childNodes.length && n.childNodes[t].contentEditable == "false" ? 2 : 0);
}
let eo = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    We(t, e, this.changes);
  }
  comparePoint(t, e) {
    We(t, e, this.changes);
  }
};
function io(n, t, e) {
  let i = new eo();
  return V.compare(n, t, e, i), i.changes;
}
function so(n, t) {
  for (let e = n; e && e != t; e = e.assignedSlot || e.parentNode)
    if (e.nodeType == 1 && e.contentEditable == "false")
      return !0;
  return !1;
}
function no(n, t) {
  let e = !1;
  return t && n.iterChangedRanges((i, s) => {
    i < t.to && s > t.from && (e = !0);
  }), e;
}
function oo(n, t, e = 1) {
  let i = n.charCategorizer(t), s = n.doc.lineAt(t), o = t - s.from;
  if (s.length == 0)
    return k.cursor(t);
  o == 0 ? e = 1 : o == s.length && (e = -1);
  let r = o, l = o;
  e < 0 ? r = bt(s.text, o, !1) : l = bt(s.text, o);
  let h = i(s.text.slice(r, l));
  for (; r > 0; ) {
    let c = bt(s.text, r, !1);
    if (i(s.text.slice(c, r)) != h)
      break;
    r = c;
  }
  for (; l < s.length; ) {
    let c = bt(s.text, l);
    if (i(s.text.slice(l, c)) != h)
      break;
    l = c;
  }
  return k.range(r + s.from, l + s.from);
}
function ro(n, t) {
  return t.left > n ? t.left - n : Math.max(0, n - t.right);
}
function lo(n, t) {
  return t.top > n ? t.top - n : Math.max(0, n - t.bottom);
}
function Me(n, t) {
  return n.top < t.bottom - 1 && n.bottom > t.top + 1;
}
function Mi(n, t) {
  return t < n.top ? { top: t, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function ki(n, t) {
  return t > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: t } : n;
}
function Ye(n, t, e) {
  let i, s, o, r, l = !1, h, c, a, f;
  for (let p = n.firstChild; p; p = p.nextSibling) {
    let g = Ct(p);
    for (let b = 0; b < g.length; b++) {
      let m = g[b];
      s && Me(s, m) && (m = Mi(ki(m, s.bottom), s.top));
      let w = ro(t, m), v = lo(e, m);
      if (w == 0 && v == 0)
        return p.nodeType == 3 ? Ai(p, t, e) : Ye(p, t, e);
      if (!i || r > v || r == v && o > w) {
        i = p, s = m, o = w, r = v;
        let x = v ? e < m.top ? -1 : 1 : w ? t < m.left ? -1 : 1 : 0;
        l = !x || (x > 0 ? b < g.length - 1 : b > 0);
      }
      w == 0 ? e > m.bottom && (!a || a.bottom < m.bottom) ? (h = p, a = m) : e < m.top && (!f || f.top > m.top) && (c = p, f = m) : a && Me(a, m) ? a = ki(a, m.bottom) : f && Me(f, m) && (f = Mi(f, m.top));
    }
  }
  if (a && a.bottom >= e ? (i = h, s = a) : f && f.top <= e && (i = c, s = f), !i)
    return { node: n, offset: 0 };
  let d = Math.max(s.left, Math.min(s.right, t));
  if (i.nodeType == 3)
    return Ai(i, d, e);
  if (l && i.contentEditable != "false")
    return Ye(i, d, e);
  let u = Array.prototype.indexOf.call(n.childNodes, i) + (t >= (s.left + s.right) / 2 ? 1 : 0);
  return { node: n, offset: u };
}
function Ai(n, t, e) {
  let i = n.nodeValue.length, s = -1, o = 1e9, r = 0;
  for (let l = 0; l < i; l++) {
    let h = ut(n, l, l + 1).getClientRects();
    for (let c = 0; c < h.length; c++) {
      let a = h[c];
      if (a.top == a.bottom)
        continue;
      r || (r = t - a.left);
      let f = (a.top > e ? a.top - e : e - a.bottom) - 1;
      if (a.left - 1 <= t && a.right + 1 >= t && f < o) {
        let d = t >= (a.left + a.right) / 2, u = d;
        if ((y.chrome || y.gecko) && ut(n, l).getBoundingClientRect().left == a.right && (u = !d), f <= 0)
          return { node: n, offset: l + (u ? 1 : 0) };
        s = l + (u ? 1 : 0), o = f;
      }
    }
  }
  return { node: n, offset: s > -1 ? s : r > 0 ? n.nodeValue.length : 0 };
}
function $s(n, t, e, i = -1) {
  var s, o;
  let r = n.contentDOM.getBoundingClientRect(), l = r.top + n.viewState.paddingTop, h, { docHeight: c } = n.viewState, { x: a, y: f } = t, d = f - l;
  if (d < 0)
    return 0;
  if (d > c)
    return n.state.doc.length;
  for (let x = n.viewState.heightOracle.textHeight / 2, S = !1; h = n.elementAtHeight(d), h.type != F.Text; )
    for (; d = i > 0 ? h.bottom + x : h.top - x, !(d >= 0 && d <= c); ) {
      if (S)
        return e ? null : 0;
      S = !0, i = -i;
    }
  f = l + d;
  let u = h.from;
  if (u < n.viewport.from)
    return n.viewport.from == 0 ? 0 : e ? null : Di(n, r, h, a, f);
  if (u > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : e ? null : Di(n, r, h, a, f);
  let p = n.dom.ownerDocument, g = n.root.elementFromPoint ? n.root : p, b = g.elementFromPoint(a, f);
  b && !n.contentDOM.contains(b) && (b = null), b || (a = Math.max(r.left + 1, Math.min(r.right - 1, a)), b = g.elementFromPoint(a, f), b && !n.contentDOM.contains(b) && (b = null));
  let m, w = -1;
  if (b && ((s = n.docView.nearest(b)) === null || s === void 0 ? void 0 : s.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let x = p.caretPositionFromPoint(a, f);
      x && ({ offsetNode: m, offset: w } = x);
    } else if (p.caretRangeFromPoint) {
      let x = p.caretRangeFromPoint(a, f);
      x && ({ startContainer: m, startOffset: w } = x, (!n.contentDOM.contains(m) || y.safari && ho(m, w, a) || y.chrome && ao(m, w, a)) && (m = void 0));
    }
  }
  if (!m || !n.docView.dom.contains(m)) {
    let x = B.find(n.docView, u);
    if (!x)
      return d > h.top + h.height / 2 ? h.to : h.from;
    ({ node: m, offset: w } = Ye(x.dom, a, f));
  }
  let v = n.docView.nearest(m);
  if (!v)
    return null;
  if (v.isWidget && ((o = v.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let x = v.dom.getBoundingClientRect();
    return t.y < x.top || t.y <= x.bottom && t.x <= (x.left + x.right) / 2 ? v.posAtStart : v.posAtEnd;
  } else
    return v.localPosFromDOM(m, w) + v.posAtStart;
}
function Di(n, t, e, i, s) {
  let o = Math.round((i - t.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && e.height > n.defaultLineHeight * 1.5) {
    let l = n.viewState.heightOracle.textHeight, h = Math.floor((s - e.top - (n.defaultLineHeight - l) * 0.5) / l);
    o += h * n.viewState.heightOracle.lineLength;
  }
  let r = n.state.sliceDoc(e.from, e.to);
  return e.from + Le(r, o, n.state.tabSize);
}
function ho(n, t, e) {
  let i;
  if (n.nodeType != 3 || t != (i = n.nodeValue.length))
    return !1;
  for (let s = n.nextSibling; s; s = s.nextSibling)
    if (s.nodeType != 1 || s.nodeName != "BR")
      return !1;
  return ut(n, i - 1, i).getBoundingClientRect().left > e;
}
function ao(n, t, e) {
  if (t != 0)
    return !1;
  for (let s = n; ; ) {
    let o = s.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != s)
      return !1;
    if (o.classList.contains("cm-line"))
      break;
    s = o;
  }
  let i = n.nodeType == 1 ? n.getBoundingClientRect() : ut(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return e - i.left > 5;
}
function _e(n, t) {
  let e = n.lineBlockAt(t);
  if (Array.isArray(e.type)) {
    for (let i of e.type)
      if (i.to > t || i.to == t && (i.to == e.to || i.type == F.Text))
        return i;
  }
  return e;
}
function co(n, t, e, i) {
  let s = _e(n, t.head), o = !i || s.type != F.Text || !(n.lineWrapping || s.widgetLineBreaks) ? null : n.coordsAtPos(t.assoc < 0 && t.head > s.from ? t.head - 1 : t.head);
  if (o) {
    let r = n.dom.getBoundingClientRect(), l = n.textDirectionAt(s.from), h = n.posAtCoords({
      x: e == (l == L.LTR) ? r.right - 1 : r.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (h != null)
      return k.cursor(h, e ? -1 : 1);
  }
  return k.cursor(e ? s.to : s.from, e ? -1 : 1);
}
function Oi(n, t, e, i) {
  let s = n.state.doc.lineAt(t.head), o = n.bidiSpans(s), r = n.textDirectionAt(s.from);
  for (let l = t, h = null; ; ) {
    let c = $n(s, o, r, l, e), a = Ls;
    if (!c) {
      if (s.number == (e ? n.state.doc.lines : 1))
        return l;
      a = `
`, s = n.state.doc.line(s.number + (e ? 1 : -1)), o = n.bidiSpans(s), c = n.visualLineSide(s, !e);
    }
    if (h) {
      if (!h(a))
        return l;
    } else {
      if (!i)
        return c;
      h = i(a);
    }
    l = c;
  }
}
function fo(n, t, e) {
  let i = n.state.charCategorizer(t), s = i(e);
  return (o) => {
    let r = i(o);
    return s == kn.Space && (s = r), s == r;
  };
}
function uo(n, t, e, i) {
  let s = t.head, o = e ? 1 : -1;
  if (s == (e ? n.state.doc.length : 0))
    return k.cursor(s, t.assoc);
  let r = t.goalColumn, l, h = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(s, t.assoc || -1), a = n.documentTop;
  if (c)
    r == null && (r = c.left - h.left), l = o < 0 ? c.top : c.bottom;
  else {
    let u = n.viewState.lineBlockAt(s);
    r == null && (r = Math.min(h.right - h.left, n.defaultCharacterWidth * (s - u.from))), l = (o < 0 ? u.top : u.bottom) + a;
  }
  let f = h.left + r, d = i ?? n.viewState.heightOracle.textHeight >> 1;
  for (let u = 0; ; u += 10) {
    let p = l + (d + u) * o, g = $s(n, { x: f, y: p }, !1, o);
    if (p < h.top || p > h.bottom || (o < 0 ? g < s : g > s)) {
      let b = n.docView.coordsForChar(g), m = !b || p < b.top ? -1 : 1;
      return k.cursor(g, m, void 0, r);
    }
  }
}
function he(n, t, e) {
  for (; ; ) {
    let i = 0;
    for (let s of n)
      s.between(t - 1, t + 1, (o, r, l) => {
        if (t > o && t < r) {
          let h = i || e || (t - o < r - t ? -1 : 1);
          t = h < 0 ? o : r, i = h;
        }
      });
    if (!i)
      return t;
  }
}
function ke(n, t, e) {
  let i = he(n.state.facet(ai).map((s) => s(n)), e.from, t.head > e.from ? -1 : 1);
  return i == e.from ? e : k.cursor(i, i < e.from ? 1 : -1);
}
const Bt = "ï¿¿";
class po {
  constructor(t, e) {
    this.points = t, this.text = "", this.lineSeparator = e.facet(Nt.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += Bt;
  }
  readRange(t, e) {
    if (!t)
      return this;
    let i = t.parentNode;
    for (let s = t; ; ) {
      this.findPointBefore(i, s);
      let o = this.text.length;
      this.readNode(s);
      let r = s.nextSibling;
      if (r == e)
        break;
      let l = O.get(s), h = O.get(r);
      (l && h ? l.breakAfter : (l ? l.breakAfter : ue(s)) || ue(r) && (s.nodeName != "BR" || s.cmIgnore) && this.text.length > o) && this.lineBreak(), s = r;
    }
    return this.findPointBefore(i, e), this;
  }
  readTextNode(t) {
    let e = t.nodeValue;
    for (let i of this.points)
      i.node == t && (i.pos = this.text.length + Math.min(i.offset, e.length));
    for (let i = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, r = 1, l;
      if (this.lineSeparator ? (o = e.indexOf(this.lineSeparator, i), r = this.lineSeparator.length) : (l = s.exec(e)) && (o = l.index, r = l[0].length), this.append(e.slice(i, o < 0 ? e.length : o)), o < 0)
        break;
      if (this.lineBreak(), r > 1)
        for (let h of this.points)
          h.node == t && h.pos > this.text.length && (h.pos -= r - 1);
      i = o + r;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let e = O.get(t), i = e && e.overrideDOMText;
    if (i != null) {
      this.findPointInside(t, i.length);
      for (let s = i.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, e) {
    for (let i of this.points)
      i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length);
  }
  findPointInside(t, e) {
    for (let i of this.points)
      (t.nodeType == 3 ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (go(t, i.node, i.offset) ? e : 0));
  }
}
function go(n, t, e) {
  for (; ; ) {
    if (!t || e < tt(t))
      return !1;
    if (t == n)
      return !0;
    e = dt(t) + 1, t = t.parentNode;
  }
}
class Ti {
  constructor(t, e) {
    this.node = t, this.offset = e, this.pos = -1;
  }
}
class mo {
  constructor(t, e, i, s) {
    this.typeOver = s, this.bounds = null, this.text = "", this.domChanged = e > -1;
    let { impreciseHead: o, impreciseAnchor: r } = t.docView;
    if (t.state.readOnly && e > -1)
      this.newSel = null;
    else if (e > -1 && (this.bounds = t.docView.domBoundsAround(e, i, 0))) {
      let l = o || r ? [] : wo(t), h = new po(l, t.state);
      h.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = h.text, this.newSel = xo(l, this.bounds.from);
    } else {
      let l = t.observer.selectionRange, h = o && o.node == l.focusNode && o.offset == l.focusOffset || !Be(t.contentDOM, l.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(l.focusNode, l.focusOffset), c = r && r.node == l.anchorNode && r.offset == l.anchorOffset || !Be(t.contentDOM, l.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(l.anchorNode, l.anchorOffset), a = t.viewport;
      if ((y.ios || y.chrome) && t.state.selection.main.empty && h != c && (a.from > 0 || a.to < t.state.doc.length)) {
        let f = Math.min(h, c), d = Math.max(h, c), u = a.from - f, p = a.to - d;
        (u == 0 || u == 1 || f == 0) && (p == 0 || p == -1 || d == t.state.doc.length) && (h = 0, c = t.state.doc.length);
      }
      this.newSel = k.single(c, h);
    }
  }
}
function Us(n, t) {
  let e, { newSel: i } = t, s = n.state.selection.main, o = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: r, to: l } = t.bounds, h = s.from, c = null;
    (o === 8 || y.android && t.text.length < l - r) && (h = s.to, c = "end");
    let a = yo(n.state.doc.sliceString(r, l, Bt), t.text, h - r, c);
    a && (y.chrome && o == 13 && a.toB == a.from + 2 && t.text.slice(a.from, a.toB) == Bt + Bt && a.toB--, e = {
      from: r + a.from,
      to: r + a.toA,
      insert: Y.of(t.text.slice(a.from, a.toB).split(Bt))
    });
  } else i && (!n.hasFocus && n.state.facet(nt) || i.main.eq(s)) && (i = null);
  if (!e && !i)
    return !1;
  if (!e && t.typeOver && !s.empty && i && i.main.empty ? e = { from: s.from, to: s.to, insert: n.state.doc.slice(s.from, s.to) } : e && e.from >= s.from && e.to <= s.to && (e.from != s.from || e.to != s.to) && s.to - s.from - (e.to - e.from) <= 4 ? e = {
    from: s.from,
    to: s.to,
    insert: n.state.doc.slice(s.from, e.from).append(e.insert).append(n.state.doc.slice(e.to, s.to))
  } : (y.mac || y.android) && e && e.from == e.to && e.from == s.head - 1 && /^\. ?$/.test(e.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (i && e.insert.length == 2 && (i = k.single(i.main.anchor - 1, i.main.head - 1)), e = { from: s.from, to: s.to, insert: Y.of([" "]) }) : y.chrome && e && e.from == e.to && e.from == s.head && e.insert.toString() == `
 ` && n.lineWrapping && (i && (i = k.single(i.main.anchor - 1, i.main.head - 1)), e = { from: s.from, to: s.to, insert: Y.of([" "]) }), e)
    return ci(n, e, i, o);
  if (i && !i.main.eq(s)) {
    let r = !1, l = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (r = !0), l = n.inputState.lastSelectionOrigin), n.dispatch({ selection: i, scrollIntoView: r, userEvent: l }), !0;
  } else
    return !1;
}
function ci(n, t, e, i = -1) {
  if (y.ios && n.inputState.flushIOSKey(t))
    return !0;
  let s = n.state.selection.main;
  if (y.android && (t.to == s.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (t.from == s.from || t.from == s.from - 1 && n.state.sliceDoc(t.from, s.from) == " ") && t.insert.length == 1 && t.insert.lines == 2 && xt(n.contentDOM, "Enter", 13) || (t.from == s.from - 1 && t.to == s.to && t.insert.length == 0 || i == 8 && t.insert.length < t.to - t.from && t.to > s.head) && xt(n.contentDOM, "Backspace", 8) || t.from == s.from && t.to == s.to + 1 && t.insert.length == 0 && xt(n.contentDOM, "Delete", 46)))
    return !0;
  let o = t.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let r, l = () => r || (r = bo(n, t, e));
  return n.state.facet(Vs).some((h) => h(n, t.from, t.to, o, l)) || n.dispatch(l()), !0;
}
function bo(n, t, e) {
  let i, s = n.state, o = s.selection.main;
  if (t.from >= o.from && t.to <= o.to && t.to - t.from >= (o.to - o.from) / 3 && (!e || e.main.empty && e.main.from == t.from + t.insert.length) && n.inputState.composing < 0) {
    let l = o.from < t.from ? s.sliceDoc(o.from, t.from) : "", h = o.to > t.to ? s.sliceDoc(t.to, o.to) : "";
    i = s.replaceSelection(n.state.toText(l + t.insert.sliceString(0, void 0, n.state.lineBreak) + h));
  } else {
    let l = s.changes(t), h = e && e.main.to <= l.newLength ? e.main : void 0;
    if (s.selection.ranges.length > 1 && n.inputState.composing >= 0 && t.to <= o.to && t.to >= o.to - 10) {
      let c = n.state.sliceDoc(t.from, t.to), a, f = e && Gs(n, e.main.head);
      if (f) {
        let p = t.insert.length - (t.to - t.from);
        a = { from: f.from, to: f.to - p };
      } else
        a = n.state.doc.lineAt(o.head);
      let d = o.to - t.to, u = o.to - o.from;
      i = s.changeByRange((p) => {
        if (p.from == o.from && p.to == o.to)
          return { changes: l, range: h || p.map(l) };
        let g = p.to - d, b = g - c.length;
        if (p.to - p.from != u || n.state.sliceDoc(b, g) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= a.from && p.from <= a.to)
          return { range: p };
        let m = s.changes({ from: b, to: g, insert: t.insert }), w = p.to - o.to;
        return {
          changes: m,
          range: h ? k.range(Math.max(0, h.anchor + w), Math.max(0, h.head + w)) : p.map(m)
        };
      });
    } else
      i = {
        changes: l,
        selection: h && s.selection.replaceRange(h)
      };
  }
  let r = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, r += ".compose", n.inputState.compositionFirstChange && (r += ".start", n.inputState.compositionFirstChange = !1)), s.update(i, { userEvent: r, scrollIntoView: !0 });
}
function yo(n, t, e, i) {
  let s = Math.min(n.length, t.length), o = 0;
  for (; o < s && n.charCodeAt(o) == t.charCodeAt(o); )
    o++;
  if (o == s && n.length == t.length)
    return null;
  let r = n.length, l = t.length;
  for (; r > 0 && l > 0 && n.charCodeAt(r - 1) == t.charCodeAt(l - 1); )
    r--, l--;
  if (i == "end") {
    let h = Math.max(0, o - Math.min(r, l));
    e -= r + h - o;
  }
  if (r < o && n.length < t.length) {
    let h = e <= o && e >= r ? o - e : 0;
    o -= h, l = o + (l - r), r = o;
  } else if (l < o) {
    let h = e <= o && e >= l ? o - e : 0;
    o -= h, r = o + (r - l), l = o;
  }
  return { from: o, toA: r, toB: l };
}
function wo(n) {
  let t = [];
  if (n.root.activeElement != n.contentDOM)
    return t;
  let { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: o } = n.observer.selectionRange;
  return e && (t.push(new Ti(e, i)), (s != e || o != i) && t.push(new Ti(s, o))), t;
}
function xo(n, t) {
  if (n.length == 0)
    return null;
  let e = n[0].pos, i = n.length == 2 ? n[1].pos : e;
  return e > -1 && i > -1 ? k.single(e + t, i + t) : null;
}
class vo {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, y.safari && t.contentDOM.addEventListener("input", () => null), y.gecko && Vo(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !To(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || this.runHandlers(t.type, t);
  }
  runHandlers(t, e) {
    let i = this.handlers[t];
    if (i) {
      for (let s of i.observers)
        s(this.view, e);
      for (let s of i.handlers) {
        if (e.defaultPrevented)
          break;
        if (s(this.view, e)) {
          e.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let e = So(t), i = this.handlers, s = this.view.contentDOM;
    for (let o in e)
      if (o != "scroll") {
        let r = !e[o].handlers.length, l = i[o];
        l && r != !l.handlers.length && (s.removeEventListener(o, this.handleEvent), l = null), l || s.addEventListener(o, this.handleEvent, { passive: r });
      }
    for (let o in i)
      o != "scroll" && !e[o] && s.removeEventListener(o, this.handleEvent);
    this.handlers = e;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && t.keyCode != 27 && Js.indexOf(t.keyCode) < 0 && (this.tabFocusMode = -1), y.android && y.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let e;
    return y.ios && !t.synthetic && !t.altKey && !t.metaKey && ((e = Qs.find((i) => i.keyCode == t.keyCode)) && !t.ctrlKey || Co.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = e || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let e = this.pendingIOSKey;
    return !e || e.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, xt(this.view.contentDOM, e.key, e.keyCode, e instanceof KeyboardEvent ? e : void 0));
  }
  ignoreDuringComposition(t) {
    return /^key/.test(t.type) ? this.composing > 0 ? !0 : y.safari && !y.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.view.observer.update(t), this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function Ri(n, t) {
  return (e, i) => {
    try {
      return t.call(n, i, e);
    } catch (s) {
      U(e.state, s);
    }
  };
}
function So(n) {
  let t = /* @__PURE__ */ Object.create(null);
  function e(i) {
    return t[i] || (t[i] = { observers: [], handlers: [] });
  }
  for (let i of n) {
    let s = i.spec;
    if (s && s.domEventHandlers)
      for (let o in s.domEventHandlers) {
        let r = s.domEventHandlers[o];
        r && e(o).handlers.push(Ri(i.value, r));
      }
    if (s && s.domEventObservers)
      for (let o in s.domEventObservers) {
        let r = s.domEventObservers[o];
        r && e(o).observers.push(Ri(i.value, r));
      }
  }
  for (let i in X)
    e(i).handlers.push(X[i]);
  for (let i in j)
    e(i).observers.push(j[i]);
  return t;
}
const Qs = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], Co = "dthko", Js = [16, 17, 18, 20, 91, 92, 224, 225], Jt = 6;
function Zt(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function Mo(n, t) {
  return Math.max(Math.abs(n.clientX - t.clientX), Math.abs(n.clientY - t.clientY));
}
class ko {
  constructor(t, e, i, s) {
    this.view = t, this.startEvent = e, this.style = i, this.mustSelect = s, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e, this.scrollParents = Bn(t.contentDOM), this.atoms = t.state.facet(ai).map((r) => r(t));
    let o = t.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e.shiftKey, this.multiple = t.state.facet(Nt.allowMultipleSelections) && Ao(t, e), this.dragging = Oo(t, e) && en(e) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && Mo(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let e = 0, i = 0, s = 0, o = 0, r = this.view.win.innerWidth, l = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: s, right: r } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o, bottom: l } = this.scrollParents.y.getBoundingClientRect());
    let h = Xs(this.view);
    t.clientX - h.left <= s + Jt ? e = -Zt(s - t.clientX) : t.clientX + h.right >= r - Jt && (e = Zt(t.clientX - r)), t.clientY - h.top <= o + Jt ? i = -Zt(o - t.clientY) : t.clientY + h.bottom >= l - Jt && (i = Zt(t.clientY - l)), this.setScrollSpeed(e, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, e) {
    this.scrollSpeed = { x: t, y: e }, t || e ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t, y: e } = this.scrollSpeed;
    t && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t, t = 0), e && this.scrollParents.y && (this.scrollParents.y.scrollTop += e, e = 0), (t || e) && this.view.win.scrollBy(t, e), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(t) {
    let e = null;
    for (let i = 0; i < t.ranges.length; i++) {
      let s = t.ranges[i], o = null;
      if (s.empty) {
        let r = he(this.atoms, s.from, 0);
        r != s.from && (o = k.cursor(r, -1));
      } else {
        let r = he(this.atoms, s.from, -1), l = he(this.atoms, s.to, 1);
        (r != s.from || l != s.to) && (o = k.range(s.from == s.anchor ? r : l, s.from == s.head ? r : l));
      }
      o && (e || (e = t.ranges.slice()), e[i] = o);
    }
    return e ? k.create(e, t.mainIndex) : t;
  }
  select(t) {
    let { view: e } = this, i = this.skipAtoms(this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !i.eq(e.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    t.transactions.some((e) => e.isUserEvent("input.type")) ? this.destroy() : this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function Ao(n, t) {
  let e = n.state.facet(Bs);
  return e.length ? e[0](t) : y.mac ? t.metaKey : t.ctrlKey;
}
function Do(n, t) {
  let e = n.state.facet(Ps);
  return e.length ? e[0](t) : y.mac ? !t.altKey : !t.ctrlKey;
}
function Oo(n, t) {
  let { main: e } = n.state.selection;
  if (e.empty)
    return !1;
  let i = zt(n.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let s = i.getRangeAt(0).getClientRects();
  for (let o = 0; o < s.length; o++) {
    let r = s[o];
    if (r.left <= t.clientX && r.right >= t.clientX && r.top <= t.clientY && r.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
function To(n, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let e = t.target, i; e != n.contentDOM; e = e.parentNode)
    if (!e || e.nodeType == 11 || (i = O.get(e)) && i.ignoreEvent(t))
      return !1;
  return !0;
}
const X = /* @__PURE__ */ Object.create(null), j = /* @__PURE__ */ Object.create(null), Zs = y.ie && y.ie_version < 15 || y.ios && y.webkit_version < 604;
function Ro(n) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let e = t.appendChild(document.createElement("textarea"));
  e.style.cssText = "position: fixed; left: -10000px; top: 10px", e.focus(), setTimeout(() => {
    n.focus(), e.remove(), tn(n, e.value);
  }, 50);
}
function xe(n, t, e) {
  for (let i of n.facet(t))
    e = i(e, n);
  return e;
}
function tn(n, t) {
  t = xe(n.state, ri, t);
  let { state: e } = n, i, s = 1, o = e.toText(t), r = o.lines == e.selection.ranges.length;
  if (Xe != null && e.selection.ranges.every((h) => h.empty) && Xe == o.toString()) {
    let h = -1;
    i = e.changeByRange((c) => {
      let a = e.doc.lineAt(c.from);
      if (a.from == h)
        return { range: c };
      h = a.from;
      let f = e.toText((r ? o.line(s++).text : t) + e.lineBreak);
      return {
        changes: { from: a.from, insert: f },
        range: k.cursor(c.from + f.length)
      };
    });
  } else r ? i = e.changeByRange((h) => {
    let c = o.line(s++);
    return {
      changes: { from: h.from, to: h.to, insert: c.text },
      range: k.cursor(h.from + c.length)
    };
  }) : i = e.replaceSelection(o);
  n.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
j.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
X.keydown = (n, t) => (n.inputState.setSelectionOrigin("select"), t.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
j.touchstart = (n, t) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
j.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
X.mousedown = (n, t) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let e = null;
  for (let i of n.state.facet(Hs))
    if (e = i(n, t), e)
      break;
  if (!e && t.button == 0 && (e = Bo(n, t)), e) {
    let i = !n.hasFocus;
    n.inputState.startMouseSelection(new ko(n, t, e, i)), i && n.observer.ignore(() => {
      ps(n.contentDOM);
      let o = n.root.activeElement;
      o && !o.contains(n.contentDOM) && o.blur();
    });
    let s = n.inputState.mouseSelection;
    if (s)
      return s.start(t), s.dragging === !1;
  }
  return !1;
};
function Ei(n, t, e, i) {
  if (i == 1)
    return k.cursor(t, e);
  if (i == 2)
    return oo(n.state, t, e);
  {
    let s = B.find(n.docView, t), o = n.state.doc.lineAt(s ? s.posAtEnd : t), r = s ? s.posAtStart : o.from, l = s ? s.posAtEnd : o.to;
    return l < n.state.doc.length && l == o.to && l++, k.range(r, l);
  }
}
let Li = (n, t, e) => t >= e.top && t <= e.bottom && n >= e.left && n <= e.right;
function Eo(n, t, e, i) {
  let s = B.find(n.docView, t);
  if (!s)
    return 1;
  let o = t - s.posAtStart;
  if (o == 0)
    return 1;
  if (o == s.length)
    return -1;
  let r = s.coordsAt(o, -1);
  if (r && Li(e, i, r))
    return -1;
  let l = s.coordsAt(o, 1);
  return l && Li(e, i, l) ? 1 : r && r.bottom >= i ? -1 : 1;
}
function Bi(n, t) {
  let e = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: e, bias: Eo(n, e, t.clientX, t.clientY) };
}
const Lo = y.ie && y.ie_version <= 11;
let Pi = null, Hi = 0, Ni = 0;
function en(n) {
  if (!Lo)
    return n.detail;
  let t = Pi, e = Ni;
  return Pi = n, Ni = Date.now(), Hi = !t || e > Date.now() - 400 && Math.abs(t.clientX - n.clientX) < 2 && Math.abs(t.clientY - n.clientY) < 2 ? (Hi + 1) % 3 : 1;
}
function Bo(n, t) {
  let e = Bi(n, t), i = en(t), s = n.state.selection;
  return {
    update(o) {
      o.docChanged && (e.pos = o.changes.mapPos(e.pos), s = s.map(o.changes));
    },
    get(o, r, l) {
      let h = Bi(n, o), c, a = Ei(n, h.pos, h.bias, i);
      if (e.pos != h.pos && !r) {
        let f = Ei(n, e.pos, e.bias, i), d = Math.min(f.from, a.from), u = Math.max(f.to, a.to);
        a = d < a.from ? k.range(d, u) : k.range(u, d);
      }
      return r ? s.replaceRange(s.main.extend(a.from, a.to)) : l && i == 1 && s.ranges.length > 1 && (c = Po(s, h.pos)) ? c : l ? s.addRange(a) : k.create([a]);
    }
  };
}
function Po(n, t) {
  for (let e = 0; e < n.ranges.length; e++) {
    let { from: i, to: s } = n.ranges[e];
    if (i <= t && s >= t)
      return k.create(n.ranges.slice(0, e).concat(n.ranges.slice(e + 1)), n.mainIndex == e ? 0 : n.mainIndex - (n.mainIndex > e ? 1 : 0));
  }
  return null;
}
X.dragstart = (n, t) => {
  let { selection: { main: e } } = n.state;
  if (t.target.draggable) {
    let s = n.docView.nearest(t.target);
    if (s && s.isWidget) {
      let o = s.posAtStart, r = o + s.length;
      (o >= e.to || r <= e.from) && (e = k.range(o, r));
    }
  }
  let { inputState: i } = n;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = e, t.dataTransfer && (t.dataTransfer.setData("Text", xe(n.state, li, n.state.sliceDoc(e.from, e.to))), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
X.dragend = (n) => (n.inputState.draggedContent = null, !1);
function Vi(n, t, e, i) {
  if (e = xe(n.state, ri, e), !e)
    return;
  let s = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: o } = n.inputState, r = i && o && Do(n, t) ? { from: o.from, to: o.to } : null, l = { from: s, insert: e }, h = n.state.changes(r ? [r, l] : l);
  n.focus(), n.dispatch({
    changes: h,
    selection: { anchor: h.mapPos(s, -1), head: h.mapPos(s, 1) },
    userEvent: r ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
X.drop = (n, t) => {
  if (!t.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let e = t.dataTransfer.files;
  if (e && e.length) {
    let i = Array(e.length), s = 0, o = () => {
      ++s == e.length && Vi(n, t, i.filter((r) => r != null).join(n.state.lineBreak), !1);
    };
    for (let r = 0; r < e.length; r++) {
      let l = new FileReader();
      l.onerror = o, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (i[r] = l.result), o();
      }, l.readAsText(e[r]);
    }
    return !0;
  } else {
    let i = t.dataTransfer.getData("Text");
    if (i)
      return Vi(n, t, i, !0), !0;
  }
  return !1;
};
X.paste = (n, t) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let e = Zs ? null : t.clipboardData;
  return e ? (tn(n, e.getData("text/plain") || e.getData("text/uri-list")), !0) : (Ro(n), !1);
};
function Ho(n, t) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let i = e.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = t, i.focus(), i.selectionEnd = t.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), n.focus();
  }, 50);
}
function No(n) {
  let t = [], e = [], i = !1;
  for (let s of n.selection.ranges)
    s.empty || (t.push(n.sliceDoc(s.from, s.to)), e.push(s));
  if (!t.length) {
    let s = -1;
    for (let { from: o } of n.selection.ranges) {
      let r = n.doc.lineAt(o);
      r.number > s && (t.push(r.text), e.push({ from: r.from, to: Math.min(n.doc.length, r.to + 1) })), s = r.number;
    }
    i = !0;
  }
  return { text: xe(n, li, t.join(n.lineBreak)), ranges: e, linewise: i };
}
let Xe = null;
X.copy = X.cut = (n, t) => {
  let { text: e, ranges: i, linewise: s } = No(n.state);
  if (!e && !s)
    return !1;
  Xe = s ? e : null, t.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let o = Zs ? null : t.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", e), !0) : (Ho(n, e), !1);
};
const sn = /* @__PURE__ */ Cn.define();
function nn(n, t) {
  let e = [];
  for (let i of n.facet(Fs)) {
    let s = i(n, t);
    s && e.push(s);
  }
  return e ? n.update({ effects: e, annotations: sn.of(!0) }) : null;
}
function on(n) {
  setTimeout(() => {
    let t = n.hasFocus;
    if (t != n.inputState.notifiedFocused) {
      let e = nn(n.state, t);
      e ? n.dispatch(e) : n.update([]);
    }
  }, 10);
}
j.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), on(n);
};
j.blur = (n) => {
  n.observer.clearSelectionRange(), on(n);
};
j.compositionstart = j.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
j.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, y.chrome && y.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
j.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
X.beforeinput = (n, t) => {
  var e, i;
  if (t.inputType == "insertReplacementText" && n.observer.editContext) {
    let o = (e = t.dataTransfer) === null || e === void 0 ? void 0 : e.getData("text/plain"), r = t.getTargetRanges();
    if (o && r.length) {
      let l = r[0], h = n.posAtDOM(l.startContainer, l.startOffset), c = n.posAtDOM(l.endContainer, l.endOffset);
      return ci(n, { from: h, to: c, insert: n.state.toText(o) }, null), !0;
    }
  }
  let s;
  if (y.chrome && y.android && (s = Qs.find((o) => o.inputType == t.inputType)) && (n.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let o = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var r;
      (((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0) > o + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return y.ios && t.inputType == "deleteContentForward" && n.observer.flushSoon(), y.safari && t.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => j.compositionend(n, t), 20), !1;
};
const Fi = /* @__PURE__ */ new Set();
function Vo(n) {
  Fi.has(n) || (Fi.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const Wi = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let At = !1;
function zi() {
  At = !1;
}
class Fo {
  constructor(t) {
    this.lineWrapping = t, this.doc = Y.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t, e) {
    let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((e - t - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return Wi.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let e = !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      s < 0 ? i++ : this.heightSamples[Math.floor(s * 10)] || (e = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return e;
  }
  refresh(t, e, i, s, o, r) {
    let l = Wi.indexOf(t) > -1, h = Math.round(e) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = e, this.charWidth = i, this.textHeight = s, this.lineLength = o, h) {
      this.heightSamples = {};
      for (let c = 0; c < r.length; c++) {
        let a = r[c];
        a < 0 ? c++ : this.heightSamples[Math.floor(a * 10)] = !0;
      }
    }
    return h;
  }
}
class Wo {
  constructor(t, e) {
    this.from = t, this.heights = e, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class $ {
  /**
  @internal
  */
  constructor(t, e, i, s, o) {
    this.from = t, this.length = e, this.top = i, this.height = s, this._content = o;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? F.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof ht ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let e = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new $(this.from, this.length + t.length, this.top, this.height + t.height, e);
  }
}
var T = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(T || (T = {}));
const ae = 1e-3;
class W {
  constructor(t, e, i = 2) {
    this.length = t, this.height = e, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t) {
    this.height != t && (Math.abs(this.height - t) > ae && (At = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, e, i) {
    return W.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, e) {
    e.push(this);
  }
  decomposeRight(t, e) {
    e.push(this);
  }
  applyChanges(t, e, i, s) {
    let o = this, r = i.doc;
    for (let l = s.length - 1; l >= 0; l--) {
      let { fromA: h, toA: c, fromB: a, toB: f } = s[l], d = o.lineAt(h, T.ByPosNoHeight, i.setDoc(e), 0, 0), u = d.to >= c ? d : o.lineAt(c, T.ByPosNoHeight, i, 0, 0);
      for (f += u.to - c, c = u.to; l > 0 && d.from <= s[l - 1].toA; )
        h = s[l - 1].fromA, a = s[l - 1].fromB, l--, h < d.from && (d = o.lineAt(h, T.ByPosNoHeight, i, 0, 0));
      a += d.from - h, h = d.from;
      let p = fi.build(i.setDoc(r), t, a, f);
      o = me(o, o.replace(h, c, p));
    }
    return o.updateHeight(i, 0);
  }
  static empty() {
    return new K(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let e = 0, i = t.length, s = 0, o = 0;
    for (; ; )
      if (e == i)
        if (s > o * 2) {
          let l = t[e - 1];
          l.break ? t.splice(--e, 1, l.left, null, l.right) : t.splice(--e, 1, l.left, l.right), i += 1 + l.break, s -= l.size;
        } else if (o > s * 2) {
          let l = t[i];
          l.break ? t.splice(i, 1, l.left, null, l.right) : t.splice(i, 1, l.left, l.right), i += 2 + l.break, o -= l.size;
        } else
          break;
      else if (s < o) {
        let l = t[e++];
        l && (s += l.size);
      } else {
        let l = t[--i];
        l && (o += l.size);
      }
    let r = 0;
    return t[e - 1] == null ? (r = 1, e--) : t[e] == null && (r = 1, i++), new zo(W.of(t.slice(0, e)), r, W.of(t.slice(i)));
  }
}
function me(n, t) {
  return n == t ? n : (n.constructor != t.constructor && (At = !0), t);
}
W.prototype.size = 1;
class rn extends W {
  constructor(t, e, i) {
    super(t, e), this.deco = i;
  }
  blockAt(t, e, i, s) {
    return new $(s, this.length, i, this.height, this.deco || 0);
  }
  lineAt(t, e, i, s, o) {
    return this.blockAt(0, i, s, o);
  }
  forEachLine(t, e, i, s, o, r) {
    t <= o + this.length && e >= o && r(this.blockAt(0, i, s, o));
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more && this.setHeight(s.heights[s.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class K extends rn {
  constructor(t, e) {
    super(t, e, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t, e, i, s) {
    return new $(s, this.length, i, this.height, this.breaks);
  }
  replace(t, e, i) {
    let s = i[0];
    return i.length == 1 && (s instanceof K || s instanceof H && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof H ? s = new K(s.length, this.height) : s.height = this.height, this.outdated || (s.outdated = !1), s) : W.of(i);
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more ? this.setHeight(s.heights[s.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class H extends W {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, e) {
    let i = t.doc.lineAt(e).number, s = t.doc.lineAt(e + this.length).number, o = s - i + 1, r, l = 0;
    if (t.lineWrapping) {
      let h = Math.min(this.height, t.lineHeight * o);
      r = h / o, this.length > o + 1 && (l = (this.height - h) / (this.length - o - 1));
    } else
      r = this.height / o;
    return { firstLine: i, lastLine: s, perLine: r, perChar: l };
  }
  blockAt(t, e, i, s) {
    let { firstLine: o, lastLine: r, perLine: l, perChar: h } = this.heightMetrics(e, s);
    if (e.lineWrapping) {
      let c = s + (t < e.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length)), a = e.doc.lineAt(c), f = l + a.length * h, d = Math.max(i, t - f / 2);
      return new $(a.from, a.length, d, f, 0);
    } else {
      let c = Math.max(0, Math.min(r - o, Math.floor((t - i) / l))), { from: a, length: f } = e.doc.line(o + c);
      return new $(a, f, i + l * c, l, 0);
    }
  }
  lineAt(t, e, i, s, o) {
    if (e == T.ByHeight)
      return this.blockAt(t, i, s, o);
    if (e == T.ByPosNoHeight) {
      let { from: u, to: p } = i.doc.lineAt(t);
      return new $(u, p - u, 0, 0, 0);
    }
    let { firstLine: r, perLine: l, perChar: h } = this.heightMetrics(i, o), c = i.doc.lineAt(t), a = l + c.length * h, f = c.number - r, d = s + l * f + h * (c.from - o - f);
    return new $(c.from, c.length, Math.max(s, Math.min(d, s + this.height - a)), a, 0);
  }
  forEachLine(t, e, i, s, o, r) {
    t = Math.max(t, o), e = Math.min(e, o + this.length);
    let { firstLine: l, perLine: h, perChar: c } = this.heightMetrics(i, o);
    for (let a = t, f = s; a <= e; ) {
      let d = i.doc.lineAt(a);
      if (a == t) {
        let p = d.number - l;
        f += h * p + c * (t - o - p);
      }
      let u = h + c * d.length;
      r(new $(d.from, d.length, f, u, 0)), f += u, a = d.to + 1;
    }
  }
  replace(t, e, i) {
    let s = this.length - e;
    if (s > 0) {
      let o = i[i.length - 1];
      o instanceof H ? i[i.length - 1] = new H(o.length + s) : i.push(null, new H(s - 1));
    }
    if (t > 0) {
      let o = i[0];
      o instanceof H ? i[0] = new H(t + o.length) : i.unshift(new H(t - 1), null);
    }
    return W.of(i);
  }
  decomposeLeft(t, e) {
    e.push(new H(t - 1), null);
  }
  decomposeRight(t, e) {
    e.push(null, new H(this.length - t - 1));
  }
  updateHeight(t, e = 0, i = !1, s) {
    let o = e + this.length;
    if (s && s.from <= e + this.length && s.more) {
      let r = [], l = Math.max(e, s.from), h = -1;
      for (s.from > e && r.push(new H(s.from - e - 1).updateHeight(t, e)); l <= o && s.more; ) {
        let a = t.doc.lineAt(l).length;
        r.length && r.push(null);
        let f = s.heights[s.index++];
        h == -1 ? h = f : Math.abs(f - h) >= ae && (h = -2);
        let d = new K(a, f);
        d.outdated = !1, r.push(d), l += a + 1;
      }
      l <= o && r.push(null, new H(o - l).updateHeight(t, l));
      let c = W.of(r);
      return (h < 0 || Math.abs(c.height - this.height) >= ae || Math.abs(h - this.heightMetrics(t, e).perLine) >= ae) && (At = !0), me(this, c);
    } else (i || this.outdated) && (this.setHeight(t.heightForGap(e, e + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class zo extends W {
  constructor(t, e, i) {
    super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, e, i, s) {
    let o = i + this.left.height;
    return t < o ? this.left.blockAt(t, e, i, s) : this.right.blockAt(t, e, o, s + this.left.length + this.break);
  }
  lineAt(t, e, i, s, o) {
    let r = s + this.left.height, l = o + this.left.length + this.break, h = e == T.ByHeight ? t < r : t < l, c = h ? this.left.lineAt(t, e, i, s, o) : this.right.lineAt(t, e, i, r, l);
    if (this.break || (h ? c.to < l : c.from > l))
      return c;
    let a = e == T.ByPosNoHeight ? T.ByPosNoHeight : T.ByPos;
    return h ? c.join(this.right.lineAt(l, a, i, r, l)) : this.left.lineAt(l, a, i, s, o).join(c);
  }
  forEachLine(t, e, i, s, o, r) {
    let l = s + this.left.height, h = o + this.left.length + this.break;
    if (this.break)
      t < h && this.left.forEachLine(t, e, i, s, o, r), e >= h && this.right.forEachLine(t, e, i, l, h, r);
    else {
      let c = this.lineAt(h, T.ByPos, i, s, o);
      t < c.from && this.left.forEachLine(t, c.from - 1, i, s, o, r), c.to >= t && c.from <= e && r(c), e > c.to && this.right.forEachLine(c.to + 1, e, i, l, h, r);
    }
  }
  replace(t, e, i) {
    let s = this.left.length + this.break;
    if (e < s)
      return this.balanced(this.left.replace(t, e, i), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - s, e - s, i));
    let o = [];
    t > 0 && this.decomposeLeft(t, o);
    let r = o.length;
    for (let l of i)
      o.push(l);
    if (t > 0 && Ii(o, r - 1), e < this.length) {
      let l = o.length;
      this.decomposeRight(e, o), Ii(o, l);
    }
    return W.of(o);
  }
  decomposeLeft(t, e) {
    let i = this.left.length;
    if (t <= i)
      return this.left.decomposeLeft(t, e);
    e.push(this.left), this.break && (i++, t >= i && e.push(null)), t > i && this.right.decomposeLeft(t - i, e);
  }
  decomposeRight(t, e) {
    let i = this.left.length, s = i + this.break;
    if (t >= s)
      return this.right.decomposeRight(t - s, e);
    t < i && this.left.decomposeRight(t, e), this.break && t < s && e.push(null), e.push(this.right);
  }
  balanced(t, e) {
    return t.size > 2 * e.size || e.size > 2 * t.size ? W.of(this.break ? [t, null, e] : [t, e]) : (this.left = me(this.left, t), this.right = me(this.right, e), this.setHeight(t.height + e.height), this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this);
  }
  updateHeight(t, e = 0, i = !1, s) {
    let { left: o, right: r } = this, l = e + o.length + this.break, h = null;
    return s && s.from <= e + o.length && s.more ? h = o = o.updateHeight(t, e, i, s) : o.updateHeight(t, e, i), s && s.from <= l + r.length && s.more ? h = r = r.updateHeight(t, l, i, s) : r.updateHeight(t, l, i), h ? this.balanced(o, r) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function Ii(n, t) {
  let e, i;
  n[t] == null && (e = n[t - 1]) instanceof H && (i = n[t + 1]) instanceof H && n.splice(t - 1, 3, new H(e.length + 1 + i.length));
}
const Io = 5;
class fi {
  constructor(t, e) {
    this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, e) {
    if (this.lineStart > -1) {
      let i = Math.min(e, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof K ? s.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new K(i - this.pos, -1)), this.writtenTo = i, e > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e;
  }
  point(t, e, i) {
    if (t < e || i.heightRelevant) {
      let s = i.widget ? i.widget.estimatedHeight : 0, o = i.widget ? i.widget.lineBreaks : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let r = e - t;
      i.block ? this.addBlock(new rn(r, s, i)) : (r || o || s >= Io) && this.addLineDeco(s, o, r);
    } else e > t && this.span(t, e);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: e } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new K(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, e) {
    let i = new H(e - t);
    return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof K)
      return t;
    let e = new K(0, -1);
    return this.nodes.push(e), e;
  }
  addBlock(t) {
    this.enterLine();
    let e = t.deco;
    e && e.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, e && e.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, e, i) {
    let s = this.ensureLine();
    s.length += i, s.collapsed += i, s.widgetHeight = Math.max(s.widgetHeight, t), s.breaks += e, this.writtenTo = this.pos = this.pos + i;
  }
  finish(t) {
    let e = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(e instanceof K) && !this.isCovered ? this.nodes.push(new K(0, -1)) : (this.writtenTo < this.pos || e == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = t;
    for (let s of this.nodes)
      s instanceof K && s.updateHeight(this.oracle, i), i += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, e, i, s) {
    let o = new fi(i, t);
    return V.spans(e, i, s, o, 0), o.finish(i);
  }
}
function Ko(n, t, e) {
  let i = new qo();
  return V.compare(n, t, e, i, 0), i.changes;
}
class qo {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, e, i, s) {
    (t < e || i && i.heightRelevant || s && s.heightRelevant) && We(t, e, this.changes, 5);
  }
}
function jo(n, t) {
  let e = n.getBoundingClientRect(), i = n.ownerDocument, s = i.defaultView || window, o = Math.max(0, e.left), r = Math.min(s.innerWidth, e.right), l = Math.max(0, e.top), h = Math.min(s.innerHeight, e.bottom);
  for (let c = n.parentNode; c && c != i.body; )
    if (c.nodeType == 1) {
      let a = c, f = window.getComputedStyle(a);
      if ((a.scrollHeight > a.clientHeight || a.scrollWidth > a.clientWidth) && f.overflow != "visible") {
        let d = a.getBoundingClientRect();
        o = Math.max(o, d.left), r = Math.min(r, d.right), l = Math.max(l, d.top), h = Math.min(c == n.parentNode ? s.innerHeight : h, d.bottom);
      }
      c = f.position == "absolute" || f.position == "fixed" ? a.offsetParent : a.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: o - e.left,
    right: Math.max(o, r) - e.left,
    top: l - (e.top + t),
    bottom: Math.max(l, h) - (e.top + t)
  };
}
function Yo(n, t) {
  let e = n.getBoundingClientRect();
  return {
    left: 0,
    right: e.right - e.left,
    top: t,
    bottom: e.bottom - (e.top + t)
  };
}
class Ae {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.size = i;
  }
  static same(t, e) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i], o = e[i];
      if (s.from != o.from || s.to != o.to || s.size != o.size)
        return !1;
    }
    return !0;
  }
  draw(t, e) {
    return R.replace({
      widget: new _o(this.size * (e ? t.scaleY : t.scaleX), e)
    }).range(this.from, this.to);
  }
}
class _o extends Ot {
  constructor(t, e) {
    super(), this.size = t, this.vertical = e;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Ki {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = qi, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = L.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let e = t.facet(hi).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new Fo(e), this.stateDeco = t.facet(It).filter((i) => typeof i != "function"), this.heightMap = W.empty().applyChanges(this.stateDeco, Y.empty, this.heightOracle.setDoc(t.doc), [new q(0, 0, 0, t.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = R.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: e } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let s = i ? e.head : e.anchor;
      if (!t.some(({ from: o, to: r }) => s >= o && s <= r)) {
        let { from: o, to: r } = this.lineBlockAt(s);
        t.push(new te(o, r));
      }
    }
    return this.viewports = t.sort((i, s) => i.from - s.from), this.updateScaler();
  }
  updateScaler() {
    let t = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? qi : new di(this.heightOracle, this.heightMap, this.viewports), t.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(Pt(t, this.scaler));
    });
  }
  update(t, e = null) {
    this.state = t.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(It).filter((a) => typeof a != "function");
    let s = t.changedRanges, o = q.extendWithRanges(s, Ko(i, this.stateDeco, t ? t.changes : as.empty(this.state.doc.length))), r = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    zi(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), o), (this.heightMap.height != r || At) && (t.flags |= 2), l ? (this.scrollAnchorPos = t.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let h = o.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (e && (e.range.head < h.from || e.range.head > h.to) || !this.viewportIsAppropriate(h)) && (h = this.getViewport(0, e));
    let c = h.from != this.viewport.from || h.to != this.viewport.to;
    this.viewport = h, t.flags |= this.updateForViewport(), (c || !t.changes.empty || t.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(zs) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let e = t.contentDOM, i = window.getComputedStyle(e), s = this.heightOracle, o = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? L.RTL : L.LTR;
    let r = this.heightOracle.mustRefreshForWrapping(o), l = e.getBoundingClientRect(), h = r || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let c = 0, a = 0;
    if (l.width && l.height) {
      let { scaleX: x, scaleY: S } = us(e, l);
      (x > 5e-3 && Math.abs(this.scaleX - x) > 5e-3 || S > 5e-3 && Math.abs(this.scaleY - S) > 5e-3) && (this.scaleX = x, this.scaleY = S, c |= 8, r = h = !0);
    }
    let f = (parseInt(i.paddingTop) || 0) * this.scaleY, d = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != f || this.paddingBottom != d) && (this.paddingTop = f, this.paddingBottom = d, c |= 10), this.editorWidth != t.scrollDOM.clientWidth && (s.lineWrapping && (h = !0), this.editorWidth = t.scrollDOM.clientWidth, c |= 8);
    let u = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != u && (this.scrollAnchorHeight = -1, this.scrollTop = u), this.scrolledToBottom = ms(t.scrollDOM);
    let p = (this.printing ? Yo : jo)(e, this.paddingTop), g = p.top - this.pixelViewport.top, b = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let m = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (m != this.inView && (this.inView = m, m && (h = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let w = l.width;
    if ((this.contentDOMWidth != w || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = t.scrollDOM.clientHeight, c |= 8), h) {
      let x = t.docView.measureVisibleLineHeights(this.viewport);
      if (s.mustRefreshForHeights(x) && (r = !0), r || s.lineWrapping && Math.abs(w - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: S, charWidth: C, textHeight: E } = t.docView.measureTextSize();
        r = S > 0 && s.refresh(o, S, C, E, w / C, x), r && (t.docView.minWidth = 0, c |= 8);
      }
      g > 0 && b > 0 ? a = Math.max(g, b) : g < 0 && b < 0 && (a = Math.min(g, b)), zi();
      for (let S of this.viewports) {
        let C = S.from == this.viewport.from ? x : t.docView.measureVisibleLineHeights(S);
        this.heightMap = (r ? W.empty().applyChanges(this.stateDeco, Y.empty, this.heightOracle, [new q(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(s, 0, r, new Wo(S.from, C));
      }
      At && (c |= 2);
    }
    let v = !this.viewportIsAppropriate(this.viewport, a) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return v && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(a, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || v) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(r ? [] : this.lineGaps, t)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, e) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), s = this.heightMap, o = this.heightOracle, { visibleTop: r, visibleBottom: l } = this, h = new te(s.lineAt(r - i * 1e3, T.ByHeight, o, 0, 0).from, s.lineAt(l + (1 - i) * 1e3, T.ByHeight, o, 0, 0).to);
    if (e) {
      let { head: c } = e.range;
      if (c < h.from || c > h.to) {
        let a = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), f = s.lineAt(c, T.ByPos, o, 0, 0), d;
        e.y == "center" ? d = (f.top + f.bottom) / 2 - a / 2 : e.y == "start" || e.y == "nearest" && c < h.from ? d = f.top : d = f.bottom - a, h = new te(s.lineAt(d - 1e3 / 2, T.ByHeight, o, 0, 0).from, s.lineAt(d + a + 1e3 / 2, T.ByHeight, o, 0, 0).to);
      }
    }
    return h;
  }
  mapViewport(t, e) {
    let i = e.mapPos(t.from, -1), s = e.mapPos(t.to, 1);
    return new te(this.heightMap.lineAt(i, T.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s, T.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: e }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(t, T.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(e, T.ByPos, this.heightOracle, 0, 0), { visibleTop: r, visibleBottom: l } = this;
    return (t == 0 || s <= r - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (e == this.state.doc.length || o >= l + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && s > r - 2 * 1e3 && o < l + 2 * 1e3;
  }
  mapLineGaps(t, e) {
    if (!t.length || e.empty)
      return t;
    let i = [];
    for (let s of t)
      e.touchesRange(s.from, s.to) || i.push(new Ae(e.mapPos(s.from), e.mapPos(s.to), s.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, e) {
    let i = this.heightOracle.lineWrapping, s = i ? 1e4 : 2e3, o = s >> 1, r = s << 1;
    if (this.defaultTextDirection != L.LTR && !i)
      return [];
    let l = [], h = (a, f, d, u) => {
      if (f - a < o)
        return;
      let p = this.state.selection.main, g = [p.from];
      p.empty || g.push(p.to);
      for (let m of g)
        if (m > a && m < f) {
          h(a, m - 10, d, u), h(m + 10, f, d, u);
          return;
        }
      let b = Go(t, (m) => m.from >= d.from && m.to <= d.to && Math.abs(m.from - a) < o && Math.abs(m.to - f) < o && !g.some((w) => m.from < w && m.to > w));
      if (!b) {
        if (f < d.to && e && i && e.visibleRanges.some((m) => m.from <= f && m.to >= f)) {
          let m = e.moveToLineBoundary(k.cursor(f), !1, !0).head;
          m > a && (f = m);
        }
        b = new Ae(a, f, this.gapSize(d, a, f, u));
      }
      l.push(b);
    }, c = (a) => {
      if (a.length < r || a.type != F.Text)
        return;
      let f = Xo(a.from, a.to, this.stateDeco);
      if (f.total < r)
        return;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, u, p;
      if (i) {
        let g = s / this.heightOracle.lineLength * this.heightOracle.lineHeight, b, m;
        if (d != null) {
          let w = ie(f, d), v = ((this.visibleBottom - this.visibleTop) / 2 + g) / a.height;
          b = w - v, m = w + v;
        } else
          b = (this.visibleTop - a.top - g) / a.height, m = (this.visibleBottom - a.top + g) / a.height;
        u = ee(f, b), p = ee(f, m);
      } else {
        let g = f.total * this.heightOracle.charWidth, b = s * this.heightOracle.charWidth, m, w;
        if (d != null) {
          let v = ie(f, d), x = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + b) / g;
          m = v - x, w = v + x;
        } else
          m = (this.pixelViewport.left - b) / g, w = (this.pixelViewport.right + b) / g;
        u = ee(f, m), p = ee(f, w);
      }
      u > a.from && h(a.from, u, a, f), p < a.to && h(p, a.to, a, f);
    };
    for (let a of this.viewportLines)
      Array.isArray(a.type) ? a.type.forEach(c) : c(a);
    return l;
  }
  gapSize(t, e, i, s) {
    let o = ie(s, i) - ie(s, e);
    return this.heightOracle.lineWrapping ? t.height * o : s.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(t) {
    Ae.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = R.set(t.map((e) => e.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let e = [];
    V.spans(t, this.viewport.from, this.viewport.to, {
      span(s, o) {
        e.push({ from: s, to: o });
      },
      point() {
      }
    }, 20);
    let i = e.length != this.visibleRanges.length || this.visibleRanges.some((s, o) => s.from != e[o].from || s.to != e[o].to);
    return this.visibleRanges = e, i ? 4 : 0;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((e) => e.from <= t && e.to >= t) || Pt(this.heightMap.lineAt(t, T.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return t >= this.viewportLines[0].top && t <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e) => e.top <= t && e.bottom >= t) || Pt(this.heightMap.lineAt(this.scaler.fromDOM(t), T.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let e = this.lineBlockAtHeight(t + 8);
    return e.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? e : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return Pt(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class te {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}
function Xo(n, t, e) {
  let i = [], s = n, o = 0;
  return V.spans(e, n, t, {
    span() {
    },
    point(r, l) {
      r > s && (i.push({ from: s, to: r }), o += r - s), s = l;
    }
  }, 20), s < t && (i.push({ from: s, to: t }), o += t - s), { total: o, ranges: i };
}
function ee({ total: n, ranges: t }, e) {
  if (e <= 0)
    return t[0].from;
  if (e >= 1)
    return t[t.length - 1].to;
  let i = Math.floor(n * e);
  for (let s = 0; ; s++) {
    let { from: o, to: r } = t[s], l = r - o;
    if (i <= l)
      return o + i;
    i -= l;
  }
}
function ie(n, t) {
  let e = 0;
  for (let { from: i, to: s } of n.ranges) {
    if (t <= s) {
      e += t - i;
      break;
    }
    e += s - i;
  }
  return e / n.total;
}
function Go(n, t) {
  for (let e of n)
    if (t(e))
      return e;
}
const qi = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
class di {
  constructor(t, e, i) {
    let s = 0, o = 0, r = 0;
    this.viewports = i.map(({ from: l, to: h }) => {
      let c = e.lineAt(l, T.ByPos, t, 0, 0).top, a = e.lineAt(h, T.ByPos, t, 0, 0).bottom;
      return s += a - c, { from: l, to: h, top: c, bottom: a, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (e.height - s);
    for (let l of this.viewports)
      l.domTop = r + (l.top - o) * this.scale, r = l.domBottom = l.domTop + (l.bottom - l.top), o = l.bottom;
  }
  toDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let o = e < this.viewports.length ? this.viewports[e] : null;
      if (!o || t < o.top)
        return s + (t - i) * this.scale;
      if (t <= o.bottom)
        return o.domTop + (t - o.top);
      i = o.bottom, s = o.domBottom;
    }
  }
  fromDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let o = e < this.viewports.length ? this.viewports[e] : null;
      if (!o || t < o.domTop)
        return i + (t - s) / this.scale;
      if (t <= o.domBottom)
        return o.top + (t - o.domTop);
      i = o.bottom, s = o.domBottom;
    }
  }
  eq(t) {
    return t instanceof di ? this.scale == t.scale && this.viewports.length == t.viewports.length && this.viewports.every((e, i) => e.from == t.viewports[i].from && e.to == t.viewports[i].to) : !1;
  }
}
function Pt(n, t) {
  if (t.scale == 1)
    return n;
  let e = t.toDOM(n.top), i = t.toDOM(n.bottom);
  return new $(n.from, n.length, e, i - e, Array.isArray(n._content) ? n._content.map((s) => Pt(s, t)) : n._content);
}
const se = /* @__PURE__ */ M.define({ combine: (n) => n.join(" ") }), Ge = /* @__PURE__ */ M.define({ combine: (n) => n.indexOf(!0) > -1 }), $e = /* @__PURE__ */ St.newName(), ln = /* @__PURE__ */ St.newName(), hn = /* @__PURE__ */ St.newName(), an = { "&light": "." + ln, "&dark": "." + hn };
function Ue(n, t, e) {
  return new St(t, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (s) => {
        if (s == "&")
          return n;
        if (!e || !e[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return e[s];
      }) : n + " " + i;
    }
  });
}
const $o = /* @__PURE__ */ Ue("." + $e, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, an), Uo = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, De = y.ie && y.ie_version <= 11;
class Qo {
  constructor(t) {
    this.view = t, this.active = !1, this.editContext = null, this.selectionRange = new Pn(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((e) => {
      for (let i of e)
        this.queue.push(i);
      (y.ie && y.ie_version <= 11 || y.ios && t.composing) && e.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && t.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(y.chrome && y.chrome_version < 126) && (this.editContext = new Zo(t), t.state.facet(nt) && (t.contentDOM.editContext = this.editContext.editContext)), De && (this.onCharData = (e) => {
      this.queue.push({
        target: e.target,
        type: "characterData",
        oldValue: e.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var e;
      ((e = this.view.docView) === null || e === void 0 ? void 0 : e.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((e) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), e.length > 0 && e[e.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((e) => {
      e.length > 0 && e[e.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    (t.type == "change" || !t.type) && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((e, i) => e != t[i]))) {
      this.gapIntersection.disconnect();
      for (let e of t)
        this.gapIntersection.observe(e);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let e = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, s = this.selectionRange;
    if (i.state.facet(nt) ? i.root.activeElement != this.dom : !le(i.dom, s))
      return;
    let o = s.anchorNode && i.docView.nearest(s.anchorNode);
    if (o && o.ignoreEvent(t)) {
      e || (this.selectionChanged = !1);
      return;
    }
    (y.ie && y.ie_version <= 11 || y.android && y.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    s.focusNode && Vt(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, e = zt(t.root);
    if (!e)
      return !1;
    let i = y.safari && t.root.nodeType == 11 && Rn(this.dom.ownerDocument) == this.dom && Jo(this.view, e) || e;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let s = le(this.dom, i);
    return s && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && Nn(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, e) {
    this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, e = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !e && t < this.scrollTargets.length && this.scrollTargets[t] == i ? t++ : e || (e = this.scrollTargets.slice(0, t)), e && e.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (t < this.scrollTargets.length && !e && (e = this.scrollTargets.slice(0, t)), e) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = e)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, Uo), De && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), De && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, e) {
    var i;
    if (!this.delayedAndroidKey) {
      let s = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && xt(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(s);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: e,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let e = -1, i = -1, s = !1;
    for (let o of t) {
      let r = this.readMutation(o);
      r && (r.typeOver && (s = !0), e == -1 ? { from: e, to: i } = r : (e = Math.min(r.from, e), i = Math.max(r.to, i)));
    }
    return { from: e, to: i, typeOver: s };
  }
  readChange() {
    let { from: t, to: e, typeOver: i } = this.processRecords(), s = this.selectionChanged && le(this.dom, this.selectionRange);
    if (t < 0 && !s)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let o = new mo(this.view, t, e, i);
    return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let e = this.readChange();
    if (!e)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, s = Us(this.view, e);
    return this.view.state == i && (e.domChanged || e.newSel && !e.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s;
  }
  readMutation(t) {
    let e = this.view.docView.nearest(t.target);
    if (!e || e.ignoreMutation(t))
      return null;
    if (e.markDirty(t.type == "attributes"), t.type == "attributes" && (e.flags |= 4), t.type == "childList") {
      let i = ji(e, t.previousSibling || t.target.previousSibling, -1), s = ji(e, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: i ? e.posAfter(i) : e.posAtStart,
        to: s ? e.posBefore(s) : e.posAtEnd,
        typeOver: !1
      };
    } else return t.type == "characterData" ? { from: e.posAtStart, to: e.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t) {
    this.editContext && (this.editContext.update(t), t.startState.facet(nt) != t.state.facet(nt) && (t.view.contentDOM.editContext = t.state.facet(nt) ? this.editContext.editContext : null));
  }
  destroy() {
    var t, e, i;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (e = this.gapIntersection) === null || e === void 0 || e.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function ji(n, t, e) {
  for (; t; ) {
    let i = O.get(t);
    if (i && i.parent == n)
      return i;
    let s = t.parentNode;
    t = s != n.dom ? s : e > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
function Yi(n, t) {
  let e = t.startContainer, i = t.startOffset, s = t.endContainer, o = t.endOffset, r = n.docView.domAtPos(n.state.selection.main.anchor);
  return Vt(r.node, r.offset, s, o) && ([e, i, s, o] = [s, o, e, i]), { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: o };
}
function Jo(n, t) {
  if (t.getComposedRanges) {
    let s = t.getComposedRanges(n.root)[0];
    if (s)
      return Yi(n, s);
  }
  let e = null;
  function i(s) {
    s.preventDefault(), s.stopImmediatePropagation(), e = s.getTargetRanges()[0];
  }
  return n.contentDOM.addEventListener("beforeinput", i, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", i, !0), e ? Yi(n, e) : null;
}
class Zo {
  constructor(t) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.resetRange(t.state);
    let e = this.editContext = new window.EditContext({
      text: t.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(t.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let { anchor: s } = t.state.selection.main, o = {
        from: this.toEditorPos(i.updateRangeStart),
        to: this.toEditorPos(i.updateRangeEnd),
        insert: Y.of(i.text.split(`
`))
      };
      o.from == this.from && s < this.from ? o.from = s : o.to == this.to && s > this.to && (o.to = s), !(o.from == o.to && !o.insert.length) && (this.pendingContextChange = o, t.state.readOnly || ci(t, o, k.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd))), this.pendingContextChange && (this.revertPending(t.state), this.setSelection(t.state)));
    }, this.handlers.characterboundsupdate = (i) => {
      let s = [], o = null;
      for (let r = this.toEditorPos(i.rangeStart), l = this.toEditorPos(i.rangeEnd); r < l; r++) {
        let h = t.coordsForChar(r);
        o = h && new DOMRect(h.left, h.top, h.right - h.left, h.bottom - h.top) || o || new DOMRect(), s.push(o);
      }
      e.updateCharacterBounds(i.rangeStart, s);
    }, this.handlers.textformatupdate = (i) => {
      let s = [];
      for (let o of i.getTextFormats()) {
        let r = o.underlineStyle, l = o.underlineThickness;
        if (r != "None" && l != "None") {
          let h = `text-decoration: underline ${r == "Dashed" ? "dashed " : r == "Squiggle" ? "wavy " : ""}${l == "Thin" ? 1 : 2}px`;
          s.push(R.mark({ attributes: { style: h } }).range(this.toEditorPos(o.rangeStart), this.toEditorPos(o.rangeEnd)));
        }
      }
      t.dispatch({ effects: Ks.of(R.set(s)) });
    }, this.handlers.compositionstart = () => {
      t.inputState.composing < 0 && (t.inputState.composing = 0, t.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      t.inputState.composing = -1, t.inputState.compositionFirstChange = null;
    };
    for (let i in this.handlers)
      e.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: (i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let s = zt(i.root);
      s && s.rangeCount && this.editContext.updateSelectionBounds(s.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(t) {
    let e = 0, i = !1, s = this.pendingContextChange;
    return t.changes.iterChanges((o, r, l, h, c) => {
      if (i)
        return;
      let a = c.length - (r - o);
      if (s && r >= s.to)
        if (s.from == o && s.to == r && s.insert.eq(c)) {
          s = this.pendingContextChange = null, e += a, this.to += a;
          return;
        } else
          s = null, this.revertPending(t.state);
      if (o += e, r += e, r <= this.from)
        this.from += a, this.to += a;
      else if (o < this.to) {
        if (o < this.from || r > this.to || this.to - this.from + c.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(o), this.toContextPos(r), c.toString()), this.to += a;
      }
      e += a;
    }), s && !i && this.revertPending(t.state), !i;
  }
  update(t) {
    let e = this.pendingContextChange;
    !this.applyEdits(t) || !this.rangeIsValid(t.state) ? (this.pendingContextChange = null, this.resetRange(t.state), this.editContext.updateText(0, this.editContext.text.length, t.state.doc.sliceString(this.from, this.to)), this.setSelection(t.state)) : (t.docChanged || t.selectionSet || e) && this.setSelection(t.state), (t.geometryChanged || t.docChanged || t.selectionSet) && t.view.requestMeasure(this.measureReq);
  }
  resetRange(t) {
    let { head: e } = t.selection.main;
    this.from = Math.max(
      0,
      e - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      t.doc.length,
      e + 1e4
      /* CxVp.Margin */
    );
  }
  revertPending(t) {
    let e = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e.from), this.toContextPos(e.from + e.insert.length), t.doc.sliceString(e.from, e.to));
  }
  setSelection(t) {
    let { main: e } = t.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, e.anchor))), s = this.toContextPos(e.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != s) && this.editContext.updateSelection(i, s);
  }
  rangeIsValid(t) {
    let { head: e } = t.selection.main;
    return !(this.from > 0 && e - this.from < 500 || this.to < t.doc.length && this.to - e < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(t) {
    return t + this.from;
  }
  toContextPos(t) {
    return t - this.from;
  }
  destroy() {
    for (let t in this.handlers)
      this.editContext.removeEventListener(t, this.handlers[t]);
  }
}
class A {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    var e;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: i } = t;
    this.dispatchTransactions = t.dispatchTransactions || i && ((s) => s.forEach((o) => i(o, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = t.root || Hn(t.parent) || document, this.viewState = new Ki(t.state || Nt.create(t)), t.scrollTo && t.scrollTo.is(Qt) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Et).map((s) => new Ce(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new Qo(this), this.inputState = new vo(this), this.inputState.ensureHandlers(this.plugins), this.docView = new Ci(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((e = document.fonts) === null || e === void 0) && e.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...t) {
    let e = t.length == 1 && t[0] instanceof Sn ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(e, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e = !1, i = !1, s, o = this.state;
    for (let d of t) {
      if (d.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let r = this.hasFocus, l = 0, h = null;
    t.some((d) => d.annotation(sn)) ? (this.inputState.notifiedFocused = r, l = 1) : r != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = r, h = nn(o, r), h || (l = 1));
    let c = this.observer.delayedAndroidKey, a = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), a = this.observer.readChange(), (a && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (a = null)) : this.observer.clear(), o.facet(Nt.phrases) != this.state.facet(Nt.phrases))
      return this.setState(o);
    s = ge.create(this, o, t), s.flags |= l;
    let f = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of t) {
        if (f && (f = f.map(d.changes)), d.scrollIntoView) {
          let { main: u } = d.state.selection;
          f = new vt(u.empty ? u : k.cursor(u.head, u.head > u.anchor ? -1 : 1));
        }
        for (let u of d.effects)
          u.is(Qt) && (f = u.value.clip(this.state));
      }
      this.viewState.update(s, f), this.bidiCache = be.update(this.bidiCache, s.changes), s.empty || (this.updatePlugins(s), this.inputState.update(s)), e = this.docView.update(s), this.state.facet(Lt) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(e, t.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s.startState.facet(se) != s.state.facet(se) && (this.viewState.mustMeasureContent = !0), (e || i || f || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e && this.docViewUpdate(), !s.empty)
      for (let d of this.state.facet(je))
        try {
          d(s);
        } catch (u) {
          U(this.state, u, "update listener");
        }
    (h || a) && Promise.resolve().then(() => {
      h && this.state == h.startState && this.dispatch(h), a && !Us(this, a) && c.force && xt(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let e = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new Ki(t), this.plugins = t.facet(Et).map((i) => new Ce(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new Ci(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let e = t.startState.facet(Et), i = t.state.facet(Et);
    if (e != i) {
      let s = [];
      for (let o of i) {
        let r = e.indexOf(o);
        if (r < 0)
          s.push(new Ce(o));
        else {
          let l = this.plugins[r];
          l.mustUpdate = t, s.push(l);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != t && o.destroy(this);
      this.plugins = s, this.pluginMap.clear();
    } else
      for (let s of this.plugins)
        s.mustUpdate = t;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
    e != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let e = t.value;
      if (e && e.docViewUpdate)
        try {
          e.docViewUpdate(this);
        } catch (i) {
          U(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let e = null, i = this.scrollDOM, s = i.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: r } = this.viewState;
    Math.abs(s - this.viewState.scrollTop) > 1 && (r = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (r < 0)
          if (ms(i))
            o = -1, r = this.viewState.heightMap.height;
          else {
            let u = this.viewState.scrollAnchorAt(s);
            o = u.from, r = u.top;
          }
        this.updateState = 1;
        let h = this.viewState.measure(this);
        if (!h && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        h & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let a = c.map((u) => {
          try {
            return u.read(this);
          } catch (p) {
            return U(this.state, p), _i;
          }
        }), f = ge.create(this, this.state, []), d = !1;
        f.flags |= h, e ? e.flags |= h : e = f, this.updateState = 2, f.empty || (this.updatePlugins(f), this.inputState.update(f), this.updateAttrs(), d = this.docView.update(f), d && this.docViewUpdate());
        for (let u = 0; u < c.length; u++)
          if (a[u] != _i)
            try {
              let p = c[u];
              p.write && p.write(a[u], this);
            } catch (p) {
              U(this.state, p);
            }
        if (d && this.docView.updateSelection(!0), !f.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, r = -1;
              continue;
            } else {
              let p = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - r;
              if (p > 1 || p < -1) {
                s = s + p, i.scrollTop = s / this.scaleY, r = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e && !e.empty)
      for (let l of this.state.facet(je))
        l(e);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return $e + " " + (this.state.facet(Ge) ? hn : ln) + " " + this.state.facet(se);
  }
  updateAttrs() {
    let t = Xi(this, qs, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), e = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(nt) ? "true" : "false",
      class: "cm-content",
      style: `${y.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (e["aria-readonly"] = "true"), Xi(this, hi, e);
    let i = this.observer.ignore(() => {
      let s = Fe(this.contentDOM, this.contentAttrs, e), o = Fe(this.dom, this.editorAttrs, t);
      return s || o;
    });
    return this.editorAttrs = t, this.contentAttrs = e, i;
  }
  showAnnouncements(t) {
    let e = !0;
    for (let i of t)
      for (let s of i.effects)
        if (s.is(A.announce)) {
          e && (this.announceDOM.textContent = ""), e = !1;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Lt);
    let t = this.state.facet(A.cspNonce);
    St.mount(this.root, this.styleModules.concat($o).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let e = 0; e < this.measureRequests.length; e++)
          if (this.measureRequests[e].key === t.key) {
            this.measureRequests[e] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let e = this.pluginMap.get(t);
    return (e === void 0 || e && e.spec != t) && this.pluginMap.set(t, e = this.plugins.find((i) => i.spec == t) || null), e && e.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, e, i) {
    return ke(this, t, Oi(this, t, e, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, e) {
    return ke(this, t, Oi(this, t, e, (i) => fo(this, t.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, e) {
    let i = this.bidiSpans(t), s = this.textDirectionAt(t.from), o = i[e ? i.length - 1 : 0];
    return k.cursor(o.side(e, s) + t.from, o.forward(!e, s) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, e, i = !0) {
    return co(this, t, e, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, e, i) {
    return ke(this, t, uo(this, t, e, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, e = 0) {
    return this.docView.posFromDOM(t, e);
  }
  posAtCoords(t, e = !0) {
    return this.readMeasured(), $s(this, t, e);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, e = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(t, e);
    if (!i || i.left == i.right)
      return i;
    let s = this.state.doc.lineAt(t), o = this.bidiSpans(s), r = o[lt.find(o, t - s.from, -1, e)];
    return qt(i, r.dir == L.LTR == e > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(Ws) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > tr)
      return Es(t.length);
    let e = this.textDirectionAt(t.from), i;
    for (let o of this.bidiCache)
      if (o.from == t.from && o.dir == e && (o.fresh || Rs(o.isolates, i = Si(this, t))))
        return o.order;
    i || (i = Si(this, t));
    let s = Gn(t.text, e, i);
    return this.bidiCache.push(new be(t.from, t.to, e, i, !0, s)), s;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || y.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      ps(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, e = {}) {
    return Qt.of(new vt(typeof t == "number" ? k.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: e } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t);
    return Qt.of(new vt(k.cursor(i.from), "start", "start", i.top - t, e, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(t) {
    t == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof t == "boolean" ? this.inputState.tabFocusMode = t ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + t);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return z.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return z.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be
  addedâ€”need to be explicitly differentiated by adding an `&` to
  the selector for that elementâ€”for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, e) {
    let i = St.newName(), s = [se.of(i), Lt.of(Ue(`.${i}`, t))];
    return e && e.dark && s.push(Ge.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return ii.lowest(Lt.of(Ue("." + $e, t, an)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var e;
    let i = t.querySelector(".cm-content"), s = i && O.get(i) || O.get(t);
    return ((e = s == null ? void 0 : s.rootView) === null || e === void 0 ? void 0 : e.view) || null;
  }
}
A.styleModule = Lt;
A.inputHandler = Vs;
A.clipboardInputFilter = ri;
A.clipboardOutputFilter = li;
A.scrollHandler = Is;
A.focusChangeEffect = Fs;
A.perLineTextDirection = Ws;
A.exceptionSink = Ns;
A.updateListener = je;
A.editable = nt;
A.mouseSelectionStyle = Hs;
A.dragMovesSelection = Ps;
A.clickAddsSelectionRange = Bs;
A.decorations = It;
A.outerDecorations = js;
A.atomicRanges = ai;
A.bidiIsolatedRanges = Ys;
A.scrollMargins = _s;
A.darkTheme = Ge;
A.cspNonce = /* @__PURE__ */ M.define({ combine: (n) => n.length ? n[0] : "" });
A.contentAttributes = hi;
A.editorAttributes = qs;
A.lineWrapping = /* @__PURE__ */ A.contentAttributes.of({ class: "cm-lineWrapping" });
A.announce = /* @__PURE__ */ Dt.define();
const tr = 4096, _i = {};
class be {
  constructor(t, e, i, s, o, r) {
    this.from = t, this.to = e, this.dir = i, this.isolates = s, this.fresh = o, this.order = r;
  }
  static update(t, e) {
    if (e.empty && !t.some((o) => o.fresh))
      return t;
    let i = [], s = t.length ? t[t.length - 1].dir : L.LTR;
    for (let o = Math.max(0, t.length - 10); o < t.length; o++) {
      let r = t[o];
      r.dir == s && !e.touchesRange(r.from, r.to) && i.push(new be(e.mapPos(r.from, 1), e.mapPos(r.to, -1), r.dir, r.isolates, !1, r.order));
    }
    return i;
  }
}
function Xi(n, t, e) {
  for (let i = n.state.facet(t), s = i.length - 1; s >= 0; s--) {
    let o = i[s], r = typeof o == "function" ? o(n) : o;
    r && Ve(r, e);
  }
  return e;
}
const er = y.mac ? "mac" : y.windows ? "win" : y.linux ? "linux" : "key";
function ir(n, t) {
  const e = n.split(/-(?!$)/);
  let i = e[e.length - 1];
  i == "Space" && (i = " ");
  let s, o, r, l;
  for (let h = 0; h < e.length - 1; ++h) {
    const c = e[h];
    if (/^(cmd|meta|m)$/i.test(c))
      l = !0;
    else if (/^a(lt)?$/i.test(c))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      o = !0;
    else if (/^s(hift)?$/i.test(c))
      r = !0;
    else if (/^mod$/i.test(c))
      t == "mac" ? l = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return s && (i = "Alt-" + i), o && (i = "Ctrl-" + i), l && (i = "Meta-" + i), r && (i = "Shift-" + i), i;
}
function ne(n, t, e) {
  return t.altKey && (n = "Alt-" + n), t.ctrlKey && (n = "Ctrl-" + n), t.metaKey && (n = "Meta-" + n), e !== !1 && t.shiftKey && (n = "Shift-" + n), n;
}
const sr = /* @__PURE__ */ ii.default(/* @__PURE__ */ A.domEventHandlers({
  keydown(n, t) {
    return fn(cn(t.state), n, t, "editor");
  }
})), nr = /* @__PURE__ */ M.define({ enables: sr }), Gi = /* @__PURE__ */ new WeakMap();
function cn(n) {
  let t = n.facet(nr), e = Gi.get(t);
  return e || Gi.set(t, e = rr(t.reduce((i, s) => i.concat(s), []))), e;
}
function tl(n, t, e) {
  return fn(cn(n.state), t, n, e);
}
let ot = null;
const or = 4e3;
function rr(n, t = er) {
  let e = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), s = (r, l) => {
    let h = i[r];
    if (h == null)
      i[r] = l;
    else if (h != l)
      throw new Error("Key binding " + r + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (r, l, h, c, a) => {
    var f, d;
    let u = e[r] || (e[r] = /* @__PURE__ */ Object.create(null)), p = l.split(/ (?!$)/).map((m) => ir(m, t));
    for (let m = 1; m < p.length; m++) {
      let w = p.slice(0, m).join(" ");
      s(w, !0), u[w] || (u[w] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(v) => {
          let x = ot = { view: v, prefix: w, scope: r };
          return setTimeout(() => {
            ot == x && (ot = null);
          }, or), !0;
        }]
      });
    }
    let g = p.join(" ");
    s(g, !1);
    let b = u[g] || (u[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (f = u._any) === null || f === void 0 ? void 0 : f.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    h && b.run.push(h), c && (b.preventDefault = !0), a && (b.stopPropagation = !0);
  };
  for (let r of n) {
    let l = r.scope ? r.scope.split(" ") : ["editor"];
    if (r.any)
      for (let c of l) {
        let a = e[c] || (e[c] = /* @__PURE__ */ Object.create(null));
        a._any || (a._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: f } = r;
        for (let d in a)
          a[d].run.push((u) => f(u, Qe));
      }
    let h = r[t] || r.key;
    if (h)
      for (let c of l)
        o(c, h, r.run, r.preventDefault, r.stopPropagation), r.shift && o(c, "Shift-" + h, r.shift, r.preventDefault, r.stopPropagation);
  }
  return e;
}
let Qe = null;
function fn(n, t, e, i) {
  Qe = t;
  let s = Dn(t), o = cs(s, 0), r = Mn(o) == s.length && s != " ", l = "", h = !1, c = !1, a = !1;
  ot && ot.view == e && ot.scope == i && (l = ot.prefix + " ", Js.indexOf(t.keyCode) < 0 && (c = !0, ot = null));
  let f = /* @__PURE__ */ new Set(), d = (b) => {
    if (b) {
      for (let m of b.run)
        if (!f.has(m) && (f.add(m), m(e)))
          return b.stopPropagation && (a = !0), !0;
      b.preventDefault && (b.stopPropagation && (a = !0), c = !0);
    }
    return !1;
  }, u = n[i], p, g;
  return u && (d(u[l + ne(s, t, !r)]) ? h = !0 : r && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(y.windows && t.ctrlKey && t.altKey) && (p = On[t.keyCode]) && p != s ? (d(u[l + ne(p, t, !0)]) || t.shiftKey && (g = Tn[t.keyCode]) != s && g != p && d(u[l + ne(g, t, !1)])) && (h = !0) : r && t.shiftKey && d(u[l + ne(s, t, !0)]) && (h = !0), !h && d(u._any) && (h = !0)), c && (h = !0), h && a && t.stopPropagation(), Qe = null, h;
}
class _t {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(t, e, i, s, o) {
    this.className = t, this.left = e, this.top = i, this.width = s, this.height = o;
  }
  draw() {
    let t = document.createElement("div");
    return t.className = this.className, this.adjust(t), t;
  }
  update(t, e) {
    return e.className != this.className ? !1 : (this.adjust(t), !0);
  }
  adjust(t) {
    t.style.left = this.left + "px", t.style.top = this.top + "px", this.width != null && (t.style.width = this.width + "px"), t.style.height = this.height + "px";
  }
  eq(t) {
    return this.left == t.left && this.top == t.top && this.width == t.width && this.height == t.height && this.className == t.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(t, e, i) {
    if (i.empty) {
      let s = t.coordsAtPos(i.head, i.assoc || 1);
      if (!s)
        return [];
      let o = dn(t);
      return [new _t(e, s.left - o.left, s.top - o.top, null, s.bottom - s.top)];
    } else
      return lr(t, e, i);
  }
}
function dn(n) {
  let t = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == L.LTR ? t.left : t.right - n.scrollDOM.clientWidth * n.scaleX) - n.scrollDOM.scrollLeft * n.scaleX, top: t.top - n.scrollDOM.scrollTop * n.scaleY };
}
function $i(n, t, e, i) {
  let s = n.coordsAtPos(t, e * 2);
  if (!s)
    return i;
  let o = n.dom.getBoundingClientRect(), r = (s.top + s.bottom) / 2, l = n.posAtCoords({ x: o.left + 1, y: r }), h = n.posAtCoords({ x: o.right - 1, y: r });
  return l == null || h == null ? i : { from: Math.max(i.from, Math.min(l, h)), to: Math.min(i.to, Math.max(l, h)) };
}
function lr(n, t, e) {
  if (e.to <= n.viewport.from || e.from >= n.viewport.to)
    return [];
  let i = Math.max(e.from, n.viewport.from), s = Math.min(e.to, n.viewport.to), o = n.textDirection == L.LTR, r = n.contentDOM, l = r.getBoundingClientRect(), h = dn(n), c = r.querySelector(".cm-line"), a = c && window.getComputedStyle(c), f = l.left + (a ? parseInt(a.paddingLeft) + Math.min(0, parseInt(a.textIndent)) : 0), d = l.right - (a ? parseInt(a.paddingRight) : 0), u = _e(n, i), p = _e(n, s), g = u.type == F.Text ? u : null, b = p.type == F.Text ? p : null;
  if (g && (n.lineWrapping || u.widgetLineBreaks) && (g = $i(n, i, 1, g)), b && (n.lineWrapping || p.widgetLineBreaks) && (b = $i(n, s, -1, b)), g && b && g.from == b.from && g.to == b.to)
    return w(v(e.from, e.to, g));
  {
    let S = g ? v(e.from, null, g) : x(u, !1), C = b ? v(null, e.to, b) : x(p, !0), E = [];
    return (g || u).to < (b || p).from - (g && b ? 1 : 0) || u.widgetLineBreaks > 1 && S.bottom + n.defaultLineHeight / 2 < C.top ? E.push(m(f, S.bottom, d, C.top)) : S.bottom < C.top && n.elementAtHeight((S.bottom + C.top) / 2).type == F.Text && (S.bottom = C.top = (S.bottom + C.top) / 2), w(S).concat(E).concat(w(C));
  }
  function m(S, C, E, P) {
    return new _t(
      t,
      S - h.left,
      C - h.top - 0.01,
      E - S,
      P - C + 0.01
      /* C.Epsilon */
    );
  }
  function w({ top: S, bottom: C, horizontal: E }) {
    let P = [];
    for (let it = 0; it < E.length; it += 2)
      P.push(m(E[it], S, E[it + 1], C));
    return P;
  }
  function v(S, C, E) {
    let P = 1e9, it = -1e9, Xt = [];
    function pi(ct, st, gt, ft, Tt) {
      let Q = n.coordsAtPos(ct, ct == E.to ? -2 : 2), J = n.coordsAtPos(gt, gt == E.from ? 2 : -2);
      !Q || !J || (P = Math.min(Q.top, J.top, P), it = Math.max(Q.bottom, J.bottom, it), Tt == L.LTR ? Xt.push(o && st ? f : Q.left, o && ft ? d : J.right) : Xt.push(!o && ft ? f : J.left, !o && st ? d : Q.right));
    }
    let Gt = S ?? E.from, $t = C ?? E.to;
    for (let ct of n.visibleRanges)
      if (ct.to > Gt && ct.from < $t)
        for (let st = Math.max(ct.from, Gt), gt = Math.min(ct.to, $t); ; ) {
          let ft = n.state.doc.lineAt(st);
          for (let Tt of n.bidiSpans(ft)) {
            let Q = Tt.from + ft.from, J = Tt.to + ft.from;
            if (Q >= gt)
              break;
            J > st && pi(Math.max(Q, st), S == null && Q <= Gt, Math.min(J, gt), C == null && J >= $t, Tt.dir);
          }
          if (st = ft.to + 1, st >= gt)
            break;
        }
    return Xt.length == 0 && pi(Gt, S == null, $t, C == null, n.textDirection), { top: P, bottom: it, horizontal: Xt };
  }
  function x(S, C) {
    let E = l.top + (C ? S.top : S.bottom);
    return { top: E, bottom: E, horizontal: [] };
  }
}
function hr(n, t) {
  return n.constructor == t.constructor && n.eq(t);
}
class ar {
  constructor(t, e) {
    this.view = t, this.layer = e, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = t.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), e.above && this.dom.classList.add("cm-layer-above"), e.class && this.dom.classList.add(e.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(t.state), t.requestMeasure(this.measureReq), e.mount && e.mount(this.dom, t);
  }
  update(t) {
    t.startState.facet(ce) != t.state.facet(ce) && this.setOrder(t.state), (this.layer.update(t, this.dom) || t.geometryChanged) && (this.scale(), t.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(t) {
    this.layer.updateOnDocViewUpdate !== !1 && t.requestMeasure(this.measureReq);
  }
  setOrder(t) {
    let e = 0, i = t.facet(ce);
    for (; e < i.length && i[e] != this.layer; )
      e++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - e);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: t, scaleY: e } = this.view;
    (t != this.scaleX || e != this.scaleY) && (this.scaleX = t, this.scaleY = e, this.dom.style.transform = `scale(${1 / t}, ${1 / e})`);
  }
  draw(t) {
    if (t.length != this.drawn.length || t.some((e, i) => !hr(e, this.drawn[i]))) {
      let e = this.dom.firstChild, i = 0;
      for (let s of t)
        s.update && e && s.constructor && this.drawn[i].constructor && s.update(e, this.drawn[i]) ? (e = e.nextSibling, i++) : this.dom.insertBefore(s.draw(), e);
      for (; e; ) {
        let s = e.nextSibling;
        e.remove(), e = s;
      }
      this.drawn = t;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const ce = /* @__PURE__ */ M.define();
function un(n) {
  return [
    z.define((t) => new ar(t, n)),
    ce.of(n)
  ];
}
const pn = !y.ios, Kt = /* @__PURE__ */ M.define({
  combine(n) {
    return si(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (t, e) => Math.min(t, e),
      drawRangeCursor: (t, e) => t || e
    });
  }
});
function el(n = {}) {
  return [
    Kt.of(n),
    cr,
    fr,
    dr,
    zs.of(!0)
  ];
}
function gn(n) {
  return n.startState.facet(Kt) != n.state.facet(Kt);
}
const cr = /* @__PURE__ */ un({
  above: !0,
  markers(n) {
    let { state: t } = n, e = t.facet(Kt), i = [];
    for (let s of t.selection.ranges) {
      let o = s == t.selection.main;
      if (s.empty ? !o || pn : e.drawRangeCursor) {
        let r = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = s.empty ? s : k.cursor(s.head, s.head > s.anchor ? -1 : 1);
        for (let h of _t.forRange(n, r, l))
          i.push(h);
      }
    }
    return i;
  },
  update(n, t) {
    n.transactions.some((i) => i.selection) && (t.style.animationName = t.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let e = gn(n);
    return e && Ui(n.state, t), n.docChanged || n.selectionSet || e;
  },
  mount(n, t) {
    Ui(t.state, n);
  },
  class: "cm-cursorLayer"
});
function Ui(n, t) {
  t.style.animationDuration = n.facet(Kt).cursorBlinkRate + "ms";
}
const fr = /* @__PURE__ */ un({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((t) => t.empty ? [] : _t.forRange(n, "cm-selectionBackground", t)).reduce((t, e) => t.concat(e));
  },
  update(n, t) {
    return n.docChanged || n.selectionSet || n.viewportChanged || gn(n);
  },
  class: "cm-selectionLayer"
}), Je = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
pn && (Je[".cm-line"].caretColor = Je[".cm-content"].caretColor = "transparent !important");
const dr = /* @__PURE__ */ ii.highest(/* @__PURE__ */ A.theme(Je)), mn = /* @__PURE__ */ Dt.define({
  map(n, t) {
    return n == null ? null : t.mapPos(n);
  }
}), Ht = /* @__PURE__ */ ds.define({
  create() {
    return null;
  },
  update(n, t) {
    return n != null && (n = t.changes.mapPos(n)), t.effects.reduce((e, i) => i.is(mn) ? i.value : e, n);
  }
}), ur = /* @__PURE__ */ z.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var t;
    let e = n.state.field(Ht);
    e == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(Ht) != e || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, t = n.state.field(Ht), e = t != null && n.coordsAtPos(t);
    if (!e)
      return null;
    let i = n.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - i.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: e.top - i.top + n.scrollDOM.scrollTop * n.scaleY,
      height: e.bottom - e.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: t, scaleY: e } = this.view;
      n ? (this.cursor.style.left = n.left / t + "px", this.cursor.style.top = n.top / e + "px", this.cursor.style.height = n.height / e + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(Ht) != n && this.view.dispatch({ effects: mn.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function il() {
  return [Ht, ur];
}
function Qi(n, t, e, i, s) {
  t.lastIndex = 0;
  for (let o = n.iterRange(e, i), r = e, l; !o.next().done; r += o.value.length)
    if (!o.lineBreak)
      for (; l = t.exec(o.value); )
        s(r + l.index, l);
}
function pr(n, t) {
  let e = n.visibleRanges;
  if (e.length == 1 && e[0].from == n.viewport.from && e[0].to == n.viewport.to)
    return e;
  let i = [];
  for (let { from: s, to: o } of e)
    s = Math.max(n.state.doc.lineAt(s).from, s - t), o = Math.min(n.state.doc.lineAt(o).to, o + t), i.length && i[i.length - 1].to >= s ? i[i.length - 1].to = o : i.push({ from: s, to: o });
  return i;
}
class gr {
  /**
  Create a decorator.
  */
  constructor(t) {
    const { regexp: e, decoration: i, decorate: s, boundary: o, maxLength: r = 1e3 } = t;
    if (!e.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = e, s)
      this.addMatch = (l, h, c, a) => s(a, c, c + l[0].length, l, h);
    else if (typeof i == "function")
      this.addMatch = (l, h, c, a) => {
        let f = i(l, h, c);
        f && a(c, c + l[0].length, f);
      };
    else if (i)
      this.addMatch = (l, h, c, a) => a(c, c + l[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o, this.maxLength = r;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(t) {
    let e = new An(), i = e.add.bind(e);
    for (let { from: s, to: o } of pr(t, this.maxLength))
      Qi(t.state.doc, this.regexp, s, o, (r, l) => this.addMatch(l, t, r, i));
    return e.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(t, e) {
    let i = 1e9, s = -1;
    return t.docChanged && t.changes.iterChanges((o, r, l, h) => {
      h > t.view.viewport.from && l < t.view.viewport.to && (i = Math.min(l, i), s = Math.max(h, s));
    }), t.viewportChanged || s - i > 1e3 ? this.createDeco(t.view) : s > -1 ? this.updateRange(t.view, e.map(t.changes), i, s) : e;
  }
  updateRange(t, e, i, s) {
    for (let o of t.visibleRanges) {
      let r = Math.max(o.from, i), l = Math.min(o.to, s);
      if (l > r) {
        let h = t.state.doc.lineAt(r), c = h.to < l ? t.state.doc.lineAt(l) : h, a = Math.max(o.from, h.from), f = Math.min(o.to, c.to);
        if (this.boundary) {
          for (; r > h.from; r--)
            if (this.boundary.test(h.text[r - 1 - h.from])) {
              a = r;
              break;
            }
          for (; l < c.to; l++)
            if (this.boundary.test(c.text[l - c.from])) {
              f = l;
              break;
            }
        }
        let d = [], u, p = (g, b, m) => d.push(m.range(g, b));
        if (h == c)
          for (this.regexp.lastIndex = a - h.from; (u = this.regexp.exec(h.text)) && u.index < f - h.from; )
            this.addMatch(u, t, u.index + h.from, p);
        else
          Qi(t.state.doc, this.regexp, a, f, (g, b) => this.addMatch(b, t, g, p));
        e = e.update({ filterFrom: a, filterTo: f, filter: (g, b) => g < a || b > f, add: d });
      }
    }
    return e;
  }
}
const Ze = /x/.unicode != null ? "gu" : "g", mr = /* @__PURE__ */ new RegExp(`[\0-\b
--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\uFEFFï¿¹-ï¿¼]`, Ze), br = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Oe = null;
function yr() {
  var n;
  if (Oe == null && typeof document < "u" && document.body) {
    let t = document.body.style;
    Oe = ((n = t.tabSize) !== null && n !== void 0 ? n : t.MozTabSize) != null;
  }
  return Oe || !1;
}
const fe = /* @__PURE__ */ M.define({
  combine(n) {
    let t = si(n, {
      render: null,
      specialChars: mr,
      addSpecialChars: null
    });
    return (t.replaceTabs = !yr()) && (t.specialChars = new RegExp("	|" + t.specialChars.source, Ze)), t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, Ze)), t;
  }
});
function sl(n = {}) {
  return [fe.of(n), wr()];
}
let Ji = null;
function wr() {
  return Ji || (Ji = z.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = R.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(fe)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new gr({
        regexp: n.specialChars,
        decoration: (t, e, i) => {
          let { doc: s } = e.state, o = cs(t[0], 0);
          if (o == 9) {
            let r = s.lineAt(i), l = e.state.tabSize, h = fs(r.text, l, i - r.from);
            return R.replace({
              widget: new Cr((l - h % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[o] || (this.decorationCache[o] = R.replace({ widget: new Sr(n, o) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let t = n.state.facet(fe);
      n.startState.facet(fe) != t ? (this.decorator = this.makeDecorator(t), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const xr = "â€¢";
function vr(n) {
  return n >= 32 ? xr : n == 10 ? "â¤" : String.fromCharCode(9216 + n);
}
class Sr extends Ot {
  constructor(t, e) {
    super(), this.options = t, this.code = e;
  }
  eq(t) {
    return t.code == this.code;
  }
  toDOM(t) {
    let e = vr(this.code), i = t.state.phrase("Control character") + " " + (br[this.code] || "0x" + this.code.toString(16)), s = this.options.render && this.options.render(this.code, i, e);
    if (s)
      return s;
    let o = document.createElement("span");
    return o.textContent = e, o.title = i, o.setAttribute("aria-label", i), o.className = "cm-specialChar", o;
  }
  ignoreEvent() {
    return !1;
  }
}
class Cr extends Ot {
  constructor(t) {
    super(), this.width = t;
  }
  eq(t) {
    return t.width == this.width;
  }
  toDOM() {
    let t = document.createElement("span");
    return t.textContent = "	", t.className = "cm-tab", t.style.width = this.width + "px", t;
  }
  ignoreEvent() {
    return !1;
  }
}
function nl() {
  return kr;
}
const Mr = /* @__PURE__ */ R.line({ class: "cm-activeLine" }), kr = /* @__PURE__ */ z.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let t = -1, e = [];
    for (let i of n.state.selection.ranges) {
      let s = n.lineBlockAt(i.head);
      s.from > t && (e.push(Mr.range(s.from)), t = s.from);
    }
    return R.set(e);
  }
}, {
  decorations: (n) => n.decorations
});
class Ar extends Ot {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-placeholder", t.style.pointerEvents = "none", t.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? t.setAttribute("aria-label", "placeholder " + this.content) : t.setAttribute("aria-hidden", "true"), t;
  }
  coordsAt(t) {
    let e = t.firstChild ? Ct(t.firstChild) : [];
    if (!e.length)
      return null;
    let i = window.getComputedStyle(t.parentNode), s = qt(e[0], i.direction != "rtl"), o = parseInt(i.lineHeight);
    return s.bottom - s.top > o * 1.5 ? { left: s.left, right: s.right, top: s.top, bottom: s.top + o } : s;
  }
  ignoreEvent() {
    return !1;
  }
}
function ol(n) {
  return z.fromClass(class {
    constructor(t) {
      this.view = t, this.placeholder = n ? R.set([R.widget({ widget: new Ar(n), side: 1 }).range(0)]) : R.none;
    }
    get decorations() {
      return this.view.state.doc.length ? R.none : this.placeholder;
    }
  }, { decorations: (t) => t.decorations });
}
const ti = 2e3;
function Dr(n, t, e) {
  let i = Math.min(t.line, e.line), s = Math.max(t.line, e.line), o = [];
  if (t.off > ti || e.off > ti || t.col < 0 || e.col < 0) {
    let r = Math.min(t.off, e.off), l = Math.max(t.off, e.off);
    for (let h = i; h <= s; h++) {
      let c = n.doc.line(h);
      c.length <= l && o.push(k.range(c.from + r, c.to + l));
    }
  } else {
    let r = Math.min(t.col, e.col), l = Math.max(t.col, e.col);
    for (let h = i; h <= s; h++) {
      let c = n.doc.line(h), a = Le(c.text, r, n.tabSize, !0);
      if (a < 0)
        o.push(k.cursor(c.to));
      else {
        let f = Le(c.text, l, n.tabSize);
        o.push(k.range(c.from + a, c.from + f));
      }
    }
  }
  return o;
}
function Or(n, t) {
  let e = n.coordsAtPos(n.viewport.from);
  return e ? Math.round(Math.abs((e.left - t) / n.defaultCharacterWidth)) : -1;
}
function Zi(n, t) {
  let e = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1), i = n.state.doc.lineAt(e), s = e - i.from, o = s > ti ? -1 : s == i.length ? Or(n, t.clientX) : fs(i.text, n.state.tabSize, e - i.from);
  return { line: i.number, col: o, off: s };
}
function Tr(n, t) {
  let e = Zi(n, t), i = n.state.selection;
  return e ? {
    update(s) {
      if (s.docChanged) {
        let o = s.changes.mapPos(s.startState.doc.line(e.line).from), r = s.state.doc.lineAt(o);
        e = { line: r.number, col: e.col, off: Math.min(e.off, r.length) }, i = i.map(s.changes);
      }
    },
    get(s, o, r) {
      let l = Zi(n, s);
      if (!l)
        return i;
      let h = Dr(n.state, e, l);
      return h.length ? r ? k.create(h.concat(i.ranges)) : k.create(h) : i;
    }
  } : null;
}
function rl(n) {
  let t = (e) => e.altKey && e.button == 0;
  return A.mouseSelectionStyle.of((e, i) => t(i) ? Tr(e, i) : null);
}
const Rr = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, Er = { style: "cursor: crosshair" };
function ll(n = {}) {
  let [t, e] = Rr[n.key || "Alt"], i = z.fromClass(class {
    constructor(s) {
      this.view = s, this.isDown = !1;
    }
    set(s) {
      this.isDown != s && (this.isDown = s, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(s) {
        this.set(s.keyCode == t || e(s));
      },
      keyup(s) {
        (s.keyCode == t || !e(s)) && this.set(!1);
      },
      mousemove(s) {
        this.set(e(s));
      }
    }
  });
  return [
    i,
    A.contentAttributes.of((s) => {
      var o;
      return !((o = s.plugin(i)) === null || o === void 0) && o.isDown ? Er : null;
    })
  ];
}
const Rt = "-10000px";
class bn {
  constructor(t, e, i, s) {
    this.facet = e, this.createTooltipView = i, this.removeTooltipView = s, this.input = t.state.facet(e), this.tooltips = this.input.filter((r) => r);
    let o = null;
    this.tooltipViews = this.tooltips.map((r) => o = i(r, o));
  }
  update(t, e) {
    var i;
    let s = t.state.facet(this.facet), o = s.filter((h) => h);
    if (s === this.input) {
      for (let h of this.tooltipViews)
        h.update && h.update(t);
      return !1;
    }
    let r = [], l = e ? [] : null;
    for (let h = 0; h < o.length; h++) {
      let c = o[h], a = -1;
      if (c) {
        for (let f = 0; f < this.tooltips.length; f++) {
          let d = this.tooltips[f];
          d && d.create == c.create && (a = f);
        }
        if (a < 0)
          r[h] = this.createTooltipView(c, h ? r[h - 1] : null), l && (l[h] = !!c.above);
        else {
          let f = r[h] = this.tooltipViews[a];
          l && (l[h] = e[a]), f.update && f.update(t);
        }
      }
    }
    for (let h of this.tooltipViews)
      r.indexOf(h) < 0 && (this.removeTooltipView(h), (i = h.destroy) === null || i === void 0 || i.call(h));
    return e && (l.forEach((h, c) => e[c] = h), e.length = l.length), this.input = s, this.tooltips = o, this.tooltipViews = r, !0;
  }
}
function Lr(n) {
  let { win: t } = n;
  return { top: 0, left: 0, bottom: t.innerHeight, right: t.innerWidth };
}
const Te = /* @__PURE__ */ M.define({
  combine: (n) => {
    var t, e, i;
    return {
      position: y.ios ? "absolute" : ((t = n.find((s) => s.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((e = n.find((s) => s.parent)) === null || e === void 0 ? void 0 : e.parent) || null,
      tooltipSpace: ((i = n.find((s) => s.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || Lr
    };
  }
}), ts = /* @__PURE__ */ new WeakMap(), ui = /* @__PURE__ */ z.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = n.state.facet(Te);
    this.position = t.position, this.parent = t.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new bn(n, yn, (e, i) => this.createTooltip(e, i), (e) => {
      this.resizeObserver && this.resizeObserver.unobserve(e.dom), e.dom.remove();
    }), this.above = this.manager.tooltips.map((e) => !!e.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((e) => {
      Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(n, this.above);
    t && this.observeIntersection();
    let e = t || n.geometryChanged, i = n.state.facet(Te);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      e = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      e = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    e && this.maybeMeasure();
  }
  createTooltip(n, t) {
    let e = n.create(this.view), i = t ? t.dom : null;
    if (e.dom.classList.add("cm-tooltip"), n.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let s = document.createElement("div");
      s.className = "cm-tooltip-arrow", e.dom.appendChild(s);
    }
    return e.dom.style.position = this.position, e.dom.style.top = Rt, e.dom.style.left = "0px", this.container.insertBefore(e.dom, i), e.mount && e.mount(this.view), this.resizeObserver && this.resizeObserver.observe(e.dom), e;
  }
  destroy() {
    var n, t, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (n = i.destroy) === null || n === void 0 || n.call(i);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = this.view.dom.getBoundingClientRect(), t = 1, e = 1, i = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: s } = this.manager.tooltipViews[0];
      if (y.gecko)
        i = s.offsetParent != this.container.ownerDocument.body;
      else if (s.style.top == Rt && s.style.left == "0px") {
        let o = s.getBoundingClientRect();
        i = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (i || this.position == "absolute")
      if (this.parent) {
        let s = this.parent.getBoundingClientRect();
        s.width && s.height && (t = s.width / this.parent.offsetWidth, e = s.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: e } = this.view.viewState);
    return {
      editor: n,
      parent: this.parent ? this.container.getBoundingClientRect() : n,
      pos: this.manager.tooltips.map((s, o) => {
        let r = this.manager.tooltipViews[o];
        return r.getCoords ? r.getCoords(s.pos) : this.view.coordsAtPos(s.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: s }) => s.getBoundingClientRect()),
      space: this.view.state.facet(Te).tooltipSpace(this.view),
      scaleX: t,
      scaleY: e,
      makeAbsolute: i
    };
  }
  writeMeasure(n) {
    var t;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { editor: e, space: i, scaleX: s, scaleY: o } = n, r = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let h = this.manager.tooltips[l], c = this.manager.tooltipViews[l], { dom: a } = c, f = n.pos[l], d = n.size[l];
      if (!f || f.bottom <= Math.max(e.top, i.top) || f.top >= Math.min(e.bottom, i.bottom) || f.right < Math.max(e.left, i.left) - 0.1 || f.left > Math.min(e.right, i.right) + 0.1) {
        a.style.top = Rt;
        continue;
      }
      let u = h.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = u ? 7 : 0, g = d.right - d.left, b = (t = ts.get(c)) !== null && t !== void 0 ? t : d.bottom - d.top, m = c.offset || Pr, w = this.view.textDirection == L.LTR, v = d.width > i.right - i.left ? w ? i.left : i.right - d.width : w ? Math.max(i.left, Math.min(f.left - (u ? 14 : 0) + m.x, i.right - g)) : Math.min(Math.max(i.left, f.left - g + (u ? 14 : 0) - m.x), i.right - g), x = this.above[l];
      !h.strictSide && (x ? f.top - (d.bottom - d.top) - m.y < i.top : f.bottom + (d.bottom - d.top) + m.y > i.bottom) && x == i.bottom - f.bottom > f.top - i.top && (x = this.above[l] = !x);
      let S = (x ? f.top - i.top : i.bottom - f.bottom) - p;
      if (S < b && c.resize !== !1) {
        if (S < this.view.defaultLineHeight) {
          a.style.top = Rt;
          continue;
        }
        ts.set(c, b), a.style.height = (b = S) / o + "px";
      } else a.style.height && (a.style.height = "");
      let C = x ? f.top - b - p - m.y : f.bottom + p + m.y, E = v + g;
      if (c.overlap !== !0)
        for (let P of r)
          P.left < E && P.right > v && P.top < C + b && P.bottom > C && (C = x ? P.top - b - 2 - p : P.bottom + p + 2);
      if (this.position == "absolute" ? (a.style.top = (C - n.parent.top) / o + "px", a.style.left = (v - n.parent.left) / s + "px") : (a.style.top = C / o + "px", a.style.left = v / s + "px"), u) {
        let P = f.left + (w ? m.x : -m.x) - (v + 14 - 7);
        u.style.left = P / s + "px";
      }
      c.overlap !== !0 && r.push({ left: v, top: C, right: E, bottom: C + b }), a.classList.toggle("cm-tooltip-above", x), a.classList.toggle("cm-tooltip-below", !x), c.positioned && c.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = Rt;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), Br = /* @__PURE__ */ A.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Pr = { x: 0, y: 0 }, yn = /* @__PURE__ */ M.define({
  enables: [ui, Br]
}), ye = /* @__PURE__ */ M.define({
  combine: (n) => n.reduce((t, e) => t.concat(e), [])
});
class ve {
  // Needs to be static so that host tooltip instances always match
  static create(t) {
    return new ve(t);
  }
  constructor(t) {
    this.view = t, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new bn(t, ye, (e, i) => this.createHostedView(e, i), (e) => e.dom.remove());
  }
  createHostedView(t, e) {
    let i = t.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, e ? e.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(t) {
    for (let e of this.manager.tooltipViews)
      e.mount && e.mount(t);
    this.mounted = !0;
  }
  positioned(t) {
    for (let e of this.manager.tooltipViews)
      e.positioned && e.positioned(t);
  }
  update(t) {
    this.manager.update(t);
  }
  destroy() {
    var t;
    for (let e of this.manager.tooltipViews)
      (t = e.destroy) === null || t === void 0 || t.call(e);
  }
  passProp(t) {
    let e;
    for (let i of this.manager.tooltipViews) {
      let s = i[t];
      if (s !== void 0) {
        if (e === void 0)
          e = s;
        else if (e !== s)
          return;
      }
    }
    return e;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const Hr = /* @__PURE__ */ yn.compute([ye], (n) => {
  let t = n.facet(ye);
  return t.length === 0 ? null : {
    pos: Math.min(...t.map((e) => e.pos)),
    end: Math.max(...t.map((e) => {
      var i;
      return (i = e.end) !== null && i !== void 0 ? i : e.pos;
    })),
    create: ve.create,
    above: t[0].above,
    arrow: t.some((e) => e.arrow)
  };
});
class Nr {
  constructor(t, e, i, s, o) {
    this.view = t, this.source = e, this.field = i, this.setHover = s, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let t = Date.now() - this.lastMove.time;
    t < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: t, lastMove: e } = this, i = t.docView.nearest(e.target);
    if (!i)
      return;
    let s, o = 1;
    if (i instanceof rt)
      s = i.posAtStart;
    else {
      if (s = t.posAtCoords(e), s == null)
        return;
      let l = t.coordsAtPos(s);
      if (!l || e.y < l.top || e.y > l.bottom || e.x < l.left - t.defaultCharacterWidth || e.x > l.right + t.defaultCharacterWidth)
        return;
      let h = t.bidiSpans(t.state.doc.lineAt(s)).find((a) => a.from <= s && a.to >= s), c = h && h.dir == L.RTL ? -1 : 1;
      o = e.x < l.left ? -c : c;
    }
    let r = this.source(t, s, o);
    if (r != null && r.then) {
      let l = this.pending = { pos: s };
      r.then((h) => {
        this.pending == l && (this.pending = null, h && !(Array.isArray(h) && !h.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(h) ? h : [h]) }));
      }, (h) => U(t.state, h, "hover tooltip"));
    } else r && !(Array.isArray(r) && !r.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(r) ? r : [r]) });
  }
  get tooltip() {
    let t = this.view.plugin(ui), e = t ? t.manager.tooltips.findIndex((i) => i.create == ve.create) : -1;
    return e > -1 ? t.manager.tooltipViews[e] : null;
  }
  mousemove(t) {
    var e, i;
    this.lastMove = { x: t.clientX, y: t.clientY, target: t.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: s, tooltip: o } = this;
    if (s.length && o && !Vr(o.dom, t) || this.pending) {
      let { pos: r } = s[0] || this.pending, l = (i = (e = s[0]) === null || e === void 0 ? void 0 : e.end) !== null && i !== void 0 ? i : r;
      (r == l ? this.view.posAtCoords(this.lastMove) != r : !Fr(this.view, r, l, t.clientX, t.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(t) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: e } = this;
    if (e.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(t.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(t) {
    let e = (i) => {
      t.removeEventListener("mouseleave", e), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    t.addEventListener("mouseleave", e);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const oe = 4;
function Vr(n, t) {
  let { left: e, right: i, top: s, bottom: o } = n.getBoundingClientRect(), r;
  if (r = n.querySelector(".cm-tooltip-arrow")) {
    let l = r.getBoundingClientRect();
    s = Math.min(l.top, s), o = Math.max(l.bottom, o);
  }
  return t.clientX >= e - oe && t.clientX <= i + oe && t.clientY >= s - oe && t.clientY <= o + oe;
}
function Fr(n, t, e, i, s, o) {
  let r = n.scrollDOM.getBoundingClientRect(), l = n.documentTop + n.documentPadding.top + n.contentHeight;
  if (r.left > i || r.right < i || r.top > s || Math.min(r.bottom, l) < s)
    return !1;
  let h = n.posAtCoords({ x: i, y: s }, !1);
  return h >= t && h <= e;
}
function hl(n, t = {}) {
  let e = Dt.define(), i = ds.define({
    create() {
      return [];
    },
    update(s, o) {
      if (s.length && (t.hideOnChange && (o.docChanged || o.selection) ? s = [] : t.hideOn && (s = s.filter((r) => !t.hideOn(o, r))), o.docChanged)) {
        let r = [];
        for (let l of s) {
          let h = o.changes.mapPos(l.pos, -1, wt.TrackDel);
          if (h != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), l);
            c.pos = h, c.end != null && (c.end = o.changes.mapPos(c.end)), r.push(c);
          }
        }
        s = r;
      }
      for (let r of o.effects)
        r.is(e) && (s = r.value), r.is(Wr) && (s = []);
      return s;
    },
    provide: (s) => ye.from(s)
  });
  return {
    active: i,
    extension: [
      i,
      z.define((s) => new Nr(
        s,
        n,
        i,
        e,
        t.hoverTime || 300
        /* Hover.Time */
      )),
      Hr
    ]
  };
}
function al(n, t) {
  let e = n.plugin(ui);
  if (!e)
    return null;
  let i = e.manager.tooltips.indexOf(t);
  return i < 0 ? null : e.manager.tooltipViews[i];
}
const Wr = /* @__PURE__ */ Dt.define(), es = /* @__PURE__ */ M.define({
  combine(n) {
    let t, e;
    for (let i of n)
      t = t || i.topContainer, e = e || i.bottomContainer;
    return { topContainer: t, bottomContainer: e };
  }
});
function cl(n, t) {
  let e = n.plugin(wn), i = e ? e.specs.indexOf(t) : -1;
  return i > -1 ? e.panels[i] : null;
}
const wn = /* @__PURE__ */ z.fromClass(class {
  constructor(n) {
    this.input = n.state.facet(ss), this.specs = this.input.filter((e) => e), this.panels = this.specs.map((e) => e(n));
    let t = n.state.facet(es);
    this.top = new re(n, !0, t.topContainer), this.bottom = new re(n, !1, t.bottomContainer), this.top.sync(this.panels.filter((e) => e.top)), this.bottom.sync(this.panels.filter((e) => !e.top));
    for (let e of this.panels)
      e.dom.classList.add("cm-panel"), e.mount && e.mount();
  }
  update(n) {
    let t = n.state.facet(es);
    this.top.container != t.topContainer && (this.top.sync([]), this.top = new re(n.view, !0, t.topContainer)), this.bottom.container != t.bottomContainer && (this.bottom.sync([]), this.bottom = new re(n.view, !1, t.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let e = n.state.facet(ss);
    if (e != this.input) {
      let i = e.filter((h) => h), s = [], o = [], r = [], l = [];
      for (let h of i) {
        let c = this.specs.indexOf(h), a;
        c < 0 ? (a = h(n.view), l.push(a)) : (a = this.panels[c], a.update && a.update(n)), s.push(a), (a.top ? o : r).push(a);
      }
      this.specs = i, this.panels = s, this.top.sync(o), this.bottom.sync(r);
      for (let h of l)
        h.dom.classList.add("cm-panel"), h.mount && h.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => A.scrollMargins.of((t) => {
    let e = t.plugin(n);
    return e && { top: e.top.scrollMargin(), bottom: e.bottom.scrollMargin() };
  })
});
class re {
  constructor(t, e, i) {
    this.view = t, this.top = e, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(t) {
    for (let e of this.panels)
      e.destroy && t.indexOf(e) < 0 && e.destroy();
    this.panels = t, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let e = this.container || this.view.dom;
      e.insertBefore(this.dom, this.top ? e.firstChild : null);
    }
    let t = this.dom.firstChild;
    for (let e of this.panels)
      if (e.dom.parentNode == this.dom) {
        for (; t != e.dom; )
          t = is(t);
        t = t.nextSibling;
      } else
        this.dom.insertBefore(e.dom, t);
    for (; t; )
      t = is(t);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let t of this.classes.split(" "))
        t && this.container.classList.remove(t);
      for (let t of (this.classes = this.view.themeClasses).split(" "))
        t && this.container.classList.add(t);
    }
  }
}
function is(n) {
  let t = n.nextSibling;
  return n.remove(), t;
}
const ss = /* @__PURE__ */ M.define({
  enables: wn
});
class at extends hs {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}
at.prototype.elementClass = "";
at.prototype.toDOM = void 0;
at.prototype.mapMode = wt.TrackBefore;
at.prototype.startSide = at.prototype.endSide = -1;
at.prototype.point = !0;
const de = /* @__PURE__ */ M.define(), zr = /* @__PURE__ */ M.define(), Ir = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => V.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Wt = /* @__PURE__ */ M.define();
function fl(n) {
  return [xn(), Wt.of(Object.assign(Object.assign({}, Ir), n))];
}
const ns = /* @__PURE__ */ M.define({
  combine: (n) => n.some((t) => t)
});
function xn(n) {
  return [
    Kr
  ];
}
const Kr = /* @__PURE__ */ z.fromClass(class {
  constructor(n) {
    this.view = n, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet(Wt).map((t) => new rs(n, t));
    for (let t of this.gutters)
      this.dom.appendChild(t.dom);
    this.fixed = !n.state.facet(ns), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  update(n) {
    if (this.updateGutters(n)) {
      let t = this.prevViewport, e = n.view.viewport, i = Math.min(t.to, e.to) - Math.max(t.from, e.from);
      this.syncGutters(i < (e.to - e.from) * 0.8);
    }
    n.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(ns) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let t = this.dom.nextSibling;
    n && this.dom.remove();
    let e = V.iter(this.view.state.facet(de), this.view.viewport.from), i = [], s = this.gutters.map((o) => new qr(o, this.view.viewport, -this.view.documentPadding.top));
    for (let o of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(o.type)) {
        let r = !0;
        for (let l of o.type)
          if (l.type == F.Text && r) {
            ei(e, i, l.from);
            for (let h of s)
              h.line(this.view, l, i);
            r = !1;
          } else if (l.widget)
            for (let h of s)
              h.widget(this.view, l);
      } else if (o.type == F.Text) {
        ei(e, i, o.from);
        for (let r of s)
          r.line(this.view, o, i);
      } else if (o.widget)
        for (let r of s)
          r.widget(this.view, o);
    for (let o of s)
      o.finish();
    n && this.view.scrollDOM.insertBefore(this.dom, t);
  }
  updateGutters(n) {
    let t = n.startState.facet(Wt), e = n.state.facet(Wt), i = n.docChanged || n.heightChanged || n.viewportChanged || !V.eq(n.startState.facet(de), n.state.facet(de), n.view.viewport.from, n.view.viewport.to);
    if (t == e)
      for (let s of this.gutters)
        s.update(n) && (i = !0);
    else {
      i = !0;
      let s = [];
      for (let o of e) {
        let r = t.indexOf(o);
        r < 0 ? s.push(new rs(this.view, o)) : (this.gutters[r].update(n), s.push(this.gutters[r]));
      }
      for (let o of this.gutters)
        o.dom.remove(), s.indexOf(o) < 0 && o.destroy();
      for (let o of s)
        this.dom.appendChild(o.dom);
      this.gutters = s;
    }
    return i;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove();
  }
}, {
  provide: (n) => A.scrollMargins.of((t) => {
    let e = t.plugin(n);
    return !e || e.gutters.length == 0 || !e.fixed ? null : t.textDirection == L.LTR ? { left: e.dom.offsetWidth * t.scaleX } : { right: e.dom.offsetWidth * t.scaleX };
  })
});
function os(n) {
  return Array.isArray(n) ? n : [n];
}
function ei(n, t, e) {
  for (; n.value && n.from <= e; )
    n.from == e && t.push(n.value), n.next();
}
class qr {
  constructor(t, e, i) {
    this.gutter = t, this.height = i, this.i = 0, this.cursor = V.iter(t.markers, e.from);
  }
  addElement(t, e, i) {
    let { gutter: s } = this, o = (e.top - this.height) / t.scaleY, r = e.height / t.scaleY;
    if (this.i == s.elements.length) {
      let l = new vn(t, r, o, i);
      s.elements.push(l), s.dom.appendChild(l.dom);
    } else
      s.elements[this.i].update(t, r, o, i);
    this.height = e.bottom, this.i++;
  }
  line(t, e, i) {
    let s = [];
    ei(this.cursor, s, e.from), i.length && (s = s.concat(i));
    let o = this.gutter.config.lineMarker(t, e, s);
    o && s.unshift(o);
    let r = this.gutter;
    s.length == 0 && !r.config.renderEmptyElements || this.addElement(t, e, s);
  }
  widget(t, e) {
    let i = this.gutter.config.widgetMarker(t, e.widget, e), s = i ? [i] : null;
    for (let o of t.state.facet(zr)) {
      let r = o(t, e.widget, e);
      r && (s || (s = [])).push(r);
    }
    s && this.addElement(t, e, s);
  }
  finish() {
    let t = this.gutter;
    for (; t.elements.length > this.i; ) {
      let e = t.elements.pop();
      t.dom.removeChild(e.dom), e.destroy();
    }
  }
}
class rs {
  constructor(t, e) {
    this.view = t, this.config = e, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in e.domEventHandlers)
      this.dom.addEventListener(i, (s) => {
        let o = s.target, r;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; )
            o = o.parentNode;
          let h = o.getBoundingClientRect();
          r = (h.top + h.bottom) / 2;
        } else
          r = s.clientY;
        let l = t.lineBlockAtHeight(r - t.documentTop);
        e.domEventHandlers[i](t, l, s) && s.preventDefault();
      });
    this.markers = os(e.markers(t)), e.initialSpacer && (this.spacer = new vn(t, 0, 0, [e.initialSpacer(t)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(t) {
    let e = this.markers;
    if (this.markers = os(this.config.markers(t.view)), this.spacer && this.config.updateSpacer) {
      let s = this.config.updateSpacer(this.spacer.markers[0], t);
      s != this.spacer.markers[0] && this.spacer.update(t.view, 0, 0, [s]);
    }
    let i = t.view.viewport;
    return !V.eq(this.markers, e, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(t) : !1);
  }
  destroy() {
    for (let t of this.elements)
      t.destroy();
  }
}
class vn {
  constructor(t, e, i, s) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t, e, i, s);
  }
  update(t, e, i, s) {
    this.height != e && (this.height = e, this.dom.style.height = e + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), jr(this.markers, s) || this.setMarkers(t, s);
  }
  setMarkers(t, e) {
    let i = "cm-gutterElement", s = this.dom.firstChild;
    for (let o = 0, r = 0; ; ) {
      let l = r, h = o < e.length ? e[o++] : null, c = !1;
      if (h) {
        let a = h.elementClass;
        a && (i += " " + a);
        for (let f = r; f < this.markers.length; f++)
          if (this.markers[f].compare(h)) {
            l = f, c = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; r < l; ) {
        let a = this.markers[r++];
        if (a.toDOM) {
          a.destroy(s);
          let f = s.nextSibling;
          s.remove(), s = f;
        }
      }
      if (!h)
        break;
      h.toDOM && (c ? s = s.nextSibling : this.dom.insertBefore(h.toDOM(t), s)), c && r++;
    }
    this.dom.className = i, this.markers = e;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function jr(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++)
    if (!n[e].compare(t[e]))
      return !1;
  return !0;
}
const Yr = /* @__PURE__ */ M.define(), _r = /* @__PURE__ */ M.define(), yt = /* @__PURE__ */ M.define({
  combine(n) {
    return si(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(t, e) {
        let i = Object.assign({}, t);
        for (let s in e) {
          let o = i[s], r = e[s];
          i[s] = o ? (l, h, c) => o(l, h, c) || r(l, h, c) : r;
        }
        return i;
      }
    });
  }
});
class Re extends at {
  constructor(t) {
    super(), this.number = t;
  }
  eq(t) {
    return this.number == t.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Ee(n, t) {
  return n.state.facet(yt).formatNumber(t, n.state);
}
const Xr = /* @__PURE__ */ Wt.compute([yt], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(t) {
    return t.state.facet(Yr);
  },
  lineMarker(t, e, i) {
    return i.some((s) => s.toDOM) ? null : new Re(Ee(t, t.state.doc.lineAt(e.from).number));
  },
  widgetMarker: (t, e, i) => {
    for (let s of t.state.facet(_r)) {
      let o = s(t, e, i);
      if (o)
        return o;
    }
    return null;
  },
  lineMarkerChange: (t) => t.startState.facet(yt) != t.state.facet(yt),
  initialSpacer(t) {
    return new Re(Ee(t, ls(t.state.doc.lines)));
  },
  updateSpacer(t, e) {
    let i = Ee(e.view, ls(e.view.state.doc.lines));
    return i == t.number ? t : new Re(i);
  },
  domEventHandlers: n.facet(yt).domEventHandlers
}));
function dl(n = {}) {
  return [
    yt.of(n),
    xn(),
    Xr
  ];
}
function ls(n) {
  let t = 9;
  for (; t < n; )
    t = t * 10 + 9;
  return t;
}
const Gr = /* @__PURE__ */ new class extends at {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), $r = /* @__PURE__ */ de.compute(["selection"], (n) => {
  let t = [], e = -1;
  for (let i of n.selection.ranges) {
    let s = n.doc.lineAt(i.head).from;
    s > e && (e = s, t.push(Gr.range(s)));
  }
  return V.of(t);
});
function ul() {
  return $r;
}
export {
  lt as BidiSpan,
  $ as BlockInfo,
  F as BlockType,
  R as Decoration,
  L as Direction,
  A as EditorView,
  at as GutterMarker,
  gr as MatchDecorator,
  _t as RectangleMarker,
  z as ViewPlugin,
  ge as ViewUpdate,
  Ot as WidgetType,
  ll as crosshairCursor,
  el as drawSelection,
  il as dropCursor,
  cl as getPanel,
  al as getTooltip,
  fl as gutter,
  de as gutterLineClass,
  zr as gutterWidgetClass,
  xn as gutters,
  nl as highlightActiveLine,
  ul as highlightActiveLineGutter,
  sl as highlightSpecialChars,
  hl as hoverTooltip,
  nr as keymap,
  un as layer,
  Yr as lineNumberMarkers,
  _r as lineNumberWidgetMarker,
  dl as lineNumbers,
  U as logException,
  ol as placeholder,
  rl as rectangularSelection,
  tl as runScopeHandlers,
  ss as showPanel,
  yn as showTooltip
};
//# sourceMappingURL=index.mjs.map
