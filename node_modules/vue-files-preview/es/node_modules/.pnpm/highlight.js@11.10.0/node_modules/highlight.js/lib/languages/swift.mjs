var O, X;
function Ie() {
  if (X) return O;
  X = 1;
  function D(t) {
    return t ? typeof t == "string" ? t : t.source : null;
  }
  function E(t) {
    return e("(?=", t, ")");
  }
  function e(...t) {
    return t.map((A) => D(A)).join("");
  }
  function H(t) {
    const o = t[t.length - 1];
    return typeof o == "object" && o.constructor === Object ? (t.splice(t.length - 1, 1), o) : {};
  }
  function s(...t) {
    return "(" + (H(t).capture ? "" : "?:") + t.map((c) => D(c)).join("|") + ")";
  }
  const y = (t) => e(
    /\b/,
    t,
    /\w$/.test(t) ? /\b/ : /\B/
  ), V = [
    "Protocol",
    // contextual
    "Type"
    // contextual
  ].map(y), v = [
    "init",
    "self"
  ].map(y), z = [
    "Any",
    "Self"
  ], _ = [
    // strings below will be fed into the regular `keywords` engine while regex
    // will result in additional modes being created to scan for those keywords to
    // avoid conflicts with other rules
    "actor",
    "any",
    // contextual
    "associatedtype",
    "async",
    "await",
    /as\?/,
    // operator
    /as!/,
    // operator
    "as",
    // operator
    "borrowing",
    // contextual
    "break",
    "case",
    "catch",
    "class",
    "consume",
    // contextual
    "consuming",
    // contextual
    "continue",
    "convenience",
    // contextual
    "copy",
    // contextual
    "default",
    "defer",
    "deinit",
    "didSet",
    // contextual
    "distributed",
    "do",
    "dynamic",
    // contextual
    "each",
    "else",
    "enum",
    "extension",
    "fallthrough",
    /fileprivate\(set\)/,
    "fileprivate",
    "final",
    // contextual
    "for",
    "func",
    "get",
    // contextual
    "guard",
    "if",
    "import",
    "indirect",
    // contextual
    "infix",
    // contextual
    /init\?/,
    /init!/,
    "inout",
    /internal\(set\)/,
    "internal",
    "in",
    "is",
    // operator
    "isolated",
    // contextual
    "nonisolated",
    // contextual
    "lazy",
    // contextual
    "let",
    "macro",
    "mutating",
    // contextual
    "nonmutating",
    // contextual
    /open\(set\)/,
    // contextual
    "open",
    // contextual
    "operator",
    "optional",
    // contextual
    "override",
    // contextual
    "package",
    "postfix",
    // contextual
    "precedencegroup",
    "prefix",
    // contextual
    /private\(set\)/,
    "private",
    "protocol",
    /public\(set\)/,
    "public",
    "repeat",
    "required",
    // contextual
    "rethrows",
    "return",
    "set",
    // contextual
    "some",
    // contextual
    "static",
    "struct",
    "subscript",
    "super",
    "switch",
    "throws",
    "throw",
    /try\?/,
    // operator
    /try!/,
    // operator
    "try",
    // operator
    "typealias",
    /unowned\(safe\)/,
    // contextual
    /unowned\(unsafe\)/,
    // contextual
    "unowned",
    // contextual
    "var",
    "weak",
    // contextual
    "where",
    "while",
    "willSet"
    // contextual
  ], P = [
    "false",
    "nil",
    "true"
  ], Z = [
    "assignment",
    "associativity",
    "higherThan",
    "left",
    "lowerThan",
    "none",
    "right"
  ], J = [
    "#colorLiteral",
    "#column",
    "#dsohandle",
    "#else",
    "#elseif",
    "#endif",
    "#error",
    "#file",
    "#fileID",
    "#fileLiteral",
    "#filePath",
    "#function",
    "#if",
    "#imageLiteral",
    "#keyPath",
    "#line",
    "#selector",
    "#sourceLocation",
    "#warning"
  ], B = [
    "abs",
    "all",
    "any",
    "assert",
    "assertionFailure",
    "debugPrint",
    "dump",
    "fatalError",
    "getVaList",
    "isKnownUniquelyReferenced",
    "max",
    "min",
    "numericCast",
    "pointwiseMax",
    "pointwiseMin",
    "precondition",
    "preconditionFailure",
    "print",
    "readLine",
    "repeatElement",
    "sequence",
    "stride",
    "swap",
    "swift_unboxFromSwiftValueWithType",
    "transcode",
    "type",
    "unsafeBitCast",
    "unsafeDowncast",
    "withExtendedLifetime",
    "withUnsafeMutablePointer",
    "withUnsafePointer",
    "withVaList",
    "withoutActuallyEscaping",
    "zip"
  ], L = s(
    /[/=\-+!*%<>&|^~?]/,
    /[\u00A1-\u00A7]/,
    /[\u00A9\u00AB]/,
    /[\u00AC\u00AE]/,
    /[\u00B0\u00B1]/,
    /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
    /[\u2016-\u2017]/,
    /[\u2020-\u2027]/,
    /[\u2030-\u203E]/,
    /[\u2041-\u2053]/,
    /[\u2055-\u205E]/,
    /[\u2190-\u23FF]/,
    /[\u2500-\u2775]/,
    /[\u2794-\u2BFF]/,
    /[\u2E00-\u2E7F]/,
    /[\u3001-\u3003]/,
    /[\u3008-\u3020]/,
    /[\u3030]/
  ), M = s(
    L,
    /[\u0300-\u036F]/,
    /[\u1DC0-\u1DFF]/,
    /[\u20D0-\u20FF]/,
    /[\uFE00-\uFE0F]/,
    /[\uFE20-\uFE2F]/
    // TODO: The following characters are also allowed, but the regex isn't supported yet.
    // /[\u{E0100}-\u{E01EF}]/u
  ), w = e(L, M, "*"), k = s(
    /[a-zA-Z_]/,
    /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
    /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
    /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
    /[\u1E00-\u1FFF]/,
    /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
    /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
    /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
    /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
    /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
    /[\uFE47-\uFEFE\uFF00-\uFFFD]/
    // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
    // The following characters are also allowed, but the regexes aren't supported yet.
    // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
    // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
    // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
    // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
  ), F = s(
    k,
    /\d/,
    /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
  ), a = e(k, F, "*"), b = e(/[A-Z]/, F, "*"), Q = [
    "attached",
    "autoclosure",
    e(/convention\(/, s("swift", "block", "c"), /\)/),
    "discardableResult",
    "dynamicCallable",
    "dynamicMemberLookup",
    "escaping",
    "freestanding",
    "frozen",
    "GKInspectable",
    "IBAction",
    "IBDesignable",
    "IBInspectable",
    "IBOutlet",
    "IBSegueAction",
    "inlinable",
    "main",
    "nonobjc",
    "NSApplicationMain",
    "NSCopying",
    "NSManaged",
    e(/objc\(/, a, /\)/),
    "objc",
    "objcMembers",
    "propertyWrapper",
    "requires_stored_property_inits",
    "resultBuilder",
    "Sendable",
    "testable",
    "UIApplicationMain",
    "unchecked",
    "unknown",
    "usableFromInline",
    "warn_unqualified_access"
  ], ee = [
    "iOS",
    "iOSApplicationExtension",
    "macOS",
    "macOSApplicationExtension",
    "macCatalyst",
    "macCatalystApplicationExtension",
    "watchOS",
    "watchOSApplicationExtension",
    "tvOS",
    "tvOSApplicationExtension",
    "swift"
  ];
  function ne(t) {
    const o = {
      match: /\s+/,
      relevance: 0
    }, A = t.COMMENT(
      "/\\*",
      "\\*/",
      { contains: ["self"] }
    ), c = [
      t.C_LINE_COMMENT_MODE,
      A
    ], te = {
      match: [
        /\./,
        s(...V, ...v)
      ],
      className: { 2: "keyword" }
    }, se = {
      // Consume .keyword to prevent highlighting properties and methods as keywords.
      match: e(/\./, s(..._)),
      relevance: 0
    }, ae = _.filter((n) => typeof n == "string").concat(["_|0"]), oe = _.filter((n) => typeof n != "string").concat(z).map(y), ce = { variants: [
      {
        className: "keyword",
        match: s(...oe, ...v)
      }
    ] }, i = {
      $pattern: s(
        /\b\w+/,
        // regular keywords
        /#\w+/
        // number keywords
      ),
      keyword: ae.concat(J),
      literal: P
    }, r = [
      te,
      se,
      ce
    ], ie = {
      // Consume .built_in to prevent highlighting properties and methods.
      match: e(/\./, s(...B)),
      relevance: 0
    }, re = {
      className: "built_in",
      match: e(/\b/, s(...B), /(?=\()/)
    }, I = [
      ie,
      re
    ], U = {
      // Prevent -> from being highlighting as an operator.
      match: /->/,
      relevance: 0
    }, ue = {
      className: "operator",
      relevance: 0,
      variants: [
        { match: w },
        {
          // dot-operator: only operators that start with a dot are allowed to use dots as
          // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
          // characters that may also include dots.
          match: `\\.(\\.|${M})+`
        }
      ]
    }, d = [
      U,
      ue
    ], f = "([0-9]_*)+", K = "([0-9a-fA-F]_*)+", p = {
      className: "number",
      relevance: 0,
      variants: [
        // decimal floating-point-literal (subsumes decimal-literal)
        { match: `\\b(${f})(\\.(${f}))?([eE][+-]?(${f}))?\\b` },
        // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
        { match: `\\b0x(${K})(\\.(${K}))?([pP][+-]?(${f}))?\\b` },
        // octal-literal
        { match: /\b0o([0-7]_*)+\b/ },
        // binary-literal
        { match: /\b0b([01]_*)+\b/ }
      ]
    }, x = (n = "") => ({
      className: "subst",
      variants: [
        { match: e(/\\/, n, /[0\\tnr"']/) },
        { match: e(/\\/, n, /u\{[0-9a-fA-F]{1,8}\}/) }
      ]
    }), le = (n = "") => ({
      className: "subst",
      match: e(/\\/, n, /[\t ]*(?:[\r\n]|\r\n)/)
    }), G = (n = "") => ({
      className: "subst",
      label: "interpol",
      begin: e(/\\/, n, /\(/),
      end: /\)/
    }), h = (n = "") => ({
      begin: e(n, /"""/),
      end: e(/"""/, n),
      contains: [
        x(n),
        le(n),
        G(n)
      ]
    }), N = (n = "") => ({
      begin: e(n, /"/),
      end: e(/"/, n),
      contains: [
        x(n),
        G(n)
      ]
    }), l = {
      className: "string",
      variants: [
        h(),
        h("#"),
        h("##"),
        h("###"),
        N(),
        N("#"),
        N("##"),
        N("###")
      ]
    }, W = [
      t.BACKSLASH_ESCAPE,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [t.BACKSLASH_ESCAPE]
      }
    ], Ee = {
      begin: /\/[^\s](?=[^/\n]*\/)/,
      end: /\//,
      contains: W
    }, C = (n) => {
      const R = e(n, /\//), m = e(/\//, n);
      return {
        begin: R,
        end: m,
        contains: [
          ...W,
          {
            scope: "comment",
            begin: `#(?!.*${m})`,
            end: /$/
          }
        ]
      };
    }, $ = {
      scope: "regexp",
      variants: [
        C("###"),
        C("##"),
        C("#"),
        Ee
      ]
    }, Y = { match: e(/`/, a, /`/) }, de = {
      className: "variable",
      match: /\$\d+/
    }, pe = {
      className: "variable",
      match: `\\$${F}+`
    }, g = [
      Y,
      de,
      pe
    ], me = {
      match: /(@|#(un)?)available/,
      scope: "keyword",
      starts: { contains: [
        {
          begin: /\(/,
          end: /\)/,
          keywords: ee,
          contains: [
            ...d,
            p,
            l
          ]
        }
      ] }
    }, Fe = {
      scope: "keyword",
      match: e(/@/, s(...Q), E(s(/\(/, /\s+/)))
    }, be = {
      scope: "meta",
      match: e(/@/, a)
    }, T = [
      me,
      Fe,
      be
    ], u = {
      match: E(/\b[A-Z]/),
      relevance: 0,
      contains: [
        {
          // Common Apple frameworks, for relevance boost
          className: "type",
          match: e(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, F, "+")
        },
        {
          // Type identifier
          className: "type",
          match: b,
          relevance: 0
        },
        {
          // Optional type
          match: /[?!]+/,
          relevance: 0
        },
        {
          // Variadic parameter
          match: /\.\.\./,
          relevance: 0
        },
        {
          // Protocol composition
          match: e(/\s+&\s+/, E(b)),
          relevance: 0
        }
      ]
    }, Ae = {
      begin: /</,
      end: />/,
      keywords: i,
      contains: [
        ...c,
        ...r,
        ...T,
        U,
        u
      ]
    };
    u.contains.push(Ae);
    const fe = {
      match: e(a, /\s*:/),
      keywords: "_|0",
      relevance: 0
    }, j = {
      begin: /\(/,
      end: /\)/,
      relevance: 0,
      keywords: i,
      contains: [
        "self",
        fe,
        ...c,
        $,
        ...r,
        ...I,
        ...d,
        p,
        l,
        ...g,
        ...T,
        u
      ]
    }, S = {
      begin: /</,
      end: />/,
      keywords: "repeat each",
      contains: [
        ...c,
        u
      ]
    }, he = {
      begin: s(
        E(e(a, /\s*:/)),
        E(e(a, /\s+/, a, /\s*:/))
      ),
      end: /:/,
      relevance: 0,
      contains: [
        {
          className: "keyword",
          match: /\b_\b/
        },
        {
          className: "params",
          match: a
        }
      ]
    }, q = {
      begin: /\(/,
      end: /\)/,
      keywords: i,
      contains: [
        he,
        ...c,
        ...r,
        ...d,
        p,
        l,
        ...T,
        u,
        j
      ],
      endsParent: !0,
      illegal: /["']/
    }, Ne = {
      match: [
        /(func|macro)/,
        /\s+/,
        s(Y.match, a, w)
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        S,
        q,
        o
      ],
      illegal: [
        /\[/,
        /%/
      ]
    }, Te = {
      match: [
        /\b(?:subscript|init[?!]?)/,
        /\s*(?=[<(])/
      ],
      className: { 1: "keyword" },
      contains: [
        S,
        q,
        o
      ],
      illegal: /\[|%/
    }, Re = {
      match: [
        /operator/,
        /\s+/,
        w
      ],
      className: {
        1: "keyword",
        3: "title"
      }
    }, ye = {
      begin: [
        /precedencegroup/,
        /\s+/,
        b
      ],
      className: {
        1: "keyword",
        3: "title"
      },
      contains: [u],
      keywords: [
        ...Z,
        ...P
      ],
      end: /}/
    }, _e = {
      begin: [
        /(struct|protocol|class|extension|enum|actor)/,
        /\s+/,
        a,
        /\s*/
      ],
      beginScope: {
        1: "keyword",
        3: "title.class"
      },
      keywords: i,
      contains: [
        S,
        ...r,
        {
          begin: /:/,
          end: /\{/,
          keywords: i,
          contains: [
            {
              scope: "title.class.inherited",
              match: b
            },
            ...r
          ],
          relevance: 0
        }
      ]
    };
    for (const n of l.variants) {
      const R = n.contains.find((we) => we.label === "interpol");
      R.keywords = i;
      const m = [
        ...r,
        ...I,
        ...d,
        p,
        l,
        ...g
      ];
      R.contains = [
        ...m,
        {
          begin: /\(/,
          end: /\)/,
          contains: [
            "self",
            ...m
          ]
        }
      ];
    }
    return {
      name: "Swift",
      keywords: i,
      contains: [
        ...c,
        Ne,
        Te,
        _e,
        Re,
        ye,
        {
          beginKeywords: "import",
          end: /$/,
          contains: [...c],
          relevance: 0
        },
        $,
        ...r,
        ...I,
        ...d,
        p,
        l,
        ...g,
        ...T,
        u,
        j
      ]
    };
  }
  return O = ne, O;
}
export {
  Ie as __require
};
//# sourceMappingURL=swift.mjs.map
