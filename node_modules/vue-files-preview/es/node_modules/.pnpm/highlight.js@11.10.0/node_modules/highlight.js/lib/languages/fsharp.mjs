var I, D;
function X() {
  if (D) return I;
  D = 1;
  function v(n) {
    return new RegExp(n.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "m");
  }
  function S(n) {
    return n ? typeof n == "string" ? n : n.source : null;
  }
  function i(n) {
    return e("(?=", n, ")");
  }
  function e(...n) {
    return n.map((s) => S(s)).join("");
  }
  function w(n) {
    const o = n[n.length - 1];
    return typeof o == "object" && o.constructor === Object ? (n.splice(n.length - 1, 1), o) : {};
  }
  function t(...n) {
    return "(" + (w(n).capture ? "" : "?:") + n.map((R) => S(R)).join("|") + ")";
  }
  function U(n) {
    const o = [
      "abstract",
      "and",
      "as",
      "assert",
      "base",
      "begin",
      "class",
      "default",
      "delegate",
      "do",
      "done",
      "downcast",
      "downto",
      "elif",
      "else",
      "end",
      "exception",
      "extern",
      // "false", // literal
      "finally",
      "fixed",
      "for",
      "fun",
      "function",
      "global",
      "if",
      "in",
      "inherit",
      "inline",
      "interface",
      "internal",
      "lazy",
      "let",
      "match",
      "member",
      "module",
      "mutable",
      "namespace",
      "new",
      // "not", // built_in
      // "null", // literal
      "of",
      "open",
      "or",
      "override",
      "private",
      "public",
      "rec",
      "return",
      "static",
      "struct",
      "then",
      "to",
      // "true", // literal
      "try",
      "type",
      "upcast",
      "use",
      "val",
      "void",
      "when",
      "while",
      "with",
      "yield"
    ], s = {
      // monad builder keywords (matches before non-bang keywords)
      scope: "keyword",
      match: /\b(yield|return|let|do|match|use)!/
    }, R = [
      "if",
      "else",
      "endif",
      "line",
      "nowarn",
      "light",
      "r",
      "i",
      "I",
      "load",
      "time",
      "help",
      "quit"
    ], B = [
      "true",
      "false",
      "null",
      "Some",
      "None",
      "Ok",
      "Error",
      "infinity",
      "infinityf",
      "nan",
      "nanf"
    ], Y = [
      "__LINE__",
      "__SOURCE_DIRECTORY__",
      "__SOURCE_FILE__"
    ], k = [
      // basic types
      "bool",
      "byte",
      "sbyte",
      "int8",
      "int16",
      "int32",
      "uint8",
      "uint16",
      "uint32",
      "int",
      "uint",
      "int64",
      "uint64",
      "nativeint",
      "unativeint",
      "decimal",
      "float",
      "double",
      "float32",
      "single",
      "char",
      "string",
      "unit",
      "bigint",
      // other native types or lowercase aliases
      "option",
      "voption",
      "list",
      "array",
      "seq",
      "byref",
      "exn",
      "inref",
      "nativeptr",
      "obj",
      "outref",
      "voidptr",
      // other important FSharp types
      "Result"
    ], a = {
      keyword: o,
      literal: B,
      built_in: [
        // Somewhat arbitrary list of builtin functions and values.
        // Most of them are declared in Microsoft.FSharp.Core
        // I tried to stay relevant by adding only the most idiomatic
        // and most used symbols that are not already declared as types.
        "not",
        "ref",
        "raise",
        "reraise",
        "dict",
        "readOnlyDict",
        "set",
        "get",
        "enum",
        "sizeof",
        "typeof",
        "typedefof",
        "nameof",
        "nullArg",
        "invalidArg",
        "invalidOp",
        "id",
        "fst",
        "snd",
        "ignore",
        "lock",
        "using",
        "box",
        "unbox",
        "tryUnbox",
        "printf",
        "printfn",
        "sprintf",
        "eprintf",
        "eprintfn",
        "fprintf",
        "fprintfn",
        "failwith",
        "failwithf"
      ],
      "variable.constant": Y
    }, E = {
      variants: [
        n.COMMENT(/\(\*(?!\))/, /\*\)/, {
          contains: ["self"]
        }),
        n.C_LINE_COMMENT_MODE
      ]
    }, F = /[a-zA-Z_](\w|')*/, r = {
      scope: "variable",
      begin: /``/,
      end: /``/
    }, N = /\B('|\^)/, _ = {
      scope: "symbol",
      variants: [
        // the type name is a quoted identifier:
        { match: e(N, /``.*?``/) },
        // the type name is a normal identifier (we don't use IDENTIFIER_RE because there cannot be another apostrophe here):
        { match: e(N, n.UNDERSCORE_IDENT_RE) }
      ],
      relevance: 0
    }, b = function({ includeEqual: d }) {
      let c;
      d ? c = "!%&*+-/<=>@^|~?" : c = "!%&*+-/<>@^|~?";
      const $ = Array.from(c), M = e("[", ...$.map(v), "]"), A = t(M, /\./), q = e(A, i(A)), W = t(
        e(q, A, "*"),
        // Matches at least 2 chars operators
        e(M, "+")
        // Matches at least one char operators
      );
      return {
        scope: "operator",
        match: t(
          // symbolic operators:
          W,
          // other symbolic keywords:
          // Type casting and conversion operators:
          /:\?>/,
          /:\?/,
          /:>/,
          /:=/,
          // Reference cell assignment
          /::?/,
          // : or ::
          /\$/
        ),
        // A single $ can be used as an operator
        relevance: 0
      };
    }, m = b({ includeEqual: !0 }), x = b({ includeEqual: !1 }), g = function(d, c) {
      return {
        begin: e(
          // a type annotation is a
          d,
          // should be a colon or the 'of' keyword
          i(
            // that has to be followed by
            e(
              /\s*/,
              // optional space
              t(
                // then either of:
                /\w/,
                // word
                /'/,
                // generic type name
                /\^/,
                // generic type name
                /#/,
                // flexible type name
                /``/,
                // quoted type name
                /\(/,
                // parens type expression
                /{\|/
                // anonymous type annotation
              )
            )
          )
        ),
        beginScope: c,
        // BUG: because ending with \n is necessary for some cases, multi-line type annotations are not properly supported.
        // Examples where \n is required at the end:
        // - abstract member definitions in classes: abstract Property : int * string
        // - return type annotations: let f f' = f' () : returnTypeAnnotation
        // - record fields definitions: { A : int \n B : string }
        end: i(
          t(
            /\n/,
            /=/
          )
        ),
        relevance: 0,
        // we need the known types, and we need the type constraint keywords and literals. e.g.: when 'a : null
        keywords: n.inherit(a, { type: k }),
        contains: [
          E,
          _,
          n.inherit(r, { scope: null }),
          // match to avoid strange patterns inside that may break the parsing
          x
        ]
      };
    }, p = g(/:/, "operator"), G = g(/\bof\b/, "keyword"), H = {
      begin: [
        /(^|\s+)/,
        // prevents matching the following: `match s.stype with`
        /type/,
        /\s+/,
        F
      ],
      beginScope: {
        2: "keyword",
        4: "title.class"
      },
      end: i(/\(|=|$/),
      keywords: a,
      // match keywords in type constraints. e.g.: when 'a : null
      contains: [
        E,
        n.inherit(r, { scope: null }),
        // match to avoid strange patterns inside that may break the parsing
        _,
        {
          // For visual consistency, highlight type brackets as operators.
          scope: "operator",
          match: /<|>/
        },
        p
        // generic types can have constraints, which are type annotations. e.g. type MyType<'T when 'T : delegate<obj * string>> =
      ]
    }, C = {
      // computation expressions:
      scope: "computation-expression",
      // BUG: might conflict with record deconstruction. e.g. let f { Name = name } = name // will highlight f
      match: /\b[_a-z]\w*(?=\s*\{)/
    }, y = {
      // preprocessor directives and fsi commands:
      begin: [
        /^\s*/,
        e(/#/, t(...R)),
        /\b/
      ],
      beginScope: { 2: "meta" },
      end: i(/\s|$/)
    }, u = {
      variants: [
        n.BINARY_NUMBER_MODE,
        n.C_NUMBER_MODE
      ]
    }, f = {
      scope: "string",
      begin: /"/,
      end: /"/,
      contains: [
        n.BACKSLASH_ESCAPE
      ]
    }, O = {
      scope: "string",
      begin: /@"/,
      end: /"/,
      contains: [
        {
          match: /""/
          // escaped "
        },
        n.BACKSLASH_ESCAPE
      ]
    }, L = {
      scope: "string",
      begin: /"""/,
      end: /"""/,
      relevance: 2
    }, l = {
      scope: "subst",
      begin: /\{/,
      end: /\}/,
      keywords: a
    }, P = {
      scope: "string",
      begin: /\$"/,
      end: /"/,
      contains: [
        {
          match: /\{\{/
          // escaped {
        },
        {
          match: /\}\}/
          // escaped }
        },
        n.BACKSLASH_ESCAPE,
        l
      ]
    }, h = {
      scope: "string",
      begin: /(\$@|@\$)"/,
      end: /"/,
      contains: [
        {
          match: /\{\{/
          // escaped {
        },
        {
          match: /\}\}/
          // escaped }
        },
        {
          match: /""/
        },
        n.BACKSLASH_ESCAPE,
        l
      ]
    }, K = {
      scope: "string",
      begin: /\$"""/,
      end: /"""/,
      contains: [
        {
          match: /\{\{/
          // escaped {
        },
        {
          match: /\}\}/
          // escaped }
        },
        l
      ],
      relevance: 2
    }, T = {
      scope: "string",
      match: e(
        /'/,
        t(
          /[^\\']/,
          // either a single non escaped char...
          /\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8})/
          // ...or an escape sequence
        ),
        /'/
      )
    };
    return l.contains = [
      h,
      P,
      O,
      f,
      T,
      s,
      E,
      r,
      p,
      C,
      y,
      u,
      _,
      m
    ], {
      name: "F#",
      aliases: [
        "fs",
        "f#"
      ],
      keywords: a,
      illegal: /\/\*/,
      classNameAliases: {
        "computation-expression": "keyword"
      },
      contains: [
        s,
        {
          variants: [
            K,
            h,
            P,
            L,
            O,
            f,
            T
          ]
        },
        E,
        r,
        H,
        {
          // e.g. [<Attributes("")>] or [<``module``: MyCustomAttributeThatWorksOnModules>]
          // or [<Sealed; NoEquality; NoComparison; CompiledName("FSharpAsync`1")>]
          scope: "meta",
          begin: /\[</,
          end: />\]/,
          relevance: 2,
          contains: [
            r,
            // can contain any constant value
            L,
            O,
            f,
            T,
            u
          ]
        },
        G,
        p,
        C,
        y,
        u,
        _,
        m
      ]
    };
  }
  return I = U, I;
}
export {
  X as __require
};
//# sourceMappingURL=fsharp.mjs.map
