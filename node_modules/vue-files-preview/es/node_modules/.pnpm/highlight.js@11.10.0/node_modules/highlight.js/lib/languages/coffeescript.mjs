var i, c;
function B() {
  if (c) return i;
  c = 1;
  const E = [
    "as",
    // for exports
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    // JS handles these with a special rule
    // "get",
    // "set",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends"
  ], u = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ], l = [
    // Fundamental objects
    "Object",
    "Function",
    "Boolean",
    "Symbol",
    // numbers and dates
    "Math",
    "Date",
    "Number",
    "BigInt",
    // text
    "String",
    "RegExp",
    // Indexed collections
    "Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Int32Array",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array",
    // Keyed collections
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    // Structured data
    "ArrayBuffer",
    "SharedArrayBuffer",
    "Atomics",
    "DataView",
    "JSON",
    // Control abstraction objects
    "Promise",
    "Generator",
    "GeneratorFunction",
    "AsyncFunction",
    // Reflection
    "Reflect",
    "Proxy",
    // Internationalization
    "Intl",
    // WebAssembly
    "WebAssembly"
  ], d = [
    "Error",
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ], S = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ], A = [].concat(
    S,
    l,
    d
  );
  function f(e) {
    const g = [
      "npm",
      "print"
    ], I = [
      "yes",
      "no",
      "on",
      "off"
    ], _ = [
      "then",
      "unless",
      "until",
      "loop",
      "by",
      "when",
      "and",
      "or",
      "is",
      "isnt",
      "not"
    ], y = [
      "var",
      "const",
      "let",
      "function",
      "static"
    ], b = (N) => (m) => !N.includes(m), t = {
      keyword: E.concat(_).filter(b(y)),
      literal: u.concat(I),
      built_in: A.concat(g)
    }, n = "[A-Za-z$_][0-9A-Za-z$_]*", r = {
      className: "subst",
      begin: /#\{/,
      end: /\}/,
      keywords: t
    }, a = [
      e.BINARY_NUMBER_MODE,
      e.inherit(e.C_NUMBER_MODE, { starts: {
        end: "(\\s*/)?",
        relevance: 0
      } }),
      // a number tries to eat the following slash to prevent treating it as a regexp
      {
        className: "string",
        variants: [
          {
            begin: /'''/,
            end: /'''/,
            contains: [e.BACKSLASH_ESCAPE]
          },
          {
            begin: /'/,
            end: /'/,
            contains: [e.BACKSLASH_ESCAPE]
          },
          {
            begin: /"""/,
            end: /"""/,
            contains: [
              e.BACKSLASH_ESCAPE,
              r
            ]
          },
          {
            begin: /"/,
            end: /"/,
            contains: [
              e.BACKSLASH_ESCAPE,
              r
            ]
          }
        ]
      },
      {
        className: "regexp",
        variants: [
          {
            begin: "///",
            end: "///",
            contains: [
              r,
              e.HASH_COMMENT_MODE
            ]
          },
          {
            begin: "//[gim]{0,3}(?=\\W)",
            relevance: 0
          },
          {
            // regex can't start with space to parse x / 2 / 3 as two divisions
            // regex can't start with *, and it supports an "illegal" in the main mode
            begin: /\/(?![ *]).*?(?![\\]).\/[gim]{0,3}(?=\W)/
          }
        ]
      },
      {
        begin: "@" + n
        // relevance booster
      },
      {
        subLanguage: "javascript",
        excludeBegin: !0,
        excludeEnd: !0,
        variants: [
          {
            begin: "```",
            end: "```"
          },
          {
            begin: "`",
            end: "`"
          }
        ]
      }
    ];
    r.contains = a;
    const p = e.inherit(e.TITLE_MODE, { begin: n }), s = "(\\(.*\\)\\s*)?\\B[-=]>", o = {
      className: "params",
      begin: "\\([^\\(]",
      returnBegin: !0,
      /* We need another contained nameless mode to not have every nested
      pair of parens to be called "params" */
      contains: [
        {
          begin: /\(/,
          end: /\)/,
          keywords: t,
          contains: ["self"].concat(a)
        }
      ]
    }, R = {
      variants: [
        { match: [
          /class\s+/,
          n,
          /\s+extends\s+/,
          n
        ] },
        { match: [
          /class\s+/,
          n
        ] }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: t
    };
    return {
      name: "CoffeeScript",
      aliases: [
        "coffee",
        "cson",
        "iced"
      ],
      keywords: t,
      illegal: /\/\*/,
      contains: [
        ...a,
        e.COMMENT("###", "###"),
        e.HASH_COMMENT_MODE,
        {
          className: "function",
          begin: "^\\s*" + n + "\\s*=\\s*" + s,
          end: "[-=]>",
          returnBegin: !0,
          contains: [
            p,
            o
          ]
        },
        {
          // anonymous function start
          begin: /[:\(,=]\s*/,
          relevance: 0,
          contains: [
            {
              className: "function",
              begin: s,
              end: "[-=]>",
              returnBegin: !0,
              contains: [o]
            }
          ]
        },
        R,
        {
          begin: n + ":",
          end: ":",
          returnBegin: !0,
          returnEnd: !0,
          relevance: 0
        }
      ]
    };
  }
  return i = f, i;
}
export {
  B as __require
};
//# sourceMappingURL=coffeescript.mjs.map
