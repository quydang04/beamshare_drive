var c, b;
function $() {
  if (b) return c;
  b = 1;
  function d(e) {
    const s = "([0-9]_*)+", o = "([0-9a-fA-F]_*)+", m = "([01]_*)+", g = "([0-7]_*)+", l = "([!#$%&*+.\\/<=>?@\\\\^~-]|(?!([(),;\\[\\]`|{}]|[_:\"']))(\\p{S}|\\p{P}))", n = { variants: [
      // Double dash forms a valid comment only if it's not part of legal lexeme.
      // See: Haskell 98 report: https://www.haskell.org/onlinereport/lexemes.html
      //
      // The commented code does the job, but we can't use negative lookbehind,
      // due to poor support by Safari browser.
      // > hljs.COMMENT(`(?<!${symbol})--+(?!${symbol})`, '$'),
      // So instead, we'll add a no-markup rule before the COMMENT rule in the rules list
      // to match the problematic infix operators that contain double dash.
      e.COMMENT("--+", "$"),
      e.COMMENT(
        /\{-/,
        /-\}/,
        { contains: ["self"] }
      )
    ] }, t = {
      className: "meta",
      begin: /\{-#/,
      end: /#-\}/
    }, r = {
      className: "meta",
      begin: "^#",
      end: "$"
    }, i = {
      className: "type",
      begin: "\\b[A-Z][\\w']*",
      // TODO: other constructors (build-in, infix).
      relevance: 0
    }, a = {
      begin: "\\(",
      end: "\\)",
      illegal: '"',
      contains: [
        t,
        r,
        {
          className: "type",
          begin: "\\b[A-Z][\\w]*(\\((\\.\\.|,|\\w+)\\))?"
        },
        e.inherit(e.TITLE_MODE, { begin: "[_a-z][\\w']*" }),
        n
      ]
    }, f = {
      begin: /\{/,
      end: /\}/,
      contains: a.contains
    }, u = {
      className: "number",
      relevance: 0,
      variants: [
        // decimal floating-point-literal (subsumes decimal-literal)
        { match: `\\b(${s})(\\.(${s}))?([eE][+-]?(${s}))?\\b` },
        // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
        { match: `\\b0[xX]_*(${o})(\\.(${o}))?([pP][+-]?(${s}))?\\b` },
        // octal-literal
        { match: `\\b0[oO](${g})\\b` },
        // binary-literal
        { match: `\\b0[bB](${m})\\b` }
      ]
    };
    return {
      name: "Haskell",
      aliases: ["hs"],
      keywords: "let in if then else case of where do module import hiding qualified type data newtype deriving class instance as default infix infixl infixr foreign export ccall stdcall cplusplus jvm dotnet safe unsafe family forall mdo proc rec",
      unicodeRegex: !0,
      contains: [
        // Top-level constructions.
        {
          beginKeywords: "module",
          end: "where",
          keywords: "module where",
          contains: [
            a,
            n
          ],
          illegal: "\\W\\.|;"
        },
        {
          begin: "\\bimport\\b",
          end: "$",
          keywords: "import qualified as hiding",
          contains: [
            a,
            n
          ],
          illegal: "\\W\\.|;"
        },
        {
          className: "class",
          begin: "^(\\s*)?(class|instance)\\b",
          end: "where",
          keywords: "class family instance where",
          contains: [
            i,
            a,
            n
          ]
        },
        {
          className: "class",
          begin: "\\b(data|(new)?type)\\b",
          end: "$",
          keywords: "data family type newtype deriving",
          contains: [
            t,
            i,
            a,
            f,
            n
          ]
        },
        {
          beginKeywords: "default",
          end: "$",
          contains: [
            i,
            a,
            n
          ]
        },
        {
          beginKeywords: "infix infixl infixr",
          end: "$",
          contains: [
            e.C_NUMBER_MODE,
            n
          ]
        },
        {
          begin: "\\bforeign\\b",
          end: "$",
          keywords: "foreign import export ccall stdcall cplusplus jvm dotnet safe unsafe",
          contains: [
            i,
            e.QUOTE_STRING_MODE,
            n
          ]
        },
        {
          className: "meta",
          begin: "#!\\/usr\\/bin\\/env runhaskell",
          end: "$"
        },
        // "Whitespaces".
        t,
        r,
        // Literals and names.
        // Single characters.
        {
          scope: "string",
          begin: /'(?=\\?.')/,
          end: /'/,
          contains: [
            {
              scope: "char.escape",
              match: /\\./
            }
          ]
        },
        e.QUOTE_STRING_MODE,
        u,
        i,
        e.inherit(e.TITLE_MODE, { begin: "^[_a-z][\\w']*" }),
        // No markup, prevents infix operators from being recognized as comments.
        { begin: `(?!-)${l}--+|--+(?!-)${l}` },
        n,
        {
          // No markup, relevance booster
          begin: "->|<-"
        }
      ]
    };
  }
  return c = d, c;
}
export {
  $ as __require
};
//# sourceMappingURL=haskell.mjs.map
