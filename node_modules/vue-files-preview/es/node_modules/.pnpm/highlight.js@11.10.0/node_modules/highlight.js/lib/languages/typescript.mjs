var C, F;
function V() {
  if (F) return C;
  F = 1;
  const g = "[A-Za-z$_][0-9A-Za-z$_]*", O = [
    "as",
    // for exports
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    // JS handles these with a special rule
    // "get",
    // "set",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends"
  ], v = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ], M = [
    // Fundamental objects
    "Object",
    "Function",
    "Boolean",
    "Symbol",
    // numbers and dates
    "Math",
    "Date",
    "Number",
    "BigInt",
    // text
    "String",
    "RegExp",
    // Indexed collections
    "Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Int32Array",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array",
    // Keyed collections
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    // Structured data
    "ArrayBuffer",
    "SharedArrayBuffer",
    "Atomics",
    "DataView",
    "JSON",
    // Control abstraction objects
    "Promise",
    "Generator",
    "GeneratorFunction",
    "AsyncFunction",
    // Reflection
    "Reflect",
    "Proxy",
    // Internationalization
    "Intl",
    // WebAssembly
    "WebAssembly"
  ], w = [
    "Error",
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ], L = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ], x = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "sessionStorage",
    "module",
    "global"
    // Node.js
  ], D = [].concat(
    L,
    M,
    w
  );
  function G(n) {
    const e = n.regex, f = (a, { after: l }) => {
      const u = "</" + a[0].slice(1);
      return a.input.indexOf(u, l) !== -1;
    }, t = g, _ = {
      begin: "<>",
      end: "</>"
    }, R = /<[A-Za-z0-9\\._:-]+\s*\/>/, i = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      /**
       * @param {RegExpMatchArray} match
       * @param {CallbackResponse} response
       */
      isTrulyOpeningTag: (a, l) => {
        const u = a[0].length + a.index, m = a.input[u];
        if (
          // HTML should not include another raw `<` inside a tag
          // nested type?
          // `<Array<Array<number>>`, etc.
          m === "<" || // the , gives away that this is not HTML
          // `<T, A extends keyof T, V>`
          m === ","
        ) {
          l.ignoreMatch();
          return;
        }
        m === ">" && (f(a, { after: u }) || l.ignoreMatch());
        let I;
        const $ = a.input.substring(u);
        if (I = $.match(/^\s*=/)) {
          l.ignoreMatch();
          return;
        }
        if ((I = $.match(/^\s+extends\s+/)) && I.index === 0) {
          l.ignoreMatch();
          return;
        }
      }
    }, c = {
      $pattern: g,
      keyword: O,
      literal: v,
      built_in: D,
      "variable.language": x
    }, A = "[0-9](_?[0-9])*", o = `\\.(${A})`, E = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", S = {
      className: "number",
      variants: [
        // DecimalLiteral
        { begin: `(\\b(${E})((${o})|\\.)?|(${o}))[eE][+-]?(${A})\\b` },
        { begin: `\\b(${E})\\b((${o})\\b|\\.)?|(${o})\\b` },
        // DecimalBigIntegerLiteral
        { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
        // NonDecimalIntegerLiteral
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        // LegacyOctalIntegerLiteral (does not include underscore separators)
        // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
        { begin: "\\b0[0-7]+n?\\b" }
      ],
      relevance: 0
    }, r = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: c,
      contains: []
      // defined later
    }, s = {
      begin: ".?html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [
          n.BACKSLASH_ESCAPE,
          r
        ],
        subLanguage: "xml"
      }
    }, N = {
      begin: ".?css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [
          n.BACKSLASH_ESCAPE,
          r
        ],
        subLanguage: "css"
      }
    }, T = {
      begin: ".?gql`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [
          n.BACKSLASH_ESCAPE,
          r
        ],
        subLanguage: "graphql"
      }
    }, d = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [
        n.BACKSLASH_ESCAPE,
        r
      ]
    }, p = {
      className: "comment",
      variants: [
        n.COMMENT(
          /\/\*\*(?!\/)/,
          "\\*/",
          {
            relevance: 0,
            contains: [
              {
                begin: "(?=@[A-Za-z]+)",
                relevance: 0,
                contains: [
                  {
                    className: "doctag",
                    begin: "@[A-Za-z]+"
                  },
                  {
                    className: "type",
                    begin: "\\{",
                    end: "\\}",
                    excludeEnd: !0,
                    excludeBegin: !0,
                    relevance: 0
                  },
                  {
                    className: "variable",
                    begin: t + "(?=\\s*(-)|$)",
                    endsParent: !0,
                    relevance: 0
                  },
                  // eat spaces (not newlines) so we can find
                  // types or variables
                  {
                    begin: /(?=[^\n])\s/,
                    relevance: 0
                  }
                ]
              }
            ]
          }
        ),
        n.C_BLOCK_COMMENT_MODE,
        n.C_LINE_COMMENT_MODE
      ]
    }, B = [
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      s,
      N,
      T,
      d,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      S
      // This is intentional:
      // See https://github.com/highlightjs/highlight.js/issues/3288
      // hljs.REGEXP_MODE
    ];
    r.contains = B.concat({
      // we need to pair up {} inside our subst to prevent
      // it from ending too early by matching another }
      begin: /\{/,
      end: /\}/,
      keywords: c,
      contains: [
        "self"
      ].concat(B)
    });
    const h = [].concat(p, r.contains), y = h.concat([
      // eat recursive parens in sub expressions
      {
        begin: /(\s*)\(/,
        end: /\)/,
        keywords: c,
        contains: ["self"].concat(h)
      }
    ]), b = {
      className: "params",
      // convert this to negative lookbehind in v12
      begin: /(\s*)\(/,
      // to match the parms with 
      end: /\)/,
      excludeBegin: !0,
      excludeEnd: !0,
      keywords: c,
      contains: y
    }, z = {
      variants: [
        // class Car extends vehicle
        {
          match: [
            /class/,
            /\s+/,
            t,
            /\s+/,
            /extends/,
            /\s+/,
            e.concat(t, "(", e.concat(/\./, t), ")*")
          ],
          scope: {
            1: "keyword",
            3: "title.class",
            5: "keyword",
            7: "title.class.inherited"
          }
        },
        // class Car
        {
          match: [
            /class/,
            /\s+/,
            t
          ],
          scope: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    }, U = {
      relevance: 0,
      match: e.either(
        // Hard coded exceptions
        /\bJSON/,
        // Float32Array, OutT
        /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
        // CSSFactory, CSSFactoryT
        /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
        // FPs, FPsT
        /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
        // P
        // single letters are not highlighted
        // BLAH
        // this will be flagged as a UPPER_CASE_CONSTANT instead
      ),
      className: "title.class",
      keywords: {
        _: [
          // se we still get relevance credit for JS library classes
          ...M,
          ...w
        ]
      }
    }, H = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    }, K = {
      variants: [
        {
          match: [
            /function/,
            /\s+/,
            t,
            /(?=\s*\()/
          ]
        },
        // anonymous function
        {
          match: [
            /function/,
            /\s*(?=\()/
          ]
        }
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      label: "func.def",
      contains: [b],
      illegal: /%/
    }, Y = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    };
    function W(a) {
      return e.concat("(?!", a.join("|"), ")");
    }
    const q = {
      match: e.concat(
        /\b/,
        W([
          ...L,
          "super",
          "import"
        ].map((a) => `${a}\\s*\\(`)),
        t,
        e.lookahead(/\s*\(/)
      ),
      className: "title.function",
      relevance: 0
    }, J = {
      begin: e.concat(/\./, e.lookahead(
        e.concat(t, /(?![0-9A-Za-z$_(])/)
      )),
      end: t,
      excludeBegin: !0,
      keywords: "prototype",
      className: "property",
      relevance: 0
    }, X = {
      match: [
        /get|set/,
        /\s+/,
        t,
        /(?=\()/
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        {
          // eat to avoid empty params
          begin: /\(\)/
        },
        b
      ]
    }, P = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", Q = {
      match: [
        /const|var|let/,
        /\s+/,
        t,
        /\s*/,
        /=\s*/,
        /(async\s*)?/,
        // async is optional
        e.lookahead(P)
      ],
      keywords: "async",
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        b
      ]
    };
    return {
      name: "JavaScript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: c,
      // this will be extended by TypeScript
      exports: { PARAMS_CONTAINS: y, CLASS_REFERENCE: U },
      illegal: /#(?![$_A-z])/,
      contains: [
        n.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        H,
        n.APOS_STRING_MODE,
        n.QUOTE_STRING_MODE,
        s,
        N,
        T,
        d,
        p,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        S,
        U,
        {
          className: "attr",
          begin: t + e.lookahead(":"),
          relevance: 0
        },
        Q,
        {
          // "value" container
          begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          relevance: 0,
          contains: [
            p,
            n.REGEXP_MODE,
            {
              className: "function",
              // we have to count the parens to make sure we actually have the
              // correct bounding ( ) before the =>.  There could be any number of
              // sub-expressions inside also surrounded by parens.
              begin: P,
              returnBegin: !0,
              end: "\\s*=>",
              contains: [
                {
                  className: "params",
                  variants: [
                    {
                      begin: n.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: !0
                    },
                    {
                      begin: /(\s*)\(/,
                      end: /\)/,
                      excludeBegin: !0,
                      excludeEnd: !0,
                      keywords: c,
                      contains: y
                    }
                  ]
                }
              ]
            },
            {
              // could be a comma delimited list of params to a function call
              begin: /,/,
              relevance: 0
            },
            {
              match: /\s+/,
              relevance: 0
            },
            {
              // JSX
              variants: [
                { begin: _.begin, end: _.end },
                { match: R },
                {
                  begin: i.begin,
                  // we carefully check the opening tag to see if it truly
                  // is a tag and not a false positive
                  "on:begin": i.isTrulyOpeningTag,
                  end: i.end
                }
              ],
              subLanguage: "xml",
              contains: [
                {
                  begin: i.begin,
                  end: i.end,
                  skip: !0,
                  contains: ["self"]
                }
              ]
            }
          ]
        },
        K,
        {
          // prevent this from getting swallowed up by function
          // since they appear "function like"
          beginKeywords: "while if switch catch for"
        },
        {
          // we have to count the parens to make sure we actually have the correct
          // bounding ( ).  There could be any number of sub-expressions inside
          // also surrounded by parens.
          begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          // end parens
          returnBegin: !0,
          label: "func.def",
          contains: [
            b,
            n.inherit(n.TITLE_MODE, { begin: t, className: "title.function" })
          ]
        },
        // catch ... so it won't trigger the property rule below
        {
          match: /\.\.\./,
          relevance: 0
        },
        J,
        // hack: prevents detection of keywords in some circumstances
        // .keyword()
        // $keyword = x
        {
          match: "\\$" + t,
          relevance: 0
        },
        {
          match: [/\bconstructor(?=\s*\()/],
          className: { 1: "title.function" },
          contains: [b]
        },
        q,
        Y,
        z,
        X,
        {
          match: /\$[(.]/
          // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
        }
      ]
    };
  }
  function Z(n) {
    const e = G(n), f = g, t = [
      "any",
      "void",
      "number",
      "boolean",
      "string",
      "object",
      "never",
      "symbol",
      "bigint",
      "unknown"
    ], _ = {
      begin: [
        /namespace/,
        /\s+/,
        n.IDENT_RE
      ],
      beginScope: {
        1: "keyword",
        3: "title.class"
      }
    }, R = {
      beginKeywords: "interface",
      end: /\{/,
      excludeEnd: !0,
      keywords: {
        keyword: "interface extends",
        built_in: t
      },
      contains: [e.exports.CLASS_REFERENCE]
    }, i = {
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use strict['"]/
    }, c = [
      "type",
      // "namespace",
      "interface",
      "public",
      "private",
      "protected",
      "implements",
      "declare",
      "abstract",
      "readonly",
      "enum",
      "override",
      "satisfies"
    ], A = {
      $pattern: g,
      keyword: O.concat(c),
      literal: v,
      built_in: D.concat(t),
      "variable.language": x
    }, o = {
      className: "meta",
      begin: "@" + f
    }, E = (s, N, T) => {
      const d = s.contains.findIndex((k) => k.label === N);
      if (d === -1)
        throw new Error("can not find mode to replace");
      s.contains.splice(d, 1, T);
    };
    Object.assign(e.keywords, A), e.exports.PARAMS_CONTAINS.push(o);
    const S = e.contains.find((s) => s.className === "attr");
    e.exports.PARAMS_CONTAINS.push([
      e.exports.CLASS_REFERENCE,
      // class reference for highlighting the params types
      S
      // highlight the params key
    ]), e.contains = e.contains.concat([
      o,
      _,
      R
    ]), E(e, "shebang", n.SHEBANG()), E(e, "use_strict", i);
    const r = e.contains.find((s) => s.label === "func.def");
    return r.relevance = 0, Object.assign(e, {
      name: "TypeScript",
      aliases: [
        "ts",
        "tsx",
        "mts",
        "cts"
      ]
    }), e;
  }
  return C = Z, C;
}
export {
  V as __require
};
//# sourceMappingURL=typescript.mjs.map
