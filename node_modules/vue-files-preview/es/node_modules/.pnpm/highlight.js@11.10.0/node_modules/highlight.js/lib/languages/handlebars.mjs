var i, T;
function M() {
  if (T) return i;
  T = 1;
  function d(e) {
    const n = e.regex, a = {
      $pattern: /[\w.\/]+/,
      built_in: [
        "action",
        "bindattr",
        "collection",
        "component",
        "concat",
        "debugger",
        "each",
        "each-in",
        "get",
        "hash",
        "if",
        "in",
        "input",
        "link-to",
        "loc",
        "log",
        "lookup",
        "mut",
        "outlet",
        "partial",
        "query-params",
        "render",
        "template",
        "textarea",
        "unbound",
        "unless",
        "view",
        "with",
        "yield"
      ]
    }, A = {
      $pattern: /[\w.\/]+/,
      literal: [
        "true",
        "false",
        "undefined",
        "null"
      ]
    }, R = /""|"[^"]+"/, m = /''|'[^']+'/, r = /\[\]|\[[^\]]+\]/, _ = /[^\s!"#%&'()*+,.\/;<=>@\[\\\]^`{|}~]+/, b = /(\.|\/)/, c = n.either(
      R,
      m,
      r,
      _
    ), u = n.concat(
      n.optional(/\.|\.\/|\//),
      // relative or absolute path
      c,
      n.anyNumberOfTimes(n.concat(
        b,
        c
      ))
    ), I = n.concat(
      "(",
      r,
      "|",
      _,
      ")(?==)"
    ), t = { begin: u }, o = e.inherit(t, { keywords: A }), s = {
      begin: /\(/,
      end: /\)/
      // the "contains" is added below when all necessary sub-modes are defined
    }, g = {
      // fka "attribute-assignment", parameters of the form 'key=value'
      className: "attr",
      begin: I,
      relevance: 0,
      starts: {
        begin: /=/,
        end: /=/,
        starts: { contains: [
          e.NUMBER_MODE,
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          o,
          s
        ] }
      }
    }, O = {
      // parameters of the form '{{#with x as | y |}}...{{/with}}'
      begin: /as\s+\|/,
      keywords: { keyword: "as" },
      end: /\|/,
      contains: [
        {
          // define sub-mode in order to prevent highlighting of block-parameter named "as"
          begin: /\w+/
        }
      ]
    }, E = {
      contains: [
        e.NUMBER_MODE,
        e.QUOTE_STRING_MODE,
        e.APOS_STRING_MODE,
        O,
        g,
        o,
        s
      ],
      returnEnd: !0
      // the property "end" is defined through inheritance when the mode is used. If depends
      // on the surrounding mode, but "endsWithParent" does not work here (i.e. it includes the
      // end-token of the surrounding mode)
    }, C = e.inherit(t, {
      className: "name",
      keywords: a,
      starts: e.inherit(E, { end: /\)/ })
    });
    s.contains = [C];
    const N = e.inherit(t, {
      keywords: a,
      className: "name",
      starts: e.inherit(E, { end: /\}\}/ })
    }), S = e.inherit(t, {
      keywords: a,
      className: "name"
    }), l = e.inherit(t, {
      className: "name",
      keywords: a,
      starts: e.inherit(E, { end: /\}\}/ })
    });
    return {
      name: "Handlebars",
      aliases: [
        "hbs",
        "html.hbs",
        "html.handlebars",
        "htmlbars"
      ],
      case_insensitive: !0,
      subLanguage: "xml",
      contains: [
        {
          begin: /\\\{\{/,
          skip: !0
        },
        {
          begin: /\\\\(?=\{\{)/,
          skip: !0
        },
        e.COMMENT(/\{\{!--/, /--\}\}/),
        e.COMMENT(/\{\{!/, /\}\}/),
        {
          // open raw block "{{{{raw}}}} content not evaluated {{{{/raw}}}}"
          className: "template-tag",
          begin: /\{\{\{\{(?!\/)/,
          end: /\}\}\}\}/,
          contains: [N],
          starts: {
            end: /\{\{\{\{\//,
            returnEnd: !0,
            subLanguage: "xml"
          }
        },
        {
          // close raw block
          className: "template-tag",
          begin: /\{\{\{\{\//,
          end: /\}\}\}\}/,
          contains: [S]
        },
        {
          // open block statement
          className: "template-tag",
          begin: /\{\{#/,
          end: /\}\}/,
          contains: [N]
        },
        {
          className: "template-tag",
          begin: /\{\{(?=else\}\})/,
          end: /\}\}/,
          keywords: "else"
        },
        {
          className: "template-tag",
          begin: /\{\{(?=else if)/,
          end: /\}\}/,
          keywords: "else if"
        },
        {
          // closing block statement
          className: "template-tag",
          begin: /\{\{\//,
          end: /\}\}/,
          contains: [S]
        },
        {
          // template variable or helper-call that is NOT html-escaped
          className: "template-variable",
          begin: /\{\{\{/,
          end: /\}\}\}/,
          contains: [l]
        },
        {
          // template variable or helper-call that is html-escaped
          className: "template-variable",
          begin: /\{\{/,
          end: /\}\}/,
          contains: [l]
        }
      ]
    };
  }
  return i = d, i;
}
export {
  M as __require
};
//# sourceMappingURL=handlebars.mjs.map
