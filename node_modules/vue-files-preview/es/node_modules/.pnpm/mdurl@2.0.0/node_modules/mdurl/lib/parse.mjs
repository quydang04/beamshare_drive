function p() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const A = /^([a-z0-9.+-]+:)/i, E = /:[0-9]*$/, k = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, y = ["<", ">", '"', "`", " ", "\r", `
`, "	"], I = ["{", "}", "|", "\\", "^", "`"].concat(y), L = ["'"].concat(I), j = ["%", "/", "?", ";", "#"].concat(L), w = ["/", "?", "#"], S = 255, v = /^[+a-z0-9A-Z_-]{0,63}$/, Z = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, C = {
  javascript: !0,
  "javascript:": !0
}, H = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function _(e, h) {
  if (e && e instanceof p) return e;
  const l = new p();
  return l.parse(e, h), l;
}
p.prototype.parse = function(e, h) {
  let l, o, m, t = e;
  if (t = t.trim(), !h && e.split("#").length === 1) {
    const s = k.exec(t);
    if (s)
      return this.pathname = s[1], s[2] && (this.search = s[2]), this;
  }
  let n = A.exec(t);
  if (n && (n = n[0], l = n.toLowerCase(), this.protocol = n, t = t.substr(n.length)), (h || n || t.match(/^\/\/[^@\/]+@[^@\/]+/)) && (m = t.substr(0, 2) === "//", m && !(n && C[n]) && (t = t.substr(2), this.slashes = !0)), !C[n] && (m || n && !H[n])) {
    let s = -1;
    for (let i = 0; i < w.length; i++)
      o = t.indexOf(w[i]), o !== -1 && (s === -1 || o < s) && (s = o);
    let b, c;
    s === -1 ? c = t.lastIndexOf("@") : c = t.lastIndexOf("@", s), c !== -1 && (b = t.slice(0, c), t = t.slice(c + 1), this.auth = b), s = -1;
    for (let i = 0; i < j.length; i++)
      o = t.indexOf(j[i]), o !== -1 && (s === -1 || o < s) && (s = o);
    s === -1 && (s = t.length), t[s - 1] === ":" && s--;
    const $ = t.slice(0, s);
    t = t.slice(s), this.parseHost($), this.hostname = this.hostname || "";
    const O = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!O) {
      const i = this.hostname.split(/\./);
      for (let f = 0, z = i.length; f < z; f++) {
        const r = i[f];
        if (r && !r.match(v)) {
          let P = "";
          for (let a = 0, u = r.length; a < u; a++)
            r.charCodeAt(a) > 127 ? P += "x" : P += r[a];
          if (!P.match(v)) {
            const a = i.slice(0, f), u = i.slice(f + 1), x = r.match(Z);
            x && (a.push(x[1]), u.unshift(x[2])), u.length && (t = u.join(".") + t), this.hostname = a.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > S && (this.hostname = ""), O && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const g = t.indexOf("#");
  g !== -1 && (this.hash = t.substr(g), t = t.slice(0, g));
  const d = t.indexOf("?");
  return d !== -1 && (this.search = t.substr(d), t = t.slice(0, d)), t && (this.pathname = t), H[l] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
p.prototype.parseHost = function(e) {
  let h = E.exec(e);
  h && (h = h[0], h !== ":" && (this.port = h.substr(1)), e = e.substr(0, e.length - h.length)), e && (this.hostname = e);
};
export {
  _ as default
};
//# sourceMappingURL=parse.mjs.map
