{"version":3,"file":"parse.mjs","sources":["../../../../../../../../node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/lib/parse.mjs"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\nfunction Url () {\n  this.protocol = null\n  this.slashes = null\n  this.auth = null\n  this.port = null\n  this.hostname = null\n  this.hash = null\n  this.search = null\n  this.pathname = null\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nconst protocolPattern = /^([a-z0-9.+-]+:)/i\nconst portPattern = /:[0-9]*$/\n\n// Special case for a simple path URL\n/* eslint-disable-next-line no-useless-escape */\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/\n\n// RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\nconst delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t']\n\n// RFC 2396: characters not allowed for various reasons.\nconst unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims)\n\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\nconst autoEscape = ['\\''].concat(unwise)\n// Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\nconst nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape)\nconst hostEndingChars = ['/', '?', '#']\nconst hostnameMaxLen = 255\nconst hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/\nconst hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/\n// protocols that can allow \"unsafe\" and \"unwise\" chars.\n// protocols that never have a hostname.\nconst hostlessProtocol = {\n  javascript: true,\n  'javascript:': true\n}\n// protocols that always contain a // bit.\nconst slashedProtocol = {\n  http: true,\n  https: true,\n  ftp: true,\n  gopher: true,\n  file: true,\n  'http:': true,\n  'https:': true,\n  'ftp:': true,\n  'gopher:': true,\n  'file:': true\n}\n\nfunction urlParse (url, slashesDenoteHost) {\n  if (url && url instanceof Url) return url\n\n  const u = new Url()\n  u.parse(url, slashesDenoteHost)\n  return u\n}\n\nUrl.prototype.parse = function (url, slashesDenoteHost) {\n  let lowerProto, hec, slashes\n  let rest = url\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim()\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    const simplePath = simplePathPattern.exec(rest)\n    if (simplePath) {\n      this.pathname = simplePath[1]\n      if (simplePath[2]) {\n        this.search = simplePath[2]\n      }\n      return this\n    }\n  }\n\n  let proto = protocolPattern.exec(rest)\n  if (proto) {\n    proto = proto[0]\n    lowerProto = proto.toLowerCase()\n    this.protocol = proto\n    rest = rest.substr(proto.length)\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  /* eslint-disable-next-line no-useless-escape */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//'\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2)\n      this.slashes = true\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    let hostEnd = -1\n    for (let i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i])\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    let auth, atSign\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@')\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd)\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign)\n      rest = rest.slice(atSign + 1)\n      this.auth = auth\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1\n    for (let i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i])\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd-- }\n    const host = rest.slice(0, hostEnd)\n    rest = rest.slice(hostEnd)\n\n    // pull out port.\n    this.parseHost(host)\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || ''\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    const ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']'\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      const hostparts = this.hostname.split(/\\./)\n      for (let i = 0, l = hostparts.length; i < l; i++) {\n        const part = hostparts[i]\n        if (!part) { continue }\n        if (!part.match(hostnamePartPattern)) {\n          let newpart = ''\n          for (let j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x'\n            } else {\n              newpart += part[j]\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            const validParts = hostparts.slice(0, i)\n            const notHost = hostparts.slice(i + 1)\n            const bit = part.match(hostnamePartStart)\n            if (bit) {\n              validParts.push(bit[1])\n              notHost.unshift(bit[2])\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest\n            }\n            this.hostname = validParts.join('.')\n            break\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = ''\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2)\n    }\n  }\n\n  // chop off from the tail first.\n  const hash = rest.indexOf('#')\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash)\n    rest = rest.slice(0, hash)\n  }\n  const qm = rest.indexOf('?')\n  if (qm !== -1) {\n    this.search = rest.substr(qm)\n    rest = rest.slice(0, qm)\n  }\n  if (rest) { this.pathname = rest }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = ''\n  }\n\n  return this\n}\n\nUrl.prototype.parseHost = function (host) {\n  let port = portPattern.exec(host)\n  if (port) {\n    port = port[0]\n    if (port !== ':') {\n      this.port = port.substr(1)\n    }\n    host = host.substr(0, host.length - port.length)\n  }\n  if (host) { this.hostname = host }\n}\n\nexport default urlParse\n"],"names":["Url","protocolPattern","portPattern","simplePathPattern","delims","unwise","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","hostlessProtocol","slashedProtocol","urlParse","url","slashesDenoteHost","u","lowerProto","hec","slashes","rest","simplePath","proto","hostEnd","auth","atSign","host","ipv6Hostname","hostparts","i","l","part","newpart","j","k","validParts","notHost","bit","hash","qm","port"],"mappings":"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","x_google_ignoreList":[0]}