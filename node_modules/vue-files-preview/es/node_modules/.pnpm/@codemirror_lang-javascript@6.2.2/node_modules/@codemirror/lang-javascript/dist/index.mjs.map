{"version":3,"file":"index.mjs","sources":["../../../../../../../../../node_modules/.pnpm/@codemirror+lang-javascript@6.2.2/node_modules/@codemirror/lang-javascript/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/\nconst typescriptSnippets = /*@__PURE__*/snippets.concat([\n    /*@__PURE__*/snippetCompletion(\"interface ${name} {\\n\\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"enum ${name} {\\n\\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Block\",\n    \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def) => {\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n    ClassExpression: () => true,\n    EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n    VariableDefinition(node, def) { if (!node.matchContext(functionContext))\n        def(node, \"variable\"); },\n    TypeDefinition(node, def) { def(node, \"type\"); },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (top) {\n            top = false;\n        }\n        else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name))\n                return false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\", \"String\", \"RegExp\",\n    \"LineComment\", \"BlockComment\",\n    \"VariableDefinition\", \"TypeDefinition\", \"Label\",\n    \"PropertyDefinition\", \"PropertyName\",\n    \"PrivatePropertyDefinition\", \"PrivatePropertyName\",\n    \".\", \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for (;;) {\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return { path: path.reverse(), name };\n        }\n        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        }\n        else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n    let read = (node) => context.state.doc.sliceString(node.from, node.to);\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    }\n    else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    }\n    else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    }\n    else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return { path: [], name: read(inner) };\n    }\n    else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    }\n    else {\n        return context.explicit ? { path: [], name: \"\" } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for (let depth = 0;; depth++) {\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name))\n                continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            }\n            catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? (/^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\")\n                    : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next)\n            return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context) => {\n        let path = completionPath(context);\n        if (!path)\n            return null;\n        let target = scope;\n        for (let step of path.path) {\n            target = target[step];\n            if (!target)\n                return null;\n        }\n        let options = cache.get(target);\n        if (!options)\n            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                IfStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n                LabeledStatement: flatIndent,\n                SwitchBody: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                ArrowFunction: cx => cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": () => null,\n                \"Statement Property\": /*@__PURE__*/continuedIndent({ except: /^{/ }),\n                JSXElement(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape(context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: node => /^JSX/.test(node.name),\n    facet: /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: \"ts\" }, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nlet kwCompletion = (name) => ({ label: name, type: \"keyword\" });\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/keywords.concat(/*@__PURE__*/[\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\nand local variable completion.\n*/\nfunction javascript(config = {}) {\n    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)\n        : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: ifNotIn(dontComplete, completeFromList(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : [],\n    ]);\n}\nfunction findOpenTag(node) {\n    for (;;) {\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\")\n            return node;\n        if (node.name == \"JSXEscape\" || !node.parent)\n            return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" ||\n            ch.name == \"JSXMemberExpression\")\n            return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||\n        from != to || (text != \">\" && text != \"/\") ||\n        !javascriptLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange(range => {\n        var _a;\n        let { head } = range, around = syntaxTree(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\")\n            around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return { range, changes: { from: head, insert: `</>` } };\n        }\n        else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 &&\n                ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return { range: EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };\n            }\n        }\n        else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && openTag.name == \"JSXOpenTag\" &&\n                !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) &&\n                (name = elementName(state.doc, openTag, head)))\n                return { range, changes: { from: head, insert: `</${name}>` } };\n        }\n        return { range };\n    });\n    if (closeTags.changes.empty)\n        return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, { userEvent: \"input.complete\", scrollIntoView: true })\n    ]);\n    return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            if (desc.meta.docs.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    return (view) => {\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)) {\n            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))\n                found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });\n                }\n            }];\n    }\n    return result;\n}\n\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage, typescriptSnippets };\n"],"names":["snippets","snippetCompletion","typescriptSnippets","cache","NodeWeakMap","ScopeNodes","defID","type","node","def","id","functionContext","gatherCompletions","getScope","doc","cached","completions","top","name","IterMode","gather","c","Identifier","dontComplete","localCompletionSource","context","inner","syntaxTree","isWord","options","pos","javascriptLanguage","LRLanguage","parser","indentNodeProp","continuedIndent","flatIndent","after","closed","isCase","delimitedIndent","cx","foldNodeProp","foldInside","tree","jsxSublanguage","defineLanguageFacet","typescriptLanguage","jsxLanguage","sublanguageProp","n","tsxLanguage","kwCompletion","keywords","typescriptKeywords","javascript","config","lang","LanguageSupport","ifNotIn","completeFromList","autoCloseTags","findOpenTag","elementName","max","ch","android","EditorView","view","from","to","text","defaultInsert","base","state","closeTags","range","_a","head","around","empty","insert","EditorSelection","openTag"],"mappings":"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","x_google_ignoreList":[0]}