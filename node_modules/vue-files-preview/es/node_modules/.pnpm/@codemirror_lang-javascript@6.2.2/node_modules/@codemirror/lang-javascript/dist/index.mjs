import { parser as B } from "../../../../../@lezer_javascript@1.4.17/node_modules/@lezer/javascript/dist/index.mjs";
import { LanguageSupport as F, syntaxTree as T, LRLanguage as j, indentNodeProp as x, continuedIndent as S, flatIndent as L, delimitedIndent as N, foldNodeProp as P, foldInside as O, sublanguageProp as C, defineLanguageFacet as V } from "../../../../../@codemirror_language@6.10.2/node_modules/@codemirror/language/dist/index.mjs";
import { EditorSelection as M } from "../../../../../@codemirror_state@6.4.1/node_modules/@codemirror/state/dist/index.mjs";
import { EditorView as _ } from "../../../../../@codemirror_view@6.33.0/node_modules/@codemirror/view/dist/index.mjs";
import { ifNotIn as R, completeFromList as W, snippetCompletion as r } from "../../../../../@codemirror_autocomplete@6.18.1_@codemirror_language@6.10.2_@codemirror_state@6.4.1_@codemirr_vumhapdsayoq2s6tgtur5g4bra/node_modules/@codemirror/autocomplete/dist/index.mjs";
import { IterMode as H, NodeWeakMap as K } from "../../../../../@lezer_common@1.2.1/node_modules/@lezer/common/dist/index.mjs";
const I = [
  /* @__PURE__ */ r("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ r("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ r("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ r("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ r("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ r(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ r("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ r(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ r(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ r('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ r('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], q = /* @__PURE__ */ I.concat([
  /* @__PURE__ */ r("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ r("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ r("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), h = /* @__PURE__ */ new K(), J = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function d(e) {
  return (t, o) => {
    let n = t.node.getChild("VariableDefinition");
    return n && o(n, e), !0;
  };
}
const z = ["FunctionDeclaration"], G = {
  FunctionDeclaration: /* @__PURE__ */ d("function"),
  ClassDeclaration: /* @__PURE__ */ d("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ d("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ d("type"),
  NamespaceDeclaration: /* @__PURE__ */ d("namespace"),
  VariableDefinition(e, t) {
    e.matchContext(z) || t(e, "variable");
  },
  TypeDefinition(e, t) {
    t(e, "type");
  },
  __proto__: null
};
function X(e, t) {
  let o = h.get(t);
  if (o)
    return o;
  let n = [], l = !0;
  function u(a, s) {
    let f = e.sliceString(a.from, a.to);
    n.push({ label: f, type: s });
  }
  return t.cursor(H.IncludeAnonymous).iterate((a) => {
    if (l)
      l = !1;
    else if (a.name) {
      let s = G[a.name];
      if (s && s(a, u) || J.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let s of X(e, a.node))
        n.push(s);
      return !1;
    }
  }), h.set(t, n), n;
}
const k = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, D = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function Q(e) {
  let t = T(e.state).resolveInner(e.pos, -1);
  if (D.indexOf(t.name) > -1)
    return null;
  let o = t.name == "VariableName" || t.to - t.from < 20 && k.test(e.state.sliceDoc(t.from, t.to));
  if (!o && !e.explicit)
    return null;
  let n = [];
  for (let l = t; l; l = l.parent)
    J.has(l.name) && (n = n.concat(X(e.state.doc, l)));
  return {
    options: n,
    from: o ? t.from : e.pos,
    validFor: k
  };
}
const p = /* @__PURE__ */ j.define({
  name: "javascript",
  parser: /* @__PURE__ */ B.configure({
    props: [
      /* @__PURE__ */ x.add({
        IfStatement: /* @__PURE__ */ S({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ S({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: L,
        SwitchBody: (e) => {
          let t = e.textAfter, o = /^\s*\}/.test(t), n = /^\s*(case|default)\b/.test(t);
          return e.baseIndent + (o ? 0 : n ? 1 : 2) * e.unit;
        },
        Block: /* @__PURE__ */ N({ closing: "}" }),
        ArrowFunction: (e) => e.baseIndent + e.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ S({ except: /^{/ }),
        JSXElement(e) {
          let t = /^\s*<\//.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        JSXEscape(e) {
          let t = /\s*\}/.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(e) {
          return e.column(e.node.from) + e.unit;
        }
      }),
      /* @__PURE__ */ P.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": O,
        BlockComment(e) {
          return { from: e.from + 2, to: e.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), v = {
  test: (e) => /^JSX/.test(e.name),
  facet: /* @__PURE__ */ V({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, U = /* @__PURE__ */ p.configure({ dialect: "ts" }, "typescript"), Y = /* @__PURE__ */ p.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ C.add((e) => e.isTop ? [v] : void 0)]
}), Z = /* @__PURE__ */ p.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ C.add((e) => e.isTop ? [v] : void 0)]
}, "typescript");
let E = (e) => ({ label: e, type: "keyword" });
const A = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(E), ee = /* @__PURE__ */ A.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(E));
function pe(e = {}) {
  let t = e.jsx ? e.typescript ? Z : Y : e.typescript ? U : p, o = e.typescript ? q.concat(ee) : I.concat(A);
  return new F(t, [
    p.data.of({
      autocomplete: R(D, W(o))
    }),
    p.data.of({
      autocomplete: Q
    }),
    e.jsx ? ae : []
  ]);
}
function te(e) {
  for (; ; ) {
    if (e.name == "JSXOpenTag" || e.name == "JSXSelfClosingTag" || e.name == "JSXFragmentTag")
      return e;
    if (e.name == "JSXEscape" || !e.parent)
      return null;
    e = e.parent;
  }
}
function w(e, t, o = e.length) {
  for (let n = t == null ? void 0 : t.firstChild; n; n = n.nextSibling)
    if (n.name == "JSXIdentifier" || n.name == "JSXBuiltin" || n.name == "JSXNamespacedName" || n.name == "JSXMemberExpression")
      return e.sliceString(n.from, Math.min(n.to, o));
  return "";
}
const ne = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), ae = /* @__PURE__ */ _.inputHandler.of((e, t, o, n, l) => {
  if ((ne ? e.composing : e.compositionStarted) || e.state.readOnly || t != o || n != ">" && n != "/" || !p.isActiveAt(e.state, t, -1))
    return !1;
  let u = l(), { state: a } = u, s = a.changeByRange((f) => {
    var g;
    let { head: i } = f, c = T(a).resolveInner(i - 1, -1), y;
    if (c.name == "JSXStartTag" && (c = c.parent), !(a.doc.sliceString(i - 1, i) != n || c.name == "JSXAttributeValue" && c.to > i)) {
      if (n == ">" && c.name == "JSXFragmentTag")
        return { range: f, changes: { from: i, insert: "</>" } };
      if (n == "/" && c.name == "JSXStartCloseTag") {
        let m = c.parent, b = m.parent;
        if (b && m.from == i - 2 && ((y = w(a.doc, b.firstChild, i)) || ((g = b.firstChild) === null || g === void 0 ? void 0 : g.name) == "JSXFragmentTag")) {
          let $ = `${y}>`;
          return { range: M.cursor(i + $.length, -1), changes: { from: i, insert: $ } };
        }
      } else if (n == ">") {
        let m = te(c);
        if (m && m.name == "JSXOpenTag" && !/^\/?>|^<\//.test(a.doc.sliceString(i, i + 2)) && (y = w(a.doc, m, i)))
          return { range: f, changes: { from: i, insert: `</${y}>` } };
      }
    }
    return { range: f };
  });
  return s.changes.empty ? !1 : (e.dispatch([
    u,
    a.update(s, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
export {
  ae as autoCloseTags,
  pe as javascript,
  p as javascriptLanguage,
  Y as jsxLanguage,
  Q as localCompletionSource,
  I as snippets,
  Z as tsxLanguage,
  U as typescriptLanguage,
  q as typescriptSnippets
};
//# sourceMappingURL=index.mjs.map
