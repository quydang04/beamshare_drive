import { NodeType as Q, Tree as C, NodeProp as y, IterMode as Pe, TreeFragment as M, Parser as De } from "../../../../../@lezer_common@1.2.1/node_modules/@lezer/common/dist/index.mjs";
import { Facet as w, StateField as X, EditorState as O, StateEffect as L, RangeSet as Oe, Prec as Be, countColumn as Ie, combineConfig as le, RangeSetBuilder as ae } from "../../../../../@codemirror_state@6.4.1/node_modules/@codemirror/state/dist/index.mjs";
import { Decoration as d, Direction as _, EditorView as b, ViewPlugin as Y, logException as Me, gutter as Ne, WidgetType as fe, GutterMarker as Ee } from "../../../../../@codemirror_view@6.33.0/node_modules/@codemirror/view/dist/index.mjs";
import { tags as u, styleTags as Fe, tagHighlighter as Le, highlightTree as He } from "../../../../../@lezer_highlight@1.2.1/node_modules/@lezer/highlight/dist/index.mjs";
import { StyleModule as ee } from "../../../../../style-mod@4.1.2/node_modules/style-mod/src/style-mod.mjs";
var U;
const A = /* @__PURE__ */ new y();
function We(n) {
  return w.define({
    combine: n ? (e) => e.concat(n) : void 0
  });
}
const Re = /* @__PURE__ */ new y();
class g {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], i = "") {
    this.data = e, this.name = i, O.prototype.hasOwnProperty("tree") || Object.defineProperty(O.prototype, "tree", { get() {
      return k(this);
    } }), this.parser = t, this.extension = [
      v.of(this),
      O.languageData.of((o, s, a) => {
        let l = te(o, s, a), f = l.type.prop(A);
        if (!f)
          return [];
        let c = o.facet(f), h = l.type.prop(Re);
        if (h) {
          let m = l.resolve(s - l.from, a);
          for (let p of h)
            if (p.test(m, o)) {
              let S = o.facet(p.facet);
              return p.type == "replace" ? S : S.concat(c);
            }
        }
        return c;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return te(e, t, r).type.prop(A) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(v);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], i = (o, s) => {
      if (o.prop(A) == this.data) {
        r.push({ from: s, to: s + o.length });
        return;
      }
      let a = o.prop(y.mounted);
      if (a) {
        if (a.tree.prop(A) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + s, to: l.to + s });
          else
            r.push({ from: s, to: s + o.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (i(a.tree, a.overlay[0].from + s), r.length > l)
            return;
        }
      }
      for (let l = 0; l < o.children.length; l++) {
        let f = o.children[l];
        f instanceof C && i(f, o.positions[l] + s);
      }
    };
    return i(k(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
g.setState = /* @__PURE__ */ L.define();
function te(n, e, t) {
  let r = n.facet(v), i = k(n).topNode;
  if (!r || r.allowsNesting)
    for (let o = i; o; o = o.enter(e, t, Pe.ExcludeBuffers))
      o.type.isTop && (i = o);
  return i;
}
class G extends g {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = We(e.languageData);
    return new G(t, e.parser.configure({
      props: [A.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new G(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function k(n) {
  let e = n.field(g.state, !1);
  return e ? e.tree : C.empty;
}
class Ue {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let D = null;
class N {
  constructor(e, t, r = [], i, o, s, a, l) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new N(e, t, [], C.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new Ue(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != C.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(M.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(M.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = D;
    D = this;
    try {
      return e();
    } finally {
      D = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = ne(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: i, treeLen: o, viewport: s, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((f, c, h, m) => l.push({ fromA: f, toA: c, fromB: h, toB: m })), r = M.applyChanges(r, l), i = C.empty, o = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let f of this.skipped) {
          let c = e.mapPos(f.from, 1), h = e.mapPos(f.to, -1);
          c < h && a.push({ from: c, to: h });
        }
      }
    }
    return new N(this.parser, t, r, i, o, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: o } = this.skipped[r];
      i < e.to && o > e.from && (this.fragments = ne(this.fragments, i, o), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends De {
      createParse(t, r, i) {
        let o = i[0].from, s = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let l = D;
            if (l) {
              for (let f of i)
                l.tempSkipped.push(f);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new C(Q.none, [], [], s - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return D;
  }
}
function ne(n, e, t) {
  return M.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class P {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new P(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = N.create(e.facet(v).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new P(r);
  }
}
g.state = /* @__PURE__ */ X.define({
  create: P.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is(g.setState))
        return t.value;
    return e.startState.facet(v) != e.state.facet(v) ? P.init(e.state) : n.apply(e);
  }
});
let ce = (n) => {
  let e = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (ce = (n) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const j = typeof navigator < "u" && (!((U = navigator.scheduling) === null || U === void 0) && U.isInputPending) ? () => navigator.scheduling.isInputPending() : null, je = /* @__PURE__ */ Y.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(g.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(g.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = ce(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, o = r.field(g.state);
    if (o.tree == o.context.tree && o.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, e && !j ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = o.context.treeLen < i && r.doc.length > i + 1e3, l = o.context.work(() => j && j() || Date.now() > s, i + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: g.setState.of(new P(o.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Me(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), v = /* @__PURE__ */ w.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    g.state,
    je,
    b.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class Nt {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const $e = /* @__PURE__ */ w.define(), ue = /* @__PURE__ */ w.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function qe(n) {
  let e = n.facet(ue);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function ze(n, e) {
  let t = "", r = n.tabSize, i = n.facet(ue)[0];
  if (i == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    i = " ";
  }
  for (let o = 0; o < e; o++)
    t += i;
  return t;
}
function Ge(n, e) {
  n instanceof O && (n = new he(n));
  for (let r of n.state.facet($e)) {
    let i = r(n, e);
    if (i !== void 0)
      return i;
  }
  let t = k(n.state);
  return t.length >= e ? Ve(n, t, e) : null;
}
class he {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = qe(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
    return i != null && i >= r.from && i <= r.to ? o && i == e ? { text: "", from: e } : (t < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, t);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), o = this.countColumn(r, e - i), s = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return s > -1 && (o += s - this.countColumn(r, r.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Ie(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), o = this.options.overrideIndentation;
    if (o) {
      let s = o(i);
      if (s > -1)
        return s;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Je = /* @__PURE__ */ new y();
function Ve(n, e, t) {
  let r = e.resolveStack(t), i = r.node.enterUnfinishedNodesBefore(t);
  if (i != r.node) {
    let o = [];
    for (let s = i; s != r.node; s = s.parent)
      o.push(s);
    for (let s = o.length - 1; s >= 0; s--)
      r = { node: o[s], next: r };
  }
  return de(r, n, t);
}
function de(n, e, t) {
  for (let r = n; r; r = r.next) {
    let i = Qe(r.node);
    if (i)
      return i(Z.create(e, t, r));
  }
  return 0;
}
function Ke(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function Qe(n) {
  let e = n.type.prop(Je);
  if (e)
    return e;
  let t = n.firstChild, r;
  if (t && (r = t.type.prop(y.closedBy))) {
    let i = n.lastChild, o = i && r.indexOf(i.name) > -1;
    return (s) => pe(s, !0, 1, void 0, o && !Ke(s) ? i.from : void 0);
  }
  return n.parent == null ? Xe : null;
}
function Xe() {
  return 0;
}
class Z extends he {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Z(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (Ye(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return de(this.context.next, this.base, this.pos);
  }
}
function Ye(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function Ze(n) {
  let e = n.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let i = n.options.simulateBreak, o = n.state.doc.lineAt(t.from), s = i == null || i <= o.from ? o.to : Math.min(o.to, i);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped)
      return l.from < s ? t : null;
    a = l.to;
  }
}
function Et({ closing: n, align: e = !0, units: t = 1 }) {
  return (r) => pe(r, e, t, n);
}
function pe(n, e, t, r, i) {
  let o = n.textAfter, s = o.match(/^\s*/)[0].length, a = r && o.slice(s, s + r.length) == r || i == n.pos + s, l = e ? Ze(n) : null;
  return l ? a ? n.column(l.from) : n.column(l.to) : n.baseIndent + (a ? 0 : n.unit * t);
}
const Ft = (n) => n.baseIndent;
function Lt({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let r = n && n.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const _e = 200;
function Ht() {
  return O.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: r } = n.newSelection.main, i = t.lineAt(r);
    if (r > i.from + _e)
      return n;
    let o = t.sliceString(i.from, r);
    if (!e.some((f) => f.test(o)))
      return n;
    let { state: s } = n, a = -1, l = [];
    for (let { head: f } of s.selection.ranges) {
      let c = s.doc.lineAt(f);
      if (c.from == a)
        continue;
      a = c.from;
      let h = Ge(s, c.from);
      if (h == null)
        continue;
      let m = /^\s*/.exec(c.text)[0], p = ze(s, h);
      m != p && l.push({ from: c.from, to: c.from + m.length, insert: p });
    }
    return l.length ? [n, { changes: l, sequential: !0 }] : n;
  });
}
const et = /* @__PURE__ */ w.define(), tt = /* @__PURE__ */ new y();
function Wt(n) {
  let e = n.firstChild, t = n.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? n.to : t.from } : null;
}
function nt(n, e, t) {
  let r = k(n);
  if (r.length < t)
    return null;
  let i = r.resolveStack(t, 1), o = null;
  for (let s = i; s; s = s.next) {
    let a = s.node;
    if (a.to <= t || a.from > t)
      continue;
    if (o && a.from < e)
      break;
    let l = a.type.prop(tt);
    if (l && (a.to < r.length - 50 || r.length == n.doc.length || !rt(a))) {
      let f = l(a, n);
      f && f.from <= t && f.from >= e && f.to > t && (o = f);
    }
  }
  return o;
}
function rt(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function E(n, e, t) {
  for (let r of n.facet(et)) {
    let i = r(n, e, t);
    if (i)
      return i;
  }
  return nt(n, e, t);
}
function me(n, e) {
  let t = e.mapPos(n.from, 1), r = e.mapPos(n.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const H = /* @__PURE__ */ L.define({ map: me }), B = /* @__PURE__ */ L.define({ map: me });
function ge(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const x = /* @__PURE__ */ X.define({
  create() {
    return d.none;
  },
  update(n, e) {
    n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is(H) && !it(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(ye), i = r ? d.replace({ widget: new ct(r(e.state, t.value)) }) : re;
        n = n.update({ add: [i.range(t.value.from, t.value.to)] });
      } else t.is(B) && (n = n.update({
        filter: (r, i) => t.value.from != r || t.value.to != i,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    if (e.selection) {
      let t = !1, { head: r } = e.selection.main;
      n.between(r, r, (i, o) => {
        i < r && o > r && (t = !0);
      }), t && (n = n.update({
        filterFrom: r,
        filterTo: r,
        filter: (i, o) => o <= r || i >= r
      }));
    }
    return n;
  },
  provide: (n) => b.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (r, i) => {
      t.push(r, i);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let r = n[t++], i = n[t++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(re.range(r, i));
    }
    return d.set(e, !0);
  }
});
function F(n, e, t) {
  var r;
  let i = null;
  return (r = n.field(x, !1)) === null || r === void 0 || r.between(e, t, (o, s) => {
    (!i || i.from > o) && (i = { from: o, to: s });
  }), i;
}
function it(n, e, t) {
  let r = !1;
  return n.between(e, e, (i, o) => {
    i == e && o == t && (r = !0);
  }), r;
}
function ke(n, e) {
  return n.field(x, !1) ? e : e.concat(L.appendConfig.of(we()));
}
const ot = (n) => {
  for (let e of ge(n)) {
    let t = E(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: ke(n.state, [H.of(t), be(n, t)]) }), !0;
  }
  return !1;
}, st = (n) => {
  if (!n.state.field(x, !1))
    return !1;
  let e = [];
  for (let t of ge(n)) {
    let r = F(n.state, t.from, t.to);
    r && e.push(B.of(r), be(n, r, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function be(n, e, t = !0) {
  let r = n.state.doc.lineAt(e.from).number, i = n.state.doc.lineAt(e.to).number;
  return b.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${n.state.phrase("to")} ${i}.`);
}
const lt = (n) => {
  let { state: e } = n, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = n.lineBlockAt(r), o = E(e, i.from, i.to);
    o && t.push(H.of(o)), r = (o ? n.lineBlockAt(o.to) : i).to + 1;
  }
  return t.length && n.dispatch({ effects: ke(n.state, t) }), !!t.length;
}, at = (n) => {
  let e = n.state.field(x, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (r, i) => {
    t.push(B.of({ from: r, to: i }));
  }), n.dispatch({ effects: t }), !0;
}, Rt = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: ot },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: st },
  { key: "Ctrl-Alt-[", run: lt },
  { key: "Ctrl-Alt-]", run: at }
], ft = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, ye = /* @__PURE__ */ w.define({
  combine(n) {
    return le(n, ft);
  }
});
function we(n) {
  return [x, ht];
}
function ve(n, e) {
  let { state: t } = n, r = t.facet(ye), i = (s) => {
    let a = n.lineBlockAt(n.posAtDOM(s.target)), l = F(n.state, a.from, a.to);
    l && n.dispatch({ effects: B.of(l) }), s.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(n, i, e);
  let o = document.createElement("span");
  return o.textContent = r.placeholderText, o.setAttribute("aria-label", t.phrase("folded code")), o.title = t.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = i, o;
}
const re = /* @__PURE__ */ d.replace({ widget: /* @__PURE__ */ new class extends fe {
  toDOM(n) {
    return ve(n, null);
  }
}() });
class ct extends fe {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return ve(e, this.value);
  }
}
const ut = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class $ extends Ee {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function Ut(n = {}) {
  let e = Object.assign(Object.assign({}, ut), n), t = new $(e, !0), r = new $(e, !1), i = Y.fromClass(class {
    constructor(s) {
      this.from = s.viewport.from, this.markers = this.buildMarkers(s);
    }
    update(s) {
      (s.docChanged || s.viewportChanged || s.startState.facet(v) != s.state.facet(v) || s.startState.field(x, !1) != s.state.field(x, !1) || k(s.startState) != k(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
    }
    buildMarkers(s) {
      let a = new ae();
      for (let l of s.viewportLineBlocks) {
        let f = F(s.state, l.from, l.to) ? r : E(s.state, l.from, l.to) ? t : null;
        f && a.add(l.from, l.from, f);
      }
      return a.finish();
    }
  }), { domEventHandlers: o } = e;
  return [
    i,
    Ne({
      class: "cm-foldGutter",
      markers(s) {
        var a;
        return ((a = s.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || Oe.empty;
      },
      initialSpacer() {
        return new $(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, o), { click: (s, a, l) => {
        if (o.click && o.click(s, a, l))
          return !0;
        let f = F(s.state, a.from, a.to);
        if (f)
          return s.dispatch({ effects: B.of(f) }), !0;
        let c = E(s.state, a.from, a.to);
        return c ? (s.dispatch({ effects: H.of(c) }), !0) : !1;
      } })
    }),
    we()
  ];
}
const ht = /* @__PURE__ */ b.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class W {
  constructor(e, t) {
    this.specs = e;
    let r;
    function i(a) {
      let l = ee.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const o = typeof t.all == "string" ? t.all : t.all ? i(t.all) : void 0, s = t.scope;
    this.scope = s instanceof g ? (a) => a.prop(A) == s.data : s ? (a) => a == s : void 0, this.style = Le(e.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: o
    }).style, this.module = r ? new ee(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new W(e, t || {});
  }
}
const J = /* @__PURE__ */ w.define(), xe = /* @__PURE__ */ w.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function q(n) {
  let e = n.facet(J);
  return e.length ? e : n.facet(xe);
}
function jt(n, e) {
  let t = [pt], r;
  return n instanceof W && (n.module && t.push(b.styleModule.of(n.module)), r = n.themeType), e != null && e.fallback ? t.push(xe.of(n)) : r ? t.push(J.computeN([b.darkTheme], (i) => i.facet(b.darkTheme) == (r == "dark") ? [n] : [])) : t.push(J.of(n)), t;
}
class dt {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = k(e.state), this.decorations = this.buildDeco(e, q(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = k(e.state), r = q(e.state), i = r != q(e.startState), { viewport: o } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
    t.length < o.to && !i && t.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (t != this.tree || e.viewportChanged || i) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = o.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return d.none;
    let r = new ae();
    for (let { from: i, to: o } of e.visibleRanges)
      He(this.tree, t, (s, a, l) => {
        r.add(s, a, this.markCache[l] || (this.markCache[l] = d.mark({ class: l })));
      }, i, o);
    return r.finish();
  }
}
const pt = /* @__PURE__ */ Be.high(/* @__PURE__ */ Y.fromClass(dt, {
  decorations: (n) => n.decorations
})), $t = /* @__PURE__ */ W.define([
  {
    tag: u.meta,
    color: "#404740"
  },
  {
    tag: u.link,
    textDecoration: "underline"
  },
  {
    tag: u.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: u.emphasis,
    fontStyle: "italic"
  },
  {
    tag: u.strong,
    fontWeight: "bold"
  },
  {
    tag: u.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: u.keyword,
    color: "#708"
  },
  {
    tag: [u.atom, u.bool, u.url, u.contentSeparator, u.labelName],
    color: "#219"
  },
  {
    tag: [u.literal, u.inserted],
    color: "#164"
  },
  {
    tag: [u.string, u.deleted],
    color: "#a11"
  },
  {
    tag: [u.regexp, u.escape, /* @__PURE__ */ u.special(u.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ u.definition(u.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ u.local(u.variableName),
    color: "#30a"
  },
  {
    tag: [u.typeName, u.namespace],
    color: "#085"
  },
  {
    tag: u.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ u.special(u.variableName), u.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ u.definition(u.propertyName),
    color: "#00c"
  },
  {
    tag: u.comment,
    color: "#940"
  },
  {
    tag: u.invalid,
    color: "#f00"
  }
]), mt = /* @__PURE__ */ b.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), Se = 1e4, Te = "()[]{}", Ce = /* @__PURE__ */ w.define({
  combine(n) {
    return le(n, {
      afterCursor: !0,
      brackets: Te,
      maxScanDistance: Se,
      renderMatch: bt
    });
  }
}), gt = /* @__PURE__ */ d.mark({ class: "cm-matchingBracket" }), kt = /* @__PURE__ */ d.mark({ class: "cm-nonmatchingBracket" });
function bt(n) {
  let e = [], t = n.matched ? gt : kt;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const yt = /* @__PURE__ */ X.define({
  create() {
    return d.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], r = e.state.facet(Ce);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let o = I(e.state, i.head, -1, r) || i.head > 0 && I(e.state, i.head - 1, 1, r) || r.afterCursor && (I(e.state, i.head, 1, r) || i.head < e.state.doc.length && I(e.state, i.head + 1, -1, r));
      o && (t = t.concat(r.renderMatch(o, e.state)));
    }
    return d.set(t, !0);
  },
  provide: (n) => b.decorations.from(n)
}), wt = [
  yt,
  mt
];
function qt(n = {}) {
  return [Ce.of(n), wt];
}
const vt = /* @__PURE__ */ new y();
function V(n, e, t) {
  let r = n.prop(e < 0 ? y.openedBy : y.closedBy);
  if (r)
    return r;
  if (n.name.length == 1) {
    let i = t.indexOf(n.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [t[i + e]];
  }
  return null;
}
function K(n) {
  let e = n.type.prop(vt);
  return e ? e(n.node) : n;
}
function I(n, e, t, r = {}) {
  let i = r.maxScanDistance || Se, o = r.brackets || Te, s = k(n), a = s.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let f = V(l.type, t, o);
    if (f && l.from < l.to) {
      let c = K(l);
      if (c && (t > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return xt(n, e, t, l, c, f, o);
    }
  }
  return St(n, e, t, s, a.type, i, o);
}
function xt(n, e, t, r, i, o, s) {
  let a = r.parent, l = { from: i.from, to: i.to }, f = 0, c = a == null ? void 0 : a.cursor();
  if (c && (t < 0 ? c.childBefore(r.from) : c.childAfter(r.to)))
    do
      if (t < 0 ? c.to <= r.from : c.from >= r.to) {
        if (f == 0 && o.indexOf(c.type.name) > -1 && c.from < c.to) {
          let h = K(c);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (V(c.type, t, s))
          f++;
        else if (V(c.type, -t, s)) {
          if (f == 0) {
            let h = K(c);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          f--;
        }
      }
    while (t < 0 ? c.prevSibling() : c.nextSibling());
  return { start: l, matched: !1 };
}
function St(n, e, t, r, i, o, s) {
  let a = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), l = s.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let f = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, c = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), h = 0;
  for (let m = 0; !c.next().done && m <= o; ) {
    let p = c.value;
    t < 0 && (m += p.length);
    let S = e + m * t;
    for (let T = t > 0 ? 0 : p.length - 1, Ae = t > 0 ? p.length : -1; T != Ae; T += t) {
      let R = s.indexOf(p[T]);
      if (!(R < 0 || r.resolveInner(S + T, 1).type != i))
        if (R % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: f, end: { from: S + T, to: S + T + 1 }, matched: R >> 1 == l >> 1 };
          h--;
        }
    }
    t > 0 && (m += p.length);
  }
  return c.done ? { start: f, matched: !1 } : null;
}
const Tt = /* @__PURE__ */ Object.create(null), ie = [Q.none], oe = [], se = /* @__PURE__ */ Object.create(null), Ct = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  Ct[n] = /* @__PURE__ */ At(Tt, e);
function z(n, e) {
  oe.indexOf(n) > -1 || (oe.push(n), console.warn(e));
}
function At(n, e) {
  let t = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let f of a.split(".")) {
      let c = n[f] || u[f];
      c ? typeof c == "function" ? l.length ? l = l.map(c) : z(f, `Modifier ${f} used at start of tag`) : l.length ? z(f, `Tag ${f} used as modifier`) : l = Array.isArray(c) ? c : [c] : z(f, `Unknown highlighting tag ${f}`);
    }
    for (let f of l)
      t.push(f);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + t.map((a) => a.id), o = se[i];
  if (o)
    return o.id;
  let s = se[i] = Q.define({
    id: ie.length,
    name: r,
    props: [Fe({ [r]: t })]
  });
  return ie.push(s), s.id;
}
_.RTL, _.LTR;
export {
  Ue as DocInput,
  W as HighlightStyle,
  he as IndentContext,
  G as LRLanguage,
  g as Language,
  Nt as LanguageSupport,
  N as ParseContext,
  Z as TreeIndentContext,
  qt as bracketMatching,
  vt as bracketMatchingHandle,
  we as codeFolding,
  Lt as continuedIndent,
  $t as defaultHighlightStyle,
  We as defineLanguageFacet,
  Et as delimitedIndent,
  Ft as flatIndent,
  lt as foldAll,
  ot as foldCode,
  H as foldEffect,
  Ut as foldGutter,
  Wt as foldInside,
  Rt as foldKeymap,
  tt as foldNodeProp,
  et as foldService,
  x as foldState,
  E as foldable,
  qe as getIndentUnit,
  Ge as getIndentation,
  Je as indentNodeProp,
  Ht as indentOnInput,
  $e as indentService,
  ze as indentString,
  ue as indentUnit,
  v as language,
  A as languageDataProp,
  I as matchBrackets,
  Re as sublanguageProp,
  jt as syntaxHighlighting,
  k as syntaxTree,
  at as unfoldAll,
  st as unfoldCode,
  B as unfoldEffect
};
//# sourceMappingURL=index.mjs.map
