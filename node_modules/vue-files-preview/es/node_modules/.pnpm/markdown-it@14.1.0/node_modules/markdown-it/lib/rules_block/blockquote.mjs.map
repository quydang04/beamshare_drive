{"version":3,"file":"blockquote.mjs","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/blockquote.mjs"],"sourcesContent":["// Block quotes\n\nimport { isSpace } from '../common/utils.mjs'\n\nexport default function blockquote (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  const oldLineMax = state.lineMax\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos) !== 0x3E/* > */) { return false }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true }\n\n  const oldBMarks  = []\n  const oldBSCount = []\n  const oldSCount  = []\n  const oldTShift  = []\n\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const oldParentType = state.parentType\n  state.parentType = 'blockquote'\n  let lastLineEmpty = false\n  let nextLine\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    const isOutdented = state.sCount[nextLine] < state.blkIndent\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {\n      // This line is inside the blockquote.\n\n      // set offset past spaces and \">\"\n      let initial = state.sCount[nextLine] + 1\n      let spaceAfterMarker\n      let adjustTab\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++\n        initial++\n        adjustTab = false\n        spaceAfterMarker = true\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true\n\n        if ((state.bsCount[nextLine] + initial) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++\n          initial++\n          adjustTab = false\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true\n        }\n      } else {\n        spaceAfterMarker = false\n      }\n\n      let offset = initial\n      oldBMarks.push(state.bMarks[nextLine])\n      state.bMarks[nextLine] = pos\n\n      while (pos < max) {\n        const ch = state.src.charCodeAt(pos)\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4\n          } else {\n            offset++\n          }\n        } else {\n          break\n        }\n\n        pos++\n      }\n\n      lastLineEmpty = pos >= max\n\n      oldBSCount.push(state.bsCount[nextLine])\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0)\n\n      oldSCount.push(state.sCount[nextLine])\n      state.sCount[nextLine] = offset - initial\n\n      oldTShift.push(state.tShift[nextLine])\n      state.tShift[nextLine] = pos - state.bMarks[nextLine]\n      continue\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break }\n\n    // Case 3: another tag found.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine])\n        oldBSCount.push(state.bsCount[nextLine])\n        oldTShift.push(state.tShift[nextLine])\n        oldSCount.push(state.sCount[nextLine])\n        state.sCount[nextLine] -= state.blkIndent\n      }\n\n      break\n    }\n\n    oldBMarks.push(state.bMarks[nextLine])\n    oldBSCount.push(state.bsCount[nextLine])\n    oldTShift.push(state.tShift[nextLine])\n    oldSCount.push(state.sCount[nextLine])\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1\n  }\n\n  const oldIndent = state.blkIndent\n  state.blkIndent = 0\n\n  const token_o  = state.push('blockquote_open', 'blockquote', 1)\n  token_o.markup = '>'\n  const lines = [startLine, 0]\n  token_o.map    = lines\n\n  state.md.block.tokenize(state, startLine, nextLine)\n\n  const token_c  = state.push('blockquote_close', 'blockquote', -1)\n  token_c.markup = '>'\n\n  state.lineMax = oldLineMax\n  state.parentType = oldParentType\n  lines[1] = state.line\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (let i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i]\n    state.tShift[i + startLine] = oldTShift[i]\n    state.sCount[i + startLine] = oldSCount[i]\n    state.bsCount[i + startLine] = oldBSCount[i]\n  }\n  state.blkIndent = oldIndent\n\n  return true\n}\n"],"names":["blockquote","state","startLine","endLine","silent","pos","max","oldLineMax","oldBMarks","oldBSCount","oldSCount","oldTShift","terminatorRules","oldParentType","lastLineEmpty","nextLine","isOutdented","initial","spaceAfterMarker","adjustTab","offset","ch","isSpace","terminate","i","l","oldIndent","token_o","lines","token_c"],"mappings":"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","x_google_ignoreList":[0]}