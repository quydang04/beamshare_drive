{"version":3,"file":"html_block.mjs","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/html_block.mjs"],"sourcesContent":["// HTML block\n\nimport block_names from '../common/html_blocks.mjs'\nimport { HTML_OPEN_CLOSE_TAG_RE } from '../common/html_re.mjs'\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nconst HTML_SEQUENCES = [\n  [/^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true],\n  [/^<!--/,        /-->/,   true],\n  [/^<\\?/,         /\\?>/,   true],\n  [/^<![A-Z]/,     />/,     true],\n  [/^<!\\[CDATA\\[/, /\\]\\]>/, true],\n  [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true],\n  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false]\n]\n\nexport default function html_block (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (!state.md.options.html) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false }\n\n  let lineText = state.src.slice(pos, max)\n\n  let i = 0\n  for (; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break }\n  }\n  if (i === HTML_SEQUENCES.length) { return false }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2]\n  }\n\n  let nextLine = startLine + 1\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine]\n      max = state.eMarks[nextLine]\n      lineText = state.src.slice(pos, max)\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++ }\n        break\n      }\n    }\n  }\n\n  state.line = nextLine\n\n  const token   = state.push('html_block', '', 0)\n  token.map     = [startLine, nextLine]\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true)\n\n  return true\n}\n"],"names":["HTML_SEQUENCES","block_names","HTML_OPEN_CLOSE_TAG_RE","html_block","state","startLine","endLine","silent","pos","max","lineText","i","nextLine","token"],"mappings":";;AAQA,MAAMA,IAAiB;AAAA,EACrB,CAAC,8CAA8C,oCAAoC,EAAI;AAAA,EACvF,CAAC,SAAgB,OAAS,EAAI;AAAA,EAC9B,CAAC,QAAgB,OAAS,EAAI;AAAA,EAC9B,CAAC,YAAgB,KAAS,EAAI;AAAA,EAC9B,CAAC,gBAAgB,SAAS,EAAI;AAAA,EAC9B,CAAC,IAAI,OAAO,UAAUC,EAAY,KAAK,GAAG,IAAI,oBAAoB,GAAG,GAAG,MAAM,EAAI;AAAA,EAClF,CAAC,IAAI,OAAOC,EAAuB,SAAS,OAAO,GAAI,MAAM,EAAK;AACpE;AAEe,SAASC,EAAYC,GAAOC,GAAWC,GAASC,GAAQ;AACrE,MAAIC,IAAMJ,EAAM,OAAOC,CAAS,IAAID,EAAM,OAAOC,CAAS,GACtDI,IAAML,EAAM,OAAOC,CAAS;AAOhC,MAJID,EAAM,OAAOC,CAAS,IAAID,EAAM,aAAa,KAE7C,CAACA,EAAM,GAAG,QAAQ,QAElBA,EAAM,IAAI,WAAWI,CAAG,MAAM;AAAe,WAAO;AAExD,MAAIE,IAAWN,EAAM,IAAI,MAAMI,GAAKC,CAAG,GAEnCE,IAAI;AACR,SAAOA,IAAIX,EAAe,UACpB,CAAAA,EAAeW,CAAC,EAAE,CAAC,EAAE,KAAKD,CAAQ,GADNC;AAChC;AAEF,MAAIA,MAAMX,EAAe;AAAU,WAAO;AAE1C,MAAIO;AAEF,WAAOP,EAAeW,CAAC,EAAE,CAAC;AAG5B,MAAIC,IAAWP,IAAY;AAI3B,MAAI,CAACL,EAAeW,CAAC,EAAE,CAAC,EAAE,KAAKD,CAAQ;AACrC,WAAOE,IAAWN,KACZ,EAAAF,EAAM,OAAOQ,CAAQ,IAAIR,EAAM,YADVQ;AAOzB,UAJAJ,IAAMJ,EAAM,OAAOQ,CAAQ,IAAIR,EAAM,OAAOQ,CAAQ,GACpDH,IAAML,EAAM,OAAOQ,CAAQ,GAC3BF,IAAWN,EAAM,IAAI,MAAMI,GAAKC,CAAG,GAE/BT,EAAeW,CAAC,EAAE,CAAC,EAAE,KAAKD,CAAQ,GAAG;AACvC,QAAIA,EAAS,WAAW,KAAKE;AAC7B;AAAA,MACD;AAAA;AAIL,EAAAR,EAAM,OAAOQ;AAEb,QAAMC,IAAUT,EAAM,KAAK,cAAc,IAAI,CAAC;AAC9C,SAAAS,EAAM,MAAU,CAACR,GAAWO,CAAQ,GACpCC,EAAM,UAAUT,EAAM,SAASC,GAAWO,GAAUR,EAAM,WAAW,EAAI,GAElE;AACT;","x_google_ignoreList":[0]}