{"version":3,"file":"table.mjs","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/table.mjs"],"sourcesContent":["// GFM table, https://github.github.com/gfm/#tables-extension-\n\nimport { isSpace } from '../common/utils.mjs'\n\n// Limit the amount of empty autocompleted cells in a table,\n// see https://github.com/markdown-it/markdown-it/issues/1000,\n//\n// Both pulldown-cmark and commonmark-hs limit the number of cells this way to ~200k.\n// We set it to 65k, which can expand user input by a factor of x370\n// (256x256 square is 1.8kB expanded into 650kB).\nconst MAX_AUTOCOMPLETED_CELLS = 0x10000\n\nfunction getLine (state, line) {\n  const pos = state.bMarks[line] + state.tShift[line]\n  const max = state.eMarks[line]\n\n  return state.src.slice(pos, max)\n}\n\nfunction escapedSplit (str) {\n  const result = []\n  const max = str.length\n\n  let pos = 0\n  let ch = str.charCodeAt(pos)\n  let isEscaped = false\n  let lastPos = 0\n  let current = ''\n\n  while (pos < max) {\n    if (ch === 0x7c/* | */) {\n      if (!isEscaped) {\n        // pipe separating cells, '|'\n        result.push(current + str.substring(lastPos, pos))\n        current = ''\n        lastPos = pos + 1\n      } else {\n        // escaped pipe, '\\|'\n        current += str.substring(lastPos, pos - 1)\n        lastPos = pos\n      }\n    }\n\n    isEscaped = (ch === 0x5c/* \\ */)\n    pos++\n\n    ch = str.charCodeAt(pos)\n  }\n\n  result.push(current + str.substring(lastPos))\n\n  return result\n}\n\nexport default function table (state, startLine, endLine, silent) {\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false }\n\n  let nextLine = startLine + 1\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  let pos = state.bMarks[nextLine] + state.tShift[nextLine]\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const firstCh = state.src.charCodeAt(pos++)\n  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false }\n\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const secondCh = state.src.charCodeAt(pos++)\n  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace(secondCh)) {\n    return false\n  }\n\n  // if first character is '-', then second character must not be a space\n  // (due to parsing ambiguity with list)\n  if (firstCh === 0x2D/* - */ && isSpace(secondCh)) { return false }\n\n  while (pos < state.eMarks[nextLine]) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false }\n\n    pos++\n  }\n\n  let lineText = getLine(state, startLine + 1)\n  let columns = lineText.split('|')\n  const aligns = []\n  for (let i = 0; i < columns.length; i++) {\n    const t = columns[i].trim()\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue\n      } else {\n        return false\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right')\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left')\n    } else {\n      aligns.push('')\n    }\n  }\n\n  lineText = getLine(state, startLine).trim()\n  if (lineText.indexOf('|') === -1) { return false }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n  columns = escapedSplit(lineText)\n  if (columns.length && columns[0] === '') columns.shift()\n  if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n  // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n  const columnCount = columns.length\n  if (columnCount === 0 || columnCount !== aligns.length) { return false }\n\n  if (silent) { return true }\n\n  const oldParentType = state.parentType\n  state.parentType = 'table'\n\n  // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const token_to = state.push('table_open', 'table', 1)\n  const tableLines = [startLine, 0]\n  token_to.map = tableLines\n\n  const token_tho = state.push('thead_open', 'thead', 1)\n  token_tho.map = [startLine, startLine + 1]\n\n  const token_htro = state.push('tr_open', 'tr', 1)\n  token_htro.map = [startLine, startLine + 1]\n\n  for (let i = 0; i < columns.length; i++) {\n    const token_ho = state.push('th_open', 'th', 1)\n    if (aligns[i]) {\n      token_ho.attrs  = [['style', 'text-align:' + aligns[i]]]\n    }\n\n    const token_il = state.push('inline', '', 0)\n    token_il.content  = columns[i].trim()\n    token_il.children = []\n\n    state.push('th_close', 'th', -1)\n  }\n\n  state.push('tr_close', 'tr', -1)\n  state.push('thead_close', 'thead', -1)\n\n  let tbodyLines\n  let autocompletedCells = 0\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) { break }\n    lineText = getLine(state, nextLine).trim()\n    if (!lineText) { break }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n    columns = escapedSplit(lineText)\n    if (columns.length && columns[0] === '') columns.shift()\n    if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n    // note: autocomplete count can be negative if user specifies more columns than header,\n    // but that does not affect intended use (which is limiting expansion)\n    autocompletedCells += columnCount - columns.length\n    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) { break }\n\n    if (nextLine === startLine + 2) {\n      const token_tbo = state.push('tbody_open', 'tbody', 1)\n      token_tbo.map = tbodyLines = [startLine + 2, 0]\n    }\n\n    const token_tro = state.push('tr_open', 'tr', 1)\n    token_tro.map = [nextLine, nextLine + 1]\n\n    for (let i = 0; i < columnCount; i++) {\n      const token_tdo = state.push('td_open', 'td', 1)\n      if (aligns[i]) {\n        token_tdo.attrs  = [['style', 'text-align:' + aligns[i]]]\n      }\n\n      const token_il = state.push('inline', '', 0)\n      token_il.content  = columns[i] ? columns[i].trim() : ''\n      token_il.children = []\n\n      state.push('td_close', 'td', -1)\n    }\n    state.push('tr_close', 'tr', -1)\n  }\n\n  if (tbodyLines) {\n    state.push('tbody_close', 'tbody', -1)\n    tbodyLines[1] = nextLine\n  }\n\n  state.push('table_close', 'table', -1)\n  tableLines[1] = nextLine\n\n  state.parentType = oldParentType\n  state.line = nextLine\n  return true\n}\n"],"names":["MAX_AUTOCOMPLETED_CELLS","getLine","state","line","pos","max","escapedSplit","str","result","ch","isEscaped","lastPos","current","table","startLine","endLine","silent","nextLine","firstCh","secondCh","isSpace","lineText","columns","aligns","i","t","columnCount","oldParentType","terminatorRules","token_to","tableLines","token_tho","token_htro","token_ho","token_il","tbodyLines","autocompletedCells","terminate","l","token_tbo","token_tro","token_tdo"],"mappings":"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","x_google_ignoreList":[0]}