{"version":3,"file":"state_block.mjs","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/state_block.mjs"],"sourcesContent":["// Parser state class\n\nimport Token from '../token.mjs'\nimport { isSpace } from '../common/utils.mjs'\n\nfunction StateBlock (src, md, env, tokens) {\n  this.src = src\n\n  // link to parser instance\n  this.md     = md\n\n  this.env = env\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens\n\n  this.bMarks = []  // line begin offsets for fast jumps\n  this.eMarks = []  // line end offsets for fast jumps\n  this.tShift = []  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = []  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = []\n\n  // block parser variables\n\n  // required block content indent (for example, if we are\n  // inside a list, it would be positioned after list marker)\n  this.blkIndent  = 0\n  this.line       = 0 // line index in src\n  this.lineMax    = 0 // lines count\n  this.tight      = false  // loose/tight mode for lists\n  this.ddIndent   = -1 // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1 // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root'\n\n  this.level = 0\n\n  // Create caches\n  // Generate markers.\n  const s = this.src\n\n  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {\n    const ch = s.charCodeAt(pos)\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4\n        } else {\n          offset++\n        }\n        continue\n      } else {\n        indent_found = true\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++ }\n      this.bMarks.push(start)\n      this.eMarks.push(pos)\n      this.tShift.push(indent)\n      this.sCount.push(offset)\n      this.bsCount.push(0)\n\n      indent_found = false\n      indent = 0\n      offset = 0\n      start = pos + 1\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length)\n  this.eMarks.push(s.length)\n  this.tShift.push(0)\n  this.sCount.push(0)\n  this.bsCount.push(0)\n\n  this.lineMax = this.bMarks.length - 1 // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  const token = new Token(type, tag, nesting)\n  token.block = true\n\n  if (nesting < 0) this.level-- // closing tag\n  token.level = this.level\n  if (nesting > 0) this.level++ // opening tag\n\n  this.tokens.push(token)\n  return token\n}\n\nStateBlock.prototype.isEmpty = function isEmpty (line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line]\n}\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines (from) {\n  for (let max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break\n    }\n  }\n  return from\n}\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces (pos) {\n  for (let max = this.src.length; pos < max; pos++) {\n    const ch = this.src.charCodeAt(pos)\n    if (!isSpace(ch)) { break }\n  }\n  return pos\n}\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack (pos, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1 }\n  }\n  return pos\n}\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars (pos, code) {\n  for (let max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break }\n  }\n  return pos\n}\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack (pos, code, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1 }\n  }\n  return pos\n}\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines (begin, end, indent, keepLastLF) {\n  if (begin >= end) {\n    return ''\n  }\n\n  const queue = new Array(end - begin)\n\n  for (let i = 0, line = begin; line < end; line++, i++) {\n    let lineIndent = 0\n    const lineStart = this.bMarks[line]\n    let first = lineStart\n    let last\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1\n    } else {\n      last = this.eMarks[line]\n    }\n\n    while (first < last && lineIndent < indent) {\n      const ch = this.src.charCodeAt(first)\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4\n        } else {\n          lineIndent++\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++\n      } else {\n        break\n      }\n\n      first++\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last)\n    } else {\n      queue[i] = this.src.slice(first, last)\n    }\n  }\n\n  return queue.join('')\n}\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token\n\nexport default StateBlock\n"],"names":["StateBlock","src","md","env","tokens","s","start","pos","indent","offset","len","indent_found","ch","isSpace","type","tag","nesting","token","Token","line","from","max","min","code","begin","end","keepLastLF","queue","i","lineIndent","lineStart","first","last"],"mappings":"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","x_google_ignoreList":[0]}