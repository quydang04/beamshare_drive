import c from "./ruler.mjs";
import k from "./rules_inline/state_inline.mjs";
import g from "./rules_inline/text.mjs";
import a from "./rules_inline/linkify.mjs";
import d from "./rules_inline/newline.mjs";
import w from "./rules_inline/escape.mjs";
import _ from "./rules_inline/backticks.mjs";
import u from "./rules_inline/strikethrough.mjs";
import h from "./rules_inline/emphasis.mjs";
import x from "./rules_inline/link.mjs";
import y from "./rules_inline/image.mjs";
import b from "./rules_inline/autolink.mjs";
import v from "./rules_inline/html_inline.mjs";
import P from "./rules_inline/entity.mjs";
import z from "./rules_inline/balance_pairs.mjs";
import N from "./rules_inline/fragments_join.mjs";
const m = [
  ["text", g],
  ["linkify", a],
  ["newline", d],
  ["escape", w],
  ["backticks", _],
  ["strikethrough", u.tokenize],
  ["emphasis", h.tokenize],
  ["link", x],
  ["image", y],
  ["autolink", b],
  ["html_inline", v],
  ["entity", P]
], f = [
  ["balance_pairs", z],
  ["strikethrough", u.postProcess],
  ["emphasis", h.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", N]
];
function p() {
  this.ruler = new c();
  for (let o = 0; o < m.length; o++)
    this.ruler.push(m[o][0], m[o][1]);
  this.ruler2 = new c();
  for (let o = 0; o < f.length; o++)
    this.ruler2.push(f[o][0], f[o][1]);
}
p.prototype.skipToken = function(o) {
  const i = o.pos, t = this.ruler.getRules(""), s = t.length, l = o.md.options.maxNesting, n = o.cache;
  if (typeof n[i] < "u") {
    o.pos = n[i];
    return;
  }
  let r = !1;
  if (o.level < l) {
    for (let e = 0; e < s; e++)
      if (o.level++, r = t[e](o, !0), o.level--, r) {
        if (i >= o.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    o.pos = o.posMax;
  r || o.pos++, n[i] = o.pos;
};
p.prototype.tokenize = function(o) {
  const i = this.ruler.getRules(""), t = i.length, s = o.posMax, l = o.md.options.maxNesting;
  for (; o.pos < s; ) {
    const n = o.pos;
    let r = !1;
    if (o.level < l) {
      for (let e = 0; e < t; e++)
        if (r = i[e](o, !1), r) {
          if (n >= o.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (r) {
      if (o.pos >= s)
        break;
      continue;
    }
    o.pending += o.src[o.pos++];
  }
  o.pending && o.pushPending();
};
p.prototype.parse = function(o, i, t, s) {
  const l = new this.State(o, i, t, s);
  this.tokenize(l);
  const n = this.ruler2.getRules(""), r = n.length;
  for (let e = 0; e < r; e++)
    n[e](l);
};
p.prototype.State = k;
export {
  p as default
};
//# sourceMappingURL=parser_inline.mjs.map
