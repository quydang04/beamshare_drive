{"version":3,"file":"emphasis.mjs","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/emphasis.mjs"],"sourcesContent":["// Process *this* and _that_\n//\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nfunction emphasis_tokenize (state, silent) {\n  const start = state.pos\n  const marker = state.src.charCodeAt(start)\n\n  if (silent) { return false }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false }\n\n  const scanned = state.scanDelims(state.pos, marker === 0x2A)\n\n  for (let i = 0; i < scanned.length; i++) {\n    const token = state.push('text', '', 0)\n    token.content = String.fromCharCode(marker)\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker,\n\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token: state.tokens.length - 1,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end: -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open: scanned.can_open,\n      close: scanned.can_close\n    })\n  }\n\n  state.pos += scanned.length\n\n  return true\n}\n\nfunction postProcess (state, delimiters) {\n  const max = delimiters.length\n\n  for (let i = max - 1; i >= 0; i--) {\n    const startDelim = delimiters[i]\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue\n    }\n\n    const endDelim = delimiters[startDelim.end]\n\n    // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    const isStrong = i > 0 &&\n               delimiters[i - 1].end === startDelim.end + 1 &&\n               // check that first two markers match and adjacent\n               delimiters[i - 1].marker === startDelim.marker &&\n               delimiters[i - 1].token === startDelim.token - 1 &&\n               // check that last two markers are adjacent (we can safely assume they match)\n               delimiters[startDelim.end + 1].token === endDelim.token + 1\n\n    const ch = String.fromCharCode(startDelim.marker)\n\n    const token_o   = state.tokens[startDelim.token]\n    token_o.type    = isStrong ? 'strong_open' : 'em_open'\n    token_o.tag     = isStrong ? 'strong' : 'em'\n    token_o.nesting = 1\n    token_o.markup  = isStrong ? ch + ch : ch\n    token_o.content = ''\n\n    const token_c   = state.tokens[endDelim.token]\n    token_c.type    = isStrong ? 'strong_close' : 'em_close'\n    token_c.tag     = isStrong ? 'strong' : 'em'\n    token_c.nesting = -1\n    token_c.markup  = isStrong ? ch + ch : ch\n    token_c.content = ''\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = ''\n      state.tokens[delimiters[startDelim.end + 1].token].content = ''\n      i--\n    }\n  }\n}\n\n// Walk through delimiter list and replace text tokens with tags\n//\nfunction emphasis_post_process (state) {\n  const tokens_meta = state.tokens_meta\n  const max = state.tokens_meta.length\n\n  postProcess(state, state.delimiters)\n\n  for (let curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters)\n    }\n  }\n}\n\nexport default {\n  tokenize: emphasis_tokenize,\n  postProcess: emphasis_post_process\n}\n"],"names":["emphasis_tokenize","state","silent","start","marker","scanned","i","token","postProcess","delimiters","max","startDelim","endDelim","isStrong","ch","token_o","token_c","emphasis_post_process","tokens_meta","curr","r_emphasis"],"mappings":"AAKA,SAASA,EAAmBC,GAAOC,GAAQ;AACzC,QAAMC,IAAQF,EAAM,KACdG,IAASH,EAAM,IAAI,WAAWE,CAAK;AAIzC,MAFID,KAEAE,MAAW,MAAgBA,MAAW;AAAgB,WAAO;AAEjE,QAAMC,IAAUJ,EAAM,WAAWA,EAAM,KAAKG,MAAW,EAAI;AAE3D,WAASE,IAAI,GAAGA,IAAID,EAAQ,QAAQC,KAAK;AACvC,UAAMC,IAAQN,EAAM,KAAK,QAAQ,IAAI,CAAC;AACtC,IAAAM,EAAM,UAAU,OAAO,aAAaH,CAAM,GAE1CH,EAAM,WAAW,KAAK;AAAA;AAAA;AAAA,MAGpB,QAAAG;AAAA;AAAA;AAAA,MAIA,QAAQC,EAAQ;AAAA;AAAA;AAAA,MAIhB,OAAOJ,EAAM,OAAO,SAAS;AAAA;AAAA;AAAA;AAAA,MAK7B,KAAK;AAAA;AAAA;AAAA;AAAA,MAKL,MAAMI,EAAQ;AAAA,MACd,OAAOA,EAAQ;AAAA,IACrB,CAAK;AAAA,EACF;AAED,SAAAJ,EAAM,OAAOI,EAAQ,QAEd;AACT;AAEA,SAASG,EAAaP,GAAOQ,GAAY;AACvC,QAAMC,IAAMD,EAAW;AAEvB,WAASH,IAAII,IAAM,GAAGJ,KAAK,GAAGA,KAAK;AACjC,UAAMK,IAAaF,EAAWH,CAAC;AAO/B,QALIK,EAAW,WAAW,MAAeA,EAAW,WAAW,MAK3DA,EAAW,QAAQ;AACrB;AAGF,UAAMC,IAAWH,EAAWE,EAAW,GAAG,GAOpCE,IAAWP,IAAI,KACVG,EAAWH,IAAI,CAAC,EAAE,QAAQK,EAAW,MAAM;AAAA,IAE3CF,EAAWH,IAAI,CAAC,EAAE,WAAWK,EAAW,UACxCF,EAAWH,IAAI,CAAC,EAAE,UAAUK,EAAW,QAAQ;AAAA,IAE/CF,EAAWE,EAAW,MAAM,CAAC,EAAE,UAAUC,EAAS,QAAQ,GAE/DE,IAAK,OAAO,aAAaH,EAAW,MAAM,GAE1CI,IAAYd,EAAM,OAAOU,EAAW,KAAK;AAC/C,IAAAI,EAAQ,OAAUF,IAAW,gBAAgB,WAC7CE,EAAQ,MAAUF,IAAW,WAAW,MACxCE,EAAQ,UAAU,GAClBA,EAAQ,SAAUF,IAAWC,IAAKA,IAAKA,GACvCC,EAAQ,UAAU;AAElB,UAAMC,IAAYf,EAAM,OAAOW,EAAS,KAAK;AAC7C,IAAAI,EAAQ,OAAUH,IAAW,iBAAiB,YAC9CG,EAAQ,MAAUH,IAAW,WAAW,MACxCG,EAAQ,UAAU,IAClBA,EAAQ,SAAUH,IAAWC,IAAKA,IAAKA,GACvCE,EAAQ,UAAU,IAEdH,MACFZ,EAAM,OAAOQ,EAAWH,IAAI,CAAC,EAAE,KAAK,EAAE,UAAU,IAChDL,EAAM,OAAOQ,EAAWE,EAAW,MAAM,CAAC,EAAE,KAAK,EAAE,UAAU,IAC7DL;AAAA,EAEH;AACH;AAIA,SAASW,EAAuBhB,GAAO;AACrC,QAAMiB,IAAcjB,EAAM,aACpBS,IAAMT,EAAM,YAAY;AAE9B,EAAAO,EAAYP,GAAOA,EAAM,UAAU;AAEnC,WAASkB,IAAO,GAAGA,IAAOT,GAAKS;AAC7B,IAAID,EAAYC,CAAI,KAAKD,EAAYC,CAAI,EAAE,cACzCX,EAAYP,GAAOiB,EAAYC,CAAI,EAAE,UAAU;AAGrD;AAEA,MAAeC,IAAA;AAAA,EACb,UAAUpB;AAAA,EACV,aAAaiB;AACf;","x_google_ignoreList":[0]}