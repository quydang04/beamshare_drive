{"version":3,"file":"state_inline.mjs","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/state_inline.mjs"],"sourcesContent":["// Inline parser state\n\nimport Token from '../token.mjs'\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs'\n\nfunction StateInline (src, md, env, outTokens) {\n  this.src = src\n  this.env = env\n  this.md = md\n  this.tokens = outTokens\n  this.tokens_meta = Array(outTokens.length)\n\n  this.pos = 0\n  this.posMax = this.src.length\n  this.level = 0\n  this.pending = ''\n  this.pendingLevel = 0\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {}\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = []\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = []\n\n  // backtick length => last seen position\n  this.backticks = {}\n  this.backticksScanned = false\n\n  // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n  this.linkLevel = 0\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  const token = new Token('text', '', 0)\n  token.content = this.pending\n  token.level = this.pendingLevel\n  this.tokens.push(token)\n  this.pending = ''\n  return token\n}\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending()\n  }\n\n  const token = new Token(type, tag, nesting)\n  let token_meta = null\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--\n    this.delimiters = this._prev_delimiters.pop()\n  }\n\n  token.level = this.level\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++\n    this._prev_delimiters.push(this.delimiters)\n    this.delimiters = []\n    token_meta = { delimiters: this.delimiters }\n  }\n\n  this.pendingLevel = this.level\n  this.tokens.push(token)\n  this.tokens_meta.push(token_meta)\n  return token\n}\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  const max = this.posMax\n  const marker = this.src.charCodeAt(start)\n\n  // treat beginning of the line as a whitespace\n  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20\n\n  let pos = start\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++ }\n\n  const count = pos - start\n\n  // treat end of the line as a whitespace\n  const nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20\n\n  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))\n  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))\n\n  const isLastWhiteSpace = isWhiteSpace(lastChar)\n  const isNextWhiteSpace = isWhiteSpace(nextChar)\n\n  const left_flanking =\n    !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar)\n  const right_flanking =\n    !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar)\n\n  const can_open  = left_flanking  && (canSplitWord || !right_flanking || isLastPunctChar)\n  const can_close = right_flanking && (canSplitWord || !left_flanking  || isNextPunctChar)\n\n  return { can_open, can_close, length: count }\n}\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token\n\nexport default StateInline\n"],"names":["StateInline","src","md","env","outTokens","token","Token","type","tag","nesting","token_meta","start","canSplitWord","max","marker","lastChar","pos","count","nextChar","isLastPunctChar","isMdAsciiPunct","isPunctChar","isNextPunctChar","isLastWhiteSpace","isWhiteSpace","isNextWhiteSpace","left_flanking","right_flanking"],"mappings":";;AAKA,SAASA,EAAaC,GAAKC,GAAIC,GAAKC,GAAW;AAC7C,OAAK,MAAMH,GACX,KAAK,MAAME,GACX,KAAK,KAAKD,GACV,KAAK,SAASE,GACd,KAAK,cAAc,MAAMA,EAAU,MAAM,GAEzC,KAAK,MAAM,GACX,KAAK,SAAS,KAAK,IAAI,QACvB,KAAK,QAAQ,GACb,KAAK,UAAU,IACf,KAAK,eAAe,GAIpB,KAAK,QAAQ,CAAE,GAGf,KAAK,aAAa,CAAE,GAGpB,KAAK,mBAAmB,CAAE,GAG1B,KAAK,YAAY,CAAE,GACnB,KAAK,mBAAmB,IAIxB,KAAK,YAAY;AACnB;AAIAJ,EAAY,UAAU,cAAc,WAAY;AAC9C,QAAMK,IAAQ,IAAIC,EAAM,QAAQ,IAAI,CAAC;AACrC,SAAAD,EAAM,UAAU,KAAK,SACrBA,EAAM,QAAQ,KAAK,cACnB,KAAK,OAAO,KAAKA,CAAK,GACtB,KAAK,UAAU,IACRA;AACT;AAKAL,EAAY,UAAU,OAAO,SAAUO,GAAMC,GAAKC,GAAS;AACzD,EAAI,KAAK,WACP,KAAK,YAAa;AAGpB,QAAMJ,IAAQ,IAAIC,EAAMC,GAAMC,GAAKC,CAAO;AAC1C,MAAIC,IAAa;AAEjB,SAAID,IAAU,MAEZ,KAAK,SACL,KAAK,aAAa,KAAK,iBAAiB,IAAK,IAG/CJ,EAAM,QAAQ,KAAK,OAEfI,IAAU,MAEZ,KAAK,SACL,KAAK,iBAAiB,KAAK,KAAK,UAAU,GAC1C,KAAK,aAAa,CAAE,GACpBC,IAAa,EAAE,YAAY,KAAK,WAAY,IAG9C,KAAK,eAAe,KAAK,OACzB,KAAK,OAAO,KAAKL,CAAK,GACtB,KAAK,YAAY,KAAKK,CAAU,GACzBL;AACT;AAQAL,EAAY,UAAU,aAAa,SAAUW,GAAOC,GAAc;AAChE,QAAMC,IAAM,KAAK,QACXC,IAAS,KAAK,IAAI,WAAWH,CAAK,GAGlCI,IAAWJ,IAAQ,IAAI,KAAK,IAAI,WAAWA,IAAQ,CAAC,IAAI;AAE9D,MAAIK,IAAML;AACV,SAAOK,IAAMH,KAAO,KAAK,IAAI,WAAWG,CAAG,MAAMF;AAAU,IAAAE;AAE3D,QAAMC,IAAQD,IAAML,GAGdO,IAAWF,IAAMH,IAAM,KAAK,IAAI,WAAWG,CAAG,IAAI,IAElDG,IAAkBC,EAAeL,CAAQ,KAAKM,EAAY,OAAO,aAAaN,CAAQ,CAAC,GACvFO,IAAkBF,EAAeF,CAAQ,KAAKG,EAAY,OAAO,aAAaH,CAAQ,CAAC,GAEvFK,IAAmBC,EAAaT,CAAQ,GACxCU,IAAmBD,EAAaN,CAAQ,GAExCQ,IACJ,CAACD,MAAqB,CAACH,KAAmBC,KAAoBJ,IAC1DQ,IACJ,CAACJ,MAAqB,CAACJ,KAAmBM,KAAoBH;AAKhE,SAAO,EAAE,UAHSI,MAAmBd,KAAgB,CAACe,KAAkBR,IAGrD,WAFDQ,MAAmBf,KAAgB,CAACc,KAAkBJ,IAE1C,QAAQL,EAAO;AAC/C;AAGAjB,EAAY,UAAU,QAAQM;","x_google_ignoreList":[0]}