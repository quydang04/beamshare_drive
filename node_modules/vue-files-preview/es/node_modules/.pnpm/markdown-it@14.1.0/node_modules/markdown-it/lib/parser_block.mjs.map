{"version":3,"file":"parser_block.mjs","sources":["../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/parser_block.mjs"],"sourcesContent":["/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n\nimport Ruler from './ruler.mjs'\nimport StateBlock from './rules_block/state_block.mjs'\n\nimport r_table from './rules_block/table.mjs'\nimport r_code from './rules_block/code.mjs'\nimport r_fence from './rules_block/fence.mjs'\nimport r_blockquote from './rules_block/blockquote.mjs'\nimport r_hr from './rules_block/hr.mjs'\nimport r_list from './rules_block/list.mjs'\nimport r_reference from './rules_block/reference.mjs'\nimport r_html_block from './rules_block/html_block.mjs'\nimport r_heading from './rules_block/heading.mjs'\nimport r_lheading from './rules_block/lheading.mjs'\nimport r_paragraph from './rules_block/paragraph.mjs'\n\nconst _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  ['table',      r_table,      ['paragraph', 'reference']],\n  ['code',       r_code],\n  ['fence',      r_fence,      ['paragraph', 'reference', 'blockquote', 'list']],\n  ['blockquote', r_blockquote, ['paragraph', 'reference', 'blockquote', 'list']],\n  ['hr',         r_hr,         ['paragraph', 'reference', 'blockquote', 'list']],\n  ['list',       r_list,       ['paragraph', 'reference', 'blockquote']],\n  ['reference',  r_reference],\n  ['html_block', r_html_block, ['paragraph', 'reference', 'blockquote']],\n  ['heading',    r_heading,    ['paragraph', 'reference', 'blockquote']],\n  ['lheading',   r_lheading],\n  ['paragraph',  r_paragraph]\n]\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock () {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler()\n\n  for (let i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() })\n  }\n}\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  const rules = this.ruler.getRules('')\n  const len = rules.length\n  const maxNesting = state.md.options.maxNesting\n  let line = startLine\n  let hasEmptyLines = false\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line)\n    if (line >= endLine) { break }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine\n      break\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n    const prevLine = state.line\n    let ok = false\n\n    for (let i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false)\n      if (ok) {\n        if (prevLine >= state.line) {\n          throw new Error(\"block rule didn't increment state.line\")\n        }\n        break\n      }\n    }\n\n    // this can only happen if user disables paragraph rule\n    if (!ok) throw new Error('none of the block rules matched')\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true\n    }\n\n    line = state.line\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true\n      line++\n      state.line = line\n    }\n  }\n}\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  if (!src) { return }\n\n  const state = new this.State(src, md, env, outTokens)\n\n  this.tokenize(state, state.line, state.lineMax)\n}\n\nParserBlock.prototype.State = StateBlock\n\nexport default ParserBlock\n"],"names":["_rules","r_table","r_code","r_fence","r_blockquote","r_hr","r_list","r_reference","r_html_block","r_heading","r_lheading","r_paragraph","ParserBlock","Ruler","i","state","startLine","endLine","rules","len","maxNesting","line","hasEmptyLines","prevLine","ok","src","md","env","outTokens","StateBlock"],"mappings":";;;;;;;;;;;;;AAqBA,MAAMA,IAAS;AAAA;AAAA;AAAA,EAGb,CAAC,SAAcC,GAAc,CAAC,aAAa,WAAW,CAAC;AAAA,EACvD,CAAC,QAAcC,CAAM;AAAA,EACrB,CAAC,SAAcC,GAAc,CAAC,aAAa,aAAa,cAAc,MAAM,CAAC;AAAA,EAC7E,CAAC,cAAcC,GAAc,CAAC,aAAa,aAAa,cAAc,MAAM,CAAC;AAAA,EAC7E,CAAC,MAAcC,GAAc,CAAC,aAAa,aAAa,cAAc,MAAM,CAAC;AAAA,EAC7E,CAAC,QAAcC,GAAc,CAAC,aAAa,aAAa,YAAY,CAAC;AAAA,EACrE,CAAC,aAAcC,CAAW;AAAA,EAC1B,CAAC,cAAcC,GAAc,CAAC,aAAa,aAAa,YAAY,CAAC;AAAA,EACrE,CAAC,WAAcC,GAAc,CAAC,aAAa,aAAa,YAAY,CAAC;AAAA,EACrE,CAAC,YAAcC,CAAU;AAAA,EACzB,CAAC,aAAcC,CAAW;AAC5B;AAKA,SAASC,IAAe;AAMtB,OAAK,QAAQ,IAAIC,EAAO;AAExB,WAASC,IAAI,GAAGA,IAAId,EAAO,QAAQc;AACjC,SAAK,MAAM,KAAKd,EAAOc,CAAC,EAAE,CAAC,GAAGd,EAAOc,CAAC,EAAE,CAAC,GAAG,EAAE,MAAMd,EAAOc,CAAC,EAAE,CAAC,KAAK,CAAA,GAAI,MAAK,GAAI;AAErF;AAIAF,EAAY,UAAU,WAAW,SAAUG,GAAOC,GAAWC,GAAS;AACpE,QAAMC,IAAQ,KAAK,MAAM,SAAS,EAAE,GAC9BC,IAAMD,EAAM,QACZE,IAAaL,EAAM,GAAG,QAAQ;AACpC,MAAIM,IAAOL,GACPM,IAAgB;AAEpB,SAAOD,IAAOJ,MACZF,EAAM,OAAOM,IAAON,EAAM,eAAeM,CAAI,GACzC,EAAAA,KAAQJ,KAIRF,EAAM,OAAOM,CAAI,IAAIN,EAAM,eANV;AAUrB,QAAIA,EAAM,SAASK,GAAY;AAC7B,MAAAL,EAAM,OAAOE;AACb;AAAA,IACD;AAQD,UAAMM,IAAWR,EAAM;AACvB,QAAIS,IAAK;AAET,aAASV,IAAI,GAAGA,IAAIK,GAAKL;AAEvB,UADAU,IAAKN,EAAMJ,CAAC,EAAEC,GAAOM,GAAMJ,GAAS,EAAK,GACrCO,GAAI;AACN,YAAID,KAAYR,EAAM;AACpB,gBAAM,IAAI,MAAM,wCAAwC;AAE1D;AAAA,MACD;AAIH,QAAI,CAACS,EAAI,OAAM,IAAI,MAAM,iCAAiC;AAI1D,IAAAT,EAAM,QAAQ,CAACO,GAGXP,EAAM,QAAQA,EAAM,OAAO,CAAC,MAC9BO,IAAgB,KAGlBD,IAAON,EAAM,MAETM,IAAOJ,KAAWF,EAAM,QAAQM,CAAI,MACtCC,IAAgB,IAChBD,KACAN,EAAM,OAAOM;AAAA,EAEhB;AACH;AAOAT,EAAY,UAAU,QAAQ,SAAUa,GAAKC,GAAIC,GAAKC,GAAW;AAC/D,MAAI,CAACH;AAAO;AAEZ,QAAMV,IAAQ,IAAI,KAAK,MAAMU,GAAKC,GAAIC,GAAKC,CAAS;AAEpD,OAAK,SAASb,GAAOA,EAAM,MAAMA,EAAM,OAAO;AAChD;AAEAH,EAAY,UAAU,QAAQiB;","x_google_ignoreList":[0]}