import { isSpace as g } from "../common/utils.mjs";
const S = 65536;
function x(e, o) {
  const p = e.bMarks[o] + e.tShift[o], h = e.eMarks[o];
  return e.src.slice(p, h);
}
function y(e) {
  const o = [], p = e.length;
  let h = 0, l = e.charCodeAt(h), i = !1, f = 0, c = "";
  for (; h < p; )
    l === 124 && (i ? (c += e.substring(f, h - 1), f = h) : (o.push(c + e.substring(f, h)), c = "", f = h + 1)), i = l === 92, h++, l = e.charCodeAt(h);
  return o.push(c + e.substring(f)), o;
}
function O(e, o, p, h) {
  if (o + 2 > p)
    return !1;
  let l = o + 1;
  if (e.sCount[l] < e.blkIndent || e.sCount[l] - e.blkIndent >= 4)
    return !1;
  let i = e.bMarks[l] + e.tShift[l];
  if (i >= e.eMarks[l])
    return !1;
  const f = e.src.charCodeAt(i++);
  if (f !== 124 && f !== 45 && f !== 58 || i >= e.eMarks[l])
    return !1;
  const c = e.src.charCodeAt(i++);
  if (c !== 124 && c !== 45 && c !== 58 && !g(c) || f === 45 && g(c))
    return !1;
  for (; i < e.eMarks[l]; ) {
    const r = e.src.charCodeAt(i);
    if (r !== 124 && r !== 45 && r !== 58 && !g(r))
      return !1;
    i++;
  }
  let d = x(e, o + 1), n = d.split("|");
  const s = [];
  for (let r = 0; r < n.length; r++) {
    const u = n[r].trim();
    if (!u) {
      if (r === 0 || r === n.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(u))
      return !1;
    u.charCodeAt(u.length - 1) === 58 ? s.push(u.charCodeAt(0) === 58 ? "center" : "right") : u.charCodeAt(0) === 58 ? s.push("left") : s.push("");
  }
  if (d = x(e, o).trim(), d.indexOf("|") === -1 || e.sCount[o] - e.blkIndent >= 4)
    return !1;
  n = y(d), n.length && n[0] === "" && n.shift(), n.length && n[n.length - 1] === "" && n.pop();
  const b = n.length;
  if (b === 0 || b !== s.length)
    return !1;
  if (h)
    return !0;
  const M = e.parentType;
  e.parentType = "table";
  const C = e.md.block.ruler.getRules("blockquote"), T = e.push("table_open", "table", 1), m = [o, 0];
  T.map = m;
  const D = e.push("thead_open", "thead", 1);
  D.map = [o, o + 1];
  const I = e.push("tr_open", "tr", 1);
  I.map = [o, o + 1];
  for (let r = 0; r < n.length; r++) {
    const u = e.push("th_open", "th", 1);
    s[r] && (u.attrs = [["style", "text-align:" + s[r]]]);
    const t = e.push("inline", "", 0);
    t.content = n[r].trim(), t.children = [], e.push("th_close", "th", -1);
  }
  e.push("tr_close", "tr", -1), e.push("thead_close", "thead", -1);
  let k, A = 0;
  for (l = o + 2; l < p && !(e.sCount[l] < e.blkIndent); l++) {
    let r = !1;
    for (let t = 0, _ = C.length; t < _; t++)
      if (C[t](e, l, p, !0)) {
        r = !0;
        break;
      }
    if (r || (d = x(e, l).trim(), !d) || e.sCount[l] - e.blkIndent >= 4 || (n = y(d), n.length && n[0] === "" && n.shift(), n.length && n[n.length - 1] === "" && n.pop(), A += b - n.length, A > S))
      break;
    if (l === o + 2) {
      const t = e.push("tbody_open", "tbody", 1);
      t.map = k = [o + 2, 0];
    }
    const u = e.push("tr_open", "tr", 1);
    u.map = [l, l + 1];
    for (let t = 0; t < b; t++) {
      const _ = e.push("td_open", "td", 1);
      s[t] && (_.attrs = [["style", "text-align:" + s[t]]]);
      const a = e.push("inline", "", 0);
      a.content = n[t] ? n[t].trim() : "", a.children = [], e.push("td_close", "td", -1);
    }
    e.push("tr_close", "tr", -1);
  }
  return k && (e.push("tbody_close", "tbody", -1), k[1] = l), e.push("table_close", "table", -1), m[1] = l, e.parentType = M, e.line = l, !0;
}
export {
  O as default
};
//# sourceMappingURL=table.mjs.map
