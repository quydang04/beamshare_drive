{"version":3,"file":"list.mjs","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/list.mjs"],"sourcesContent":["// Lists\n\nimport { isSpace } from '../common/utils.mjs'\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker (state, startLine) {\n  const max = state.eMarks[startLine]\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n\n  const marker = state.src.charCodeAt(pos++)\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1\n  }\n\n  if (pos < max) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1\n    }\n  }\n\n  return pos\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker (state, startLine) {\n  const start = state.bMarks[startLine] + state.tShift[startLine]\n  const max = state.eMarks[startLine]\n  let pos = start\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1 }\n\n  let ch = state.src.charCodeAt(pos++)\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1 }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1 }\n\n    ch = state.src.charCodeAt(pos++)\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1 }\n\n      continue\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break\n    }\n\n    return -1\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos)\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1\n    }\n  }\n  return pos\n}\n\nfunction markTightParagraphs (state, idx) {\n  const level = state.level + 2\n\n  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true\n      state.tokens[i].hidden = true\n      i += 2\n    }\n  }\n}\n\nexport default function list (state, startLine, endLine, silent) {\n  let max, pos, start, token\n  let nextLine = startLine\n  let tight = true\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 &&\n      state.sCount[nextLine] - state.listIndent >= 4 &&\n      state.sCount[nextLine] < state.blkIndent) {\n    return false\n  }\n\n  let isTerminatingParagraph = false\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      isTerminatingParagraph = true\n    }\n  }\n\n  // Detect list type and position after marker\n  let isOrdered\n  let markerValue\n  let posAfterMarker\n  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {\n    isOrdered = true\n    start = state.bMarks[nextLine] + state.tShift[nextLine]\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1))\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false\n  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {\n    isOrdered = false\n  } else {\n    return false\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false\n  }\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true }\n\n  // We should terminate list on style change. Remember first one to compare.\n  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1)\n\n  // Start list\n  const listTokIdx = state.tokens.length\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1)\n    if (markerValue !== 1) {\n      token.attrs = [['start', markerValue]]\n    }\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1)\n  }\n\n  const listLines = [nextLine, 0]\n  token.map    = listLines\n  token.markup = String.fromCharCode(markerCharCode)\n\n  //\n  // Iterate list items\n  //\n\n  let prevEmptyEnd = false\n  const terminatorRules = state.md.block.ruler.getRules('list')\n\n  const oldParentType = state.parentType\n  state.parentType = 'list'\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker\n    max = state.eMarks[nextLine]\n\n    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine])\n    let offset = initial\n\n    while (pos < max) {\n      const ch = state.src.charCodeAt(pos)\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4\n      } else if (ch === 0x20) {\n        offset++\n      } else {\n        break\n      }\n\n      pos++\n    }\n\n    const contentStart = pos\n    let indentAfterMarker\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1\n    } else {\n      indentAfterMarker = offset - initial\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1 }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    const indent = initial + indentAfterMarker\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1)\n    token.markup = String.fromCharCode(markerCharCode)\n    const itemLines = [nextLine, 0]\n    token.map    = itemLines\n    if (isOrdered) {\n      token.info = state.src.slice(start, posAfterMarker - 1)\n    }\n\n    // change current state, then restore it after parser subcall\n    const oldTight = state.tight\n    const oldTShift = state.tShift[nextLine]\n    const oldSCount = state.sCount[nextLine]\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    const oldListIndent = state.listIndent\n    state.listIndent = state.blkIndent\n    state.blkIndent = indent\n\n    state.tight = true\n    state.tShift[nextLine] = contentStart - state.bMarks[nextLine]\n    state.sCount[nextLine] = offset\n\n    if (contentStart >= max && state.isEmpty(nextLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine)\n    } else {\n      state.md.block.tokenize(state, nextLine, endLine, true)\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - nextLine) > 1 && state.isEmpty(state.line - 1)\n\n    state.blkIndent = state.listIndent\n    state.listIndent = oldListIndent\n    state.tShift[nextLine] = oldTShift\n    state.sCount[nextLine] = oldSCount\n    state.tight = oldTight\n\n    token        = state.push('list_item_close', 'li', -1)\n    token.markup = String.fromCharCode(markerCharCode)\n\n    nextLine = state.line\n    itemLines[1] = nextLine\n\n    if (nextLine >= endLine) { break }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n\n    // fail if terminating block found\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine)\n      if (posAfterMarker < 0) { break }\n      start = state.bMarks[nextLine] + state.tShift[nextLine]\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine)\n      if (posAfterMarker < 0) { break }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1)\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1)\n  }\n  token.markup = String.fromCharCode(markerCharCode)\n\n  listLines[1] = nextLine\n  state.line = nextLine\n\n  state.parentType = oldParentType\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx)\n  }\n\n  return true\n}\n"],"names":["skipBulletListMarker","state","startLine","max","pos","marker","ch","isSpace","skipOrderedListMarker","start","markTightParagraphs","idx","level","l","list","endLine","silent","token","nextLine","tight","isTerminatingParagraph","isOrdered","markerValue","posAfterMarker","markerCharCode","listTokIdx","listLines","prevEmptyEnd","terminatorRules","oldParentType","initial","offset","contentStart","indentAfterMarker","indent","itemLines","oldTight","oldTShift","oldSCount","oldListIndent","terminate","i"],"mappings":"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","x_google_ignoreList":[0]}