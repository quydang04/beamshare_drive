{"version":3,"file":"renderer.mjs","sources":["../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/renderer.mjs"],"sourcesContent":["/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n\nimport { assign, unescapeAll, escapeHtml } from './common/utils.mjs'\n\nconst default_rules = {}\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n\n  return  '<code' + slf.renderAttrs(token) + '>' +\n          escapeHtml(token.content) +\n          '</code>'\n}\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n\n  return  '<pre' + slf.renderAttrs(token) + '><code>' +\n          escapeHtml(tokens[idx].content) +\n          '</code></pre>\\n'\n}\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n  const info = token.info ? unescapeAll(token.info).trim() : ''\n  let langName = ''\n  let langAttrs = ''\n\n  if (info) {\n    const arr = info.split(/(\\s+)/g)\n    langName = arr[0]\n    langAttrs = arr.slice(2).join('')\n  }\n\n  let highlighted\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content)\n  } else {\n    highlighted = escapeHtml(token.content)\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n'\n  }\n\n  // If language exists, inject class gently, without modifying original token.\n  // May be, one day we will add .deepClone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    const i = token.attrIndex('class')\n    const tmpAttrs = token.attrs ? token.attrs.slice() : []\n\n    if (i < 0) {\n      tmpAttrs.push(['class', options.langPrefix + langName])\n    } else {\n      tmpAttrs[i] = tmpAttrs[i].slice()\n      tmpAttrs[i][1] += ' ' + options.langPrefix + langName\n    }\n\n    // Fake token just to render attributes\n    const tmpToken = {\n      attrs: tmpAttrs\n    }\n\n    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>\\n`\n  }\n\n  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>\\n`\n}\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    slf.renderInlineAsText(token.children, options, env)\n\n  return slf.renderToken(tokens, idx, options)\n}\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n'\n}\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n'\n}\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content)\n}\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content\n}\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content\n}\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer () {\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independent static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.mjs)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules)\n}\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs (token) {\n  let i, l, result\n\n  if (!token.attrs) { return '' }\n\n  result = ''\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"'\n  }\n\n  return result\n}\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken (tokens, idx, options) {\n  const token = tokens[idx]\n  let result = ''\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return ''\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n'\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token)\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /'\n  }\n\n  // Check if we need to add a newline after this tag\n  let needLf = false\n  if (token.block) {\n    needLf = true\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        const nextToken = tokens[idx + 1]\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>'\n\n  return result\n}\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  let result = ''\n  const rules = this.rules\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const type = tokens[i].type\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this)\n    } else {\n      result += this.renderToken(tokens, i, options)\n    }\n  }\n\n  return result\n}\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  let result = ''\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    switch (tokens[i].type) {\n      case 'text':\n        result += tokens[i].content\n        break\n      case 'image':\n        result += this.renderInlineAsText(tokens[i].children, options, env)\n        break\n      case 'html_inline':\n      case 'html_block':\n        result += tokens[i].content\n        break\n      case 'softbreak':\n      case 'hardbreak':\n        result += '\\n'\n        break\n      default:\n        // all other tokens are skipped\n    }\n  }\n\n  return result\n}\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  let result = ''\n  const rules = this.rules\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const type = tokens[i].type\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env)\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this)\n    } else {\n      result += this.renderToken(tokens, i, options, env)\n    }\n  }\n\n  return result\n}\n\nexport default Renderer\n"],"names":["default_rules","tokens","idx","options","env","slf","token","escapeHtml","info","unescapeAll","langName","langAttrs","arr","highlighted","i","tmpAttrs","tmpToken","Renderer","assign","result","needLf","nextToken","rules","len","type"],"mappings":"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","x_google_ignoreList":[0]}