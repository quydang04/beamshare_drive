import { isSpace as h, normalizeReference as w } from "../common/utils.mjs";
function B(n, t, S, y) {
  let e = n.bMarks[t] + n.tShift[t], i = n.eMarks[t], f = t + 1;
  if (n.sCount[t] - n.blkIndent >= 4 || n.src.charCodeAt(e) !== 91)
    return !1;
  function s(r) {
    const o = n.lineMax;
    if (r >= o || n.isEmpty(r))
      return null;
    let k = !1;
    if (n.sCount[r] - n.blkIndent > 3 && (k = !0), n.sCount[r] < 0 && (k = !0), !k) {
      const x = n.md.block.ruler.getRules("reference"), R = n.parentType;
      n.parentType = "reference";
      let g = !1;
      for (let C = 0, E = x.length; C < E; C++)
        if (x[C](n, r, o, !0)) {
          g = !0;
          break;
        }
      if (n.parentType = R, g)
        return null;
    }
    const v = n.bMarks[r] + n.tShift[r], M = n.eMarks[r];
    return n.src.slice(v, M + 1);
  }
  let l = n.src.slice(e, i + 1);
  i = l.length;
  let u = -1;
  for (e = 1; e < i; e++) {
    const r = l.charCodeAt(e);
    if (r === 91)
      return !1;
    if (r === 93) {
      u = e;
      break;
    } else if (r === 10) {
      const o = s(f);
      o !== null && (l += o, i = l.length, f++);
    } else if (r === 92 && (e++, e < i && l.charCodeAt(e) === 10)) {
      const o = s(f);
      o !== null && (l += o, i = l.length, f++);
    }
  }
  if (u < 0 || l.charCodeAt(u + 1) !== 58)
    return !1;
  for (e = u + 2; e < i; e++) {
    const r = l.charCodeAt(e);
    if (r === 10) {
      const o = s(f);
      o !== null && (l += o, i = l.length, f++);
    } else if (!h(r)) break;
  }
  const p = n.md.helpers.parseLinkDestination(l, e, i);
  if (!p.ok)
    return !1;
  const A = n.md.normalizeLink(p.str);
  if (!n.md.validateLink(A))
    return !1;
  e = p.pos;
  const m = e, b = f, T = e;
  for (; e < i; e++) {
    const r = l.charCodeAt(e);
    if (r === 10) {
      const o = s(f);
      o !== null && (l += o, i = l.length, f++);
    } else if (!h(r)) break;
  }
  let c = n.md.helpers.parseLinkTitle(l, e, i);
  for (; c.can_continue; ) {
    const r = s(f);
    if (r === null) break;
    l += r, e = i, i = l.length, f++, c = n.md.helpers.parseLinkTitle(l, e, i, c);
  }
  let d;
  for (e < i && T !== e && c.ok ? (d = c.str, e = c.pos) : (d = "", e = m, f = b); e < i; ) {
    const r = l.charCodeAt(e);
    if (!h(r))
      break;
    e++;
  }
  if (e < i && l.charCodeAt(e) !== 10 && d)
    for (d = "", e = m, f = b; e < i; ) {
      const r = l.charCodeAt(e);
      if (!h(r))
        break;
      e++;
    }
  if (e < i && l.charCodeAt(e) !== 10)
    return !1;
  const a = w(l.slice(1, u));
  return a ? (y || (typeof n.env.references > "u" && (n.env.references = {}), typeof n.env.references[a] > "u" && (n.env.references[a] = { title: d, href: A }), n.line = f), !0) : !1;
}
export {
  B as default
};
//# sourceMappingURL=reference.mjs.map
