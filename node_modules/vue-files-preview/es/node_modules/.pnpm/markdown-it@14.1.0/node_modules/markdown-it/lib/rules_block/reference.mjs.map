{"version":3,"file":"reference.mjs","sources":["../../../../../../../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/reference.mjs"],"sourcesContent":["import { isSpace, normalizeReference } from '../common/utils.mjs'\n\nexport default function reference (state, startLine, _endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n  let nextLine = startLine + 1\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false }\n\n  function getNextLine (nextLine) {\n    const endLine = state.lineMax\n\n    if (nextLine >= endLine || state.isEmpty(nextLine)) {\n      // empty line or end of input\n      return null\n    }\n\n    let isContinuation = false\n\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { isContinuation = true }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { isContinuation = true }\n\n    if (!isContinuation) {\n      const terminatorRules = state.md.block.ruler.getRules('reference')\n      const oldParentType = state.parentType\n      state.parentType = 'reference'\n\n      // Some tags can terminate paragraph without empty line.\n      let terminate = false\n      for (let i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true\n          break\n        }\n      }\n\n      state.parentType = oldParentType\n      if (terminate) {\n        // terminated by another block\n        return null\n      }\n    }\n\n    const pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    const max = state.eMarks[nextLine]\n\n    // max + 1 explicitly includes the newline\n    return state.src.slice(pos, max + 1)\n  }\n\n  let str = state.src.slice(pos, max + 1)\n\n  max = str.length\n  let labelEnd = -1\n\n  for (pos = 1; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x5B /* [ */) {\n      return false\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos\n      break\n    } else if (ch === 0x0A /* \\n */) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (ch === 0x5C /* \\ */) {\n      pos++\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        const lineContent = getNextLine(nextLine)\n        if (lineContent !== null) {\n          str += lineContent\n          max = str.length\n          nextLine++\n        }\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  const destRes = state.md.helpers.parseLinkDestination(str, pos, max)\n  if (!destRes.ok) { return false }\n\n  const href = state.md.normalizeLink(destRes.str)\n  if (!state.md.validateLink(href)) { return false }\n\n  pos = destRes.pos\n\n  // save cursor state, we could require to rollback later\n  const destEndPos = pos\n  const destEndLineNo = nextLine\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  const start = pos\n  for (; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max)\n  while (titleRes.can_continue) {\n    const lineContent = getNextLine(nextLine)\n    if (lineContent === null) break\n    str += lineContent\n    pos = max\n    max = str.length\n    nextLine++\n    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes)\n  }\n  let title\n\n  if (pos < max && start !== pos && titleRes.ok) {\n    title = titleRes.str\n    pos = titleRes.pos\n  } else {\n    title = ''\n    pos = destEndPos\n    nextLine = destEndLineNo\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    const ch = str.charCodeAt(pos)\n    if (!isSpace(ch)) { break }\n    pos++\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = ''\n      pos = destEndPos\n      nextLine = destEndLineNo\n      while (pos < max) {\n        const ch = str.charCodeAt(pos)\n        if (!isSpace(ch)) { break }\n        pos++\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false\n  }\n\n  const label = normalizeReference(str.slice(1, labelEnd))\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /* istanbul ignore if */\n  if (silent) { return true }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {}\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title, href }\n  }\n\n  state.line = nextLine\n  return true\n}\n"],"names":["reference","state","startLine","_endLine","silent","pos","max","nextLine","getNextLine","endLine","isContinuation","terminatorRules","oldParentType","terminate","i","l","str","labelEnd","ch","lineContent","isSpace","destRes","href","destEndPos","destEndLineNo","start","titleRes","title","label","normalizeReference"],"mappings":"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","x_google_ignoreList":[0]}