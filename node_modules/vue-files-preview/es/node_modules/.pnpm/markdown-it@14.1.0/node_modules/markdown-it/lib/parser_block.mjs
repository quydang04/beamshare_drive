import u from "./ruler.mjs";
import s from "./rules_block/state_block.mjs";
import k from "./rules_block/table.mjs";
import b from "./rules_block/code.mjs";
import g from "./rules_block/fence.mjs";
import d from "./rules_block/blockquote.mjs";
import q from "./rules_block/hr.mjs";
import w from "./rules_block/list.mjs";
import y from "./rules_block/reference.mjs";
import E from "./rules_block/html_block.mjs";
import x from "./rules_block/heading.mjs";
import S from "./rules_block/lheading.mjs";
import _ from "./rules_block/paragraph.mjs";
const t = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", k, ["paragraph", "reference"]],
  ["code", b],
  ["fence", g, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", d, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", q, ["paragraph", "reference", "blockquote", "list"]],
  ["list", w, ["paragraph", "reference", "blockquote"]],
  ["reference", y],
  ["html_block", E, ["paragraph", "reference", "blockquote"]],
  ["heading", x, ["paragraph", "reference", "blockquote"]],
  ["lheading", S],
  ["paragraph", _]
];
function c() {
  this.ruler = new u();
  for (let e = 0; e < t.length; e++)
    this.ruler.push(t[e][0], t[e][1], { alt: (t[e][2] || []).slice() });
}
c.prototype.tokenize = function(e, n, o) {
  const l = this.ruler.getRules(""), i = l.length, m = e.md.options.maxNesting;
  let r = n, p = !1;
  for (; r < o && (e.line = r = e.skipEmptyLines(r), !(r >= o || e.sCount[r] < e.blkIndent)); ) {
    if (e.level >= m) {
      e.line = o;
      break;
    }
    const h = e.line;
    let f = !1;
    for (let a = 0; a < i; a++)
      if (f = l[a](e, r, o, !1), f) {
        if (h >= e.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!f) throw new Error("none of the block rules matched");
    e.tight = !p, e.isEmpty(e.line - 1) && (p = !0), r = e.line, r < o && e.isEmpty(r) && (p = !0, r++, e.line = r);
  }
};
c.prototype.parse = function(e, n, o, l) {
  if (!e)
    return;
  const i = new this.State(e, n, o, l);
  this.tokenize(i, i.line, i.lineMax);
};
c.prototype.State = s;
export {
  c as default
};
//# sourceMappingURL=parser_block.mjs.map
