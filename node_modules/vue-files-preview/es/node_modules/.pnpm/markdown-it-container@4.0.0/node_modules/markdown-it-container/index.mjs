function D(_, l, f) {
  function x(r) {
    return r.trim().split(" ", 2)[0] === l;
  }
  function C(r, o, p, d, n) {
    return r[o].nesting === 1 && r[o].attrJoin("class", l), n.renderToken(r, o, p, d, n);
  }
  f = f || {};
  const g = 3, a = f.marker || ":", t = a.charCodeAt(0), i = a.length, T = f.validate || x, b = f.render || C;
  function y(r, o, p, d) {
    let n, s = !1, e = r.bMarks[o] + r.tShift[o], u = r.eMarks[o];
    if (t !== r.src.charCodeAt(e))
      return !1;
    for (n = e + 1; n <= u && a[(n - e) % i] === r.src[n]; n++)
      ;
    const h = Math.floor((n - e) / i);
    if (h < g)
      return !1;
    n -= (n - e) % i;
    const M = r.src.slice(e, n), m = r.src.slice(n, u);
    if (!T(m, M))
      return !1;
    if (d)
      return !0;
    let c = o;
    for (; c++, !(c >= p || (e = r.bMarks[c] + r.tShift[c], u = r.eMarks[c], e < u && r.sCount[c] < r.blkIndent)); )
      if (t === r.src.charCodeAt(e) && !(r.sCount[c] - r.blkIndent >= 4)) {
        for (n = e + 1; n <= u && a[(n - e) % i] === r.src[n]; n++)
          ;
        if (!(Math.floor((n - e) / i) < h) && (n -= (n - e) % i, n = r.skipSpaces(n), !(n < u))) {
          s = !0;
          break;
        }
      }
    const A = r.parentType, S = r.lineMax;
    r.parentType = "container", r.lineMax = c;
    const k = r.push("container_" + l + "_open", "div", 1);
    k.markup = M, k.block = !0, k.info = m, k.map = [o, c], r.md.block.tokenize(r, o + 1, c);
    const v = r.push("container_" + l + "_close", "div", -1);
    return v.markup = r.src.slice(e, n), v.block = !0, r.parentType = A, r.lineMax = S, r.line = c + (s ? 1 : 0), !0;
  }
  _.block.ruler.before("fence", "container_" + l, y, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  }), _.renderer.rules["container_" + l + "_open"] = b, _.renderer.rules["container_" + l + "_close"] = b;
}
export {
  D as default
};
//# sourceMappingURL=index.mjs.map
