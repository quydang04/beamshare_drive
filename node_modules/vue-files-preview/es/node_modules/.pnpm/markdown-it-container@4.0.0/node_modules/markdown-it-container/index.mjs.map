{"version":3,"file":"index.mjs","sources":["../../../../../../../node_modules/.pnpm/markdown-it-container@4.0.0/node_modules/markdown-it-container/index.mjs"],"sourcesContent":["// Process block-level custom containers\n//\nexport default function container_plugin (md, name, options) {\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault (params/*, markup */) {\n    return params.trim().split(' ', 2)[0] === name\n  }\n\n  function renderDefault (tokens, idx, _options, env, slf) {\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name)\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf)\n  }\n\n  options = options || {}\n\n  const min_markers = 3\n  const marker_str  = options.marker || ':'\n  const marker_char = marker_str.charCodeAt(0)\n  const marker_len  = marker_str.length\n  const validate    = options.validate || validateDefault\n  const render      = options.render || renderDefault\n\n  function container (state, startLine, endLine, silent) {\n    let pos\n    let auto_closed = false\n    let start = state.bMarks[startLine] + state.tShift[startLine]\n    let max = state.eMarks[startLine]\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) { return false }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break\n      }\n    }\n\n    const marker_count = Math.floor((pos - start) / marker_len)\n    if (marker_count < min_markers) { return false }\n    pos -= (pos - start) % marker_len\n\n    const markup = state.src.slice(start, pos)\n    const params = state.src.slice(pos, max)\n    if (!validate(params, markup)) { return false }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true }\n\n    // Search for the end of the block\n    //\n    let nextLine = startLine\n\n    for (;;) {\n      nextLine++\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine]\n      max = state.eMarks[nextLine]\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) { continue }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) { continue }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len\n      pos = state.skipSpaces(pos)\n\n      if (pos < max) { continue }\n\n      // found!\n      auto_closed = true\n      break\n    }\n\n    const old_parent = state.parentType\n    const old_line_max = state.lineMax\n    state.parentType = 'container'\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine\n\n    const token_o  = state.push('container_' + name + '_open', 'div', 1)\n    token_o.markup = markup\n    token_o.block  = true\n    token_o.info   = params\n    token_o.map    = [startLine, nextLine]\n\n    state.md.block.tokenize(state, startLine + 1, nextLine)\n\n    const token_c  = state.push('container_' + name + '_close', 'div', -1)\n    token_c.markup = state.src.slice(start, pos)\n    token_c.block  = true\n\n    state.parentType = old_parent\n    state.lineMax = old_line_max\n    state.line = nextLine + (auto_closed ? 1 : 0)\n\n    return true\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  })\n  md.renderer.rules['container_' + name + '_open'] = render\n  md.renderer.rules['container_' + name + '_close'] = render\n};\n"],"names":["container_plugin","md","name","options","validateDefault","params","renderDefault","tokens","idx","_options","env","slf","min_markers","marker_str","marker_char","marker_len","validate","render","container","state","startLine","endLine","silent","pos","auto_closed","start","max","marker_count","markup","nextLine","old_parent","old_line_max","token_o","token_c"],"mappings":"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","x_google_ignoreList":[0]}