{"version":3,"file":"style-mod.mjs","sources":["../../../../../../../../node_modules/.pnpm/style-mod@4.1.2/node_modules/style-mod/src/style-mod.js"],"sourcesContent":["const C = \"\\u037c\"\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C)\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\")\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nexport class StyleModule {\n  // :: (Object<Style>, ?{finish: ?(string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  constructor(spec, options) {\n    this.rules = []\n    let {finish} = options || {}\n\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/)\n    }\n\n    function render(selectors, spec, target, isKeyframes) {\n      let local = [], isAt = /^@(\\w+)\\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == \"keyframes\"\n      if (isAt && spec == null) return target.push(selectors[0] + \";\")\n      for (let prop in spec) {\n        let value = spec[prop]\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),\n                 value, target)\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n          render(splitSelector(prop), value, local, keyframes)\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\")\n        }\n      }\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") +\n                    \" {\" + local.join(\" \") + \"}\")\n      }\n    }\n\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)\n  }\n\n  // :: () → string\n  // Returns a string containing the module's CSS rules.\n  getRules() { return this.rules.join(\"\\n\") }\n\n  // :: () → string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1\n    top[COUNT] = id + 1\n    return C + id.toString(36)\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  //\n  // If a Content Security Policy nonce is provided, it is added to\n  // the `<style>` tag generated by the library.\n  static mount(root, modules, options) {\n    let set = root[SET], nonce = options && options.nonce\n    if (!set) set = new StyleSet(root, nonce)\n    else if (nonce) set.setNonce(nonce)\n    set.mount(Array.isArray(modules) ? modules : [modules], root)\n  }\n}\n\nlet adoptedSet = new Map //<Document, StyleSet>\n\nclass StyleSet {\n  constructor(root, nonce) {\n    let doc = root.ownerDocument || root, win = doc.defaultView\n    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {\n      let adopted = adoptedSet.get(doc)\n      if (adopted) return root[SET] = adopted\n      this.sheet = new win.CSSStyleSheet\n      adoptedSet.set(doc, this)\n    } else {\n      this.styleTag = doc.createElement(\"style\")\n      if (nonce) this.styleTag.setAttribute(\"nonce\", nonce)\n    }\n    this.modules = []\n    root[SET] = this\n  }\n\n  mount(modules, root) {\n    let sheet = this.sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (sheet) for (let k = 0; k < mod.rules.length; k++)\n          sheet.insertRule(mod.rules[k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length\n        pos += mod.rules.length\n        j++\n      }\n    }\n\n    if (sheet) {\n      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)\n        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets]\n    } else {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i].getRules() + \"\\n\"\n      this.styleTag.textContent = text\n      let target = root.head || root\n      if (this.styleTag.parentNode != target)\n        target.insertBefore(this.styleTag, target.firstChild)\n    }\n  }\n\n  setNonce(nonce) {\n    if (this.styleTag && this.styleTag.getAttribute(\"nonce\") != nonce)\n      this.styleTag.setAttribute(\"nonce\", nonce)\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n"],"names":["C","COUNT","SET","top","StyleModule","spec","options","finish","splitSelector","selector","render","selectors","target","isKeyframes","local","isAt","keyframes","prop","value","part","sel","a","b","l","id","root","modules","set","nonce","StyleSet","adoptedSet","doc","win","adopted","sheet","pos","j","i","mod","index","k","text"],"mappings":"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","x_google_ignoreList":[0]}