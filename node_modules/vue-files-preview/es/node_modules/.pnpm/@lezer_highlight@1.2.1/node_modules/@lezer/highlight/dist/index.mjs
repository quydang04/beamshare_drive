import { NodeProp as F } from "../../../../../@lezer_common@1.2.1/node_modules/@lezer/common/dist/index.mjs";
let z = 0;
class f {
  /**
  @internal
  */
  constructor(t, a, i, n) {
    this.name = t, this.set = a, this.base = i, this.modified = n, this.id = z++;
  }
  toString() {
    let { name: t } = this;
    for (let a of this.modified)
      a.name && (t = `${a.name}(${t})`);
    return t;
  }
  static define(t, a) {
    let i = typeof t == "string" ? t : "?";
    if (t instanceof f && (a = t), a != null && a.base)
      throw new Error("Can not derive from a modified tag");
    let n = new f(i, [], null, []);
    if (n.set.push(n), a)
      for (let s of a.set)
        n.set.push(s);
    return n;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(t) {
    let a = new C(t);
    return (i) => i.modified.indexOf(a) > -1 ? i : C.get(i.base || i, i.modified.concat(a).sort((n, s) => n.id - s.id));
  }
}
let G = 0;
class C {
  constructor(t) {
    this.name = t, this.instances = [], this.id = G++;
  }
  static get(t, a) {
    if (!a.length)
      return t;
    let i = a[0].instances.find((r) => r.base == t && L(a, r.modified));
    if (i)
      return i;
    let n = [], s = new f(t.name, n, t, a);
    for (let r of a)
      r.instances.push(s);
    let g = P(a);
    for (let r of t.set)
      if (!r.modified.length)
        for (let m of g)
          n.push(C.get(r, m));
    return s;
  }
}
function L(o, t) {
  return o.length == t.length && o.every((a, i) => a == t[i]);
}
function P(o) {
  let t = [[]];
  for (let a = 0; a < o.length; a++)
    for (let i = 0, n = t.length; i < n; i++)
      t.push(t[i].concat(o[a]));
  return t.sort((a, i) => i.length - a.length);
}
function Z(o) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let a in o) {
    let i = o[a];
    Array.isArray(i) || (i = [i]);
    for (let n of a.split(" "))
      if (n) {
        let s = [], g = 2, r = n;
        for (let d = 0; ; ) {
          if (r == "..." && d > 0 && d + 3 == n.length) {
            g = 1;
            break;
          }
          let h = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(r);
          if (!h)
            throw new RangeError("Invalid path: " + n);
          if (s.push(h[0] == "*" ? "" : h[0][0] == '"' ? JSON.parse(h[0]) : h[0]), d += h[0].length, d == n.length)
            break;
          let N = n[d++];
          if (d == n.length && N == "!") {
            g = 0;
            break;
          }
          if (N != "/")
            throw new RangeError("Invalid path: " + n);
          r = n.slice(d);
        }
        let m = s.length - 1, c = s[m];
        if (!c)
          throw new RangeError("Invalid path: " + n);
        let v = new q(i, g, m > 0 ? s.slice(0, m) : null);
        t[c] = v.sort(t[c]);
      }
  }
  return J.add(t);
}
const J = new F();
class q {
  constructor(t, a, i, n) {
    this.tags = t, this.mode = a, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
q.empty = new q([], 2, null);
function Q(o, t) {
  let a = /* @__PURE__ */ Object.create(null);
  for (let s of o)
    if (!Array.isArray(s.tag))
      a[s.tag.id] = s.class;
    else
      for (let g of s.tag)
        a[g.id] = s.class;
  let { scope: i, all: n = null } = t || {};
  return {
    style: (s) => {
      let g = n;
      for (let r of s)
        for (let m of r.set) {
          let c = a[m.id];
          if (c) {
            g = g ? g + " " + c : c;
            break;
          }
        }
      return g;
    },
    scope: i
  };
}
function U(o, t) {
  let a = null;
  for (let i of o) {
    let n = i.style(t);
    n && (a = a ? a + " " + n : n);
  }
  return a;
}
function _(o, t, a, i = 0, n = o.length) {
  let s = new W(i, Array.isArray(t) ? t : [t], a);
  s.highlightRange(o.cursor(), i, n, "", s.highlighters), s.flush(n);
}
class W {
  constructor(t, a, i) {
    this.at = t, this.highlighters = a, this.span = i, this.class = "";
  }
  startSpan(t, a) {
    a != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = a);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, a, i, n, s) {
    let { type: g, from: r, to: m } = t;
    if (r >= i || m <= a)
      return;
    g.isTop && (s = this.highlighters.filter((N) => !N.scope || N.scope(g)));
    let c = n, v = X(t) || q.empty, d = U(s, v.tags);
    if (d && (c && (c += " "), c += d, v.mode == 1 && (n += (n ? " " : "") + d)), this.startSpan(Math.max(a, r), c), v.opaque)
      return;
    let h = t.tree && t.tree.prop(F.mounted);
    if (h && h.overlay) {
      let N = t.node.enter(h.overlay[0].from + r, 1), V = this.highlighters.filter((x) => !x.scope || x.scope(h.tree.type)), B = t.firstChild();
      for (let x = 0, M = r; ; x++) {
        let S = x < h.overlay.length ? h.overlay[x] : null, E = S ? S.from + r : m, H = Math.max(a, M), R = Math.min(i, E);
        if (H < R && B)
          for (; t.from < R && (this.highlightRange(t, H, R, n, s), this.startSpan(Math.min(R, t.to), c), !(t.to >= E || !t.nextSibling())); )
            ;
        if (!S || E > i)
          break;
        M = S.to + r, M > a && (this.highlightRange(N.cursor(), Math.max(a, S.from + r), Math.min(i, M), "", V), this.startSpan(Math.min(i, M), c));
      }
      B && t.parent();
    } else if (t.firstChild()) {
      h && (n = "");
      do
        if (!(t.to <= a)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, a, i, n, s), this.startSpan(Math.min(i, t.to), c);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}
function X(o) {
  let t = o.type.prop(J);
  for (; t && t.context && !o.matchContext(t.context); )
    t = t.next;
  return t || null;
}
const e = f.define, A = e(), y = e(), D = e(y), $ = e(y), b = e(), I = e(b), K = e(b), k = e(), w = e(k), p = e(), u = e(), j = e(), O = e(j), T = e(), l = {
  /**
  A comment.
  */
  comment: A,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: e(A),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: e(A),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: e(A),
  /**
  Any kind of identifier.
  */
  name: y,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: e(y),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: D,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: e(D),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: $,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: e($),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: e(y),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: e(y),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: e(y),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: e(y),
  /**
  A literal value.
  */
  literal: b,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: I,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: e(I),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: e(I),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: e(I),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: K,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: e(K),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: e(K),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: e(b),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: e(b),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: e(b),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: e(b),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: e(b),
  /**
  A language keyword.
  */
  keyword: p,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: e(p),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: e(p),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: e(p),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: e(p),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: e(p),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: e(p),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: e(p),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: e(p),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: e(p),
  /**
  An operator.
  */
  operator: u,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: e(u),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: e(u),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: e(u),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: e(u),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: e(u),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: e(u),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: e(u),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: e(u),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: e(u),
  /**
  Program or markup punctuation.
  */
  punctuation: j,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: e(j),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: O,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: e(O),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: e(O),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: e(O),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: e(O),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: k,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: w,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: e(w),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: e(w),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: e(w),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: e(w),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: e(w),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: e(w),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: e(k),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: e(k),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: e(k),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: e(k),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: e(k),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: e(k),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: e(k),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: e(k),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: e(),
  /**
  Deleted text.
  */
  deleted: e(),
  /**
  Changed text.
  */
  changed: e(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: e(),
  /**
  Metadata or meta-instruction.
  */
  meta: T,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: e(T),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: e(T),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: e(T),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: f.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: f.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: f.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: f.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: f.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: f.defineModifier("special")
};
for (let o in l) {
  let t = l[o];
  t instanceof f && (t.name = o);
}
Q([
  { tag: l.link, class: "tok-link" },
  { tag: l.heading, class: "tok-heading" },
  { tag: l.emphasis, class: "tok-emphasis" },
  { tag: l.strong, class: "tok-strong" },
  { tag: l.keyword, class: "tok-keyword" },
  { tag: l.atom, class: "tok-atom" },
  { tag: l.bool, class: "tok-bool" },
  { tag: l.url, class: "tok-url" },
  { tag: l.labelName, class: "tok-labelName" },
  { tag: l.inserted, class: "tok-inserted" },
  { tag: l.deleted, class: "tok-deleted" },
  { tag: l.literal, class: "tok-literal" },
  { tag: l.string, class: "tok-string" },
  { tag: l.number, class: "tok-number" },
  { tag: [l.regexp, l.escape, l.special(l.string)], class: "tok-string2" },
  { tag: l.variableName, class: "tok-variableName" },
  { tag: l.local(l.variableName), class: "tok-variableName tok-local" },
  { tag: l.definition(l.variableName), class: "tok-variableName tok-definition" },
  { tag: l.special(l.variableName), class: "tok-variableName2" },
  { tag: l.definition(l.propertyName), class: "tok-propertyName tok-definition" },
  { tag: l.typeName, class: "tok-typeName" },
  { tag: l.namespace, class: "tok-namespace" },
  { tag: l.className, class: "tok-className" },
  { tag: l.macroName, class: "tok-macroName" },
  { tag: l.propertyName, class: "tok-propertyName" },
  { tag: l.operator, class: "tok-operator" },
  { tag: l.comment, class: "tok-comment" },
  { tag: l.meta, class: "tok-meta" },
  { tag: l.invalid, class: "tok-invalid" },
  { tag: l.punctuation, class: "tok-punctuation" }
]);
export {
  f as Tag,
  X as getStyleTags,
  _ as highlightTree,
  Z as styleTags,
  Q as tagHighlighter,
  l as tags
};
//# sourceMappingURL=index.mjs.map
