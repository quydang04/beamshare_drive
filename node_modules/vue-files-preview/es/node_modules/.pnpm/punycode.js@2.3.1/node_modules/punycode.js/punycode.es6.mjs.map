{"version":3,"file":"punycode.es6.mjs","sources":["../../../../../../../node_modules/.pnpm/punycode.js@2.3.1/node_modules/punycode.js/punycode.es6.js"],"sourcesContent":["'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = callback(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n\tconst parts = domain.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tdomain = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tdomain = domain.replace(regexSeparators, '\\x2E');\n\tconst labels = domain.split('.');\n\tconst encoded = map(labels, callback).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint >= 0x30 && codePoint < 0x3A) {\n\t\treturn 26 + (codePoint - 0x30);\n\t}\n\tif (codePoint >= 0x41 && codePoint < 0x5B) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint >= 0x61 && codePoint < 0x7B) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tconst oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\t\t\tif (digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tconst inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tconst basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue === n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.3.1',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport { ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode };\nexport default punycode;\n"],"names":["delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","stringFromCharCode","error","type","map","array","callback","result","length","mapDomain","domain","parts","labels","encoded","ucs2decode","string","output","counter","value","extra","ucs2encode","codePoints","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","i","n","bias","basic","j","index","oldi","w","t","baseMinusT","out","encode","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","qMinusT","toUnicode","toASCII","punycode"],"mappings":"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","x_google_ignoreList":[0]}