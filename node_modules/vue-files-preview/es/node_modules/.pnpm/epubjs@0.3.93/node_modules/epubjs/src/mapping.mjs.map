{"version":3,"file":"mapping.mjs","sources":["../../../../../../../../node_modules/.pnpm/epubjs@0.3.93/node_modules/epubjs/src/mapping.js"],"sourcesContent":["import EpubCFI from \"./epubcfi\";\nimport { nodeBounds } from \"./utils/core\";\n\n/**\n * Map text locations to CFI ranges\n * @class\n * @param {Layout} layout Layout to apply\n * @param {string} [direction=\"ltr\"] Text direction\n * @param {string} [axis=\"horizontal\"] vertical or horizontal axis\n * @param {boolean} [dev] toggle developer highlighting\n */\nclass Mapping {\n\tconstructor(layout, direction, axis, dev=false) {\n\t\tthis.layout = layout;\n\t\tthis.horizontal = (axis === \"horizontal\") ? true : false;\n\t\tthis.direction = direction || \"ltr\";\n\t\tthis._dev = dev;\n\t}\n\n\t/**\n\t * Find CFI pairs for entire section at once\n\t */\n\tsection(view) {\n\t\tvar ranges = this.findRanges(view);\n\t\tvar map = this.rangeListToCfiList(view.section.cfiBase, ranges);\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Find CFI pairs for a page\n\t * @param {Contents} contents Contents from view\n\t * @param {string} cfiBase string of the base for a cfi\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t */\n\tpage(contents, cfiBase, start, end) {\n\t\tvar root = contents && contents.document ? contents.document.body : false;\n\t\tvar result;\n\n\t\tif (!root) {\n\t\t\treturn;\n\t\t}\n\n\t\tresult = this.rangePairToCfiPair(cfiBase, {\n\t\t\tstart: this.findStart(root, start, end),\n\t\t\tend: this.findEnd(root, start, end)\n\t\t});\n\n\t\tif (this._dev === true) {\n\t\t\tlet doc = contents.document;\n\t\t\tlet startRange = new EpubCFI(result.start).toRange(doc);\n\t\t\tlet endRange = new EpubCFI(result.end).toRange(doc);\n\n\t\t\tlet selection = doc.defaultView.getSelection();\n\t\t\tlet r = doc.createRange();\n\t\t\tselection.removeAllRanges();\n\t\t\tr.setStart(startRange.startContainer, startRange.startOffset);\n\t\t\tr.setEnd(endRange.endContainer, endRange.endOffset);\n\t\t\tselection.addRange(r);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Walk a node, preforming a function on each node it finds\n\t * @private\n\t * @param {Node} root Node to walkToNode\n\t * @param {function} func walk function\n\t * @return {*} returns the result of the walk function\n\t */\n\twalk(root, func) {\n\t\t// IE11 has strange issue, if root is text node IE throws exception on\n\t\t// calling treeWalker.nextNode(), saying\n\t\t// Unexpected call to method or property access instead of returning null value\n\t\tif(root && root.nodeType === Node.TEXT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\t// safeFilter is required so that it can work in IE as filter is a function for IE\n\t\t// and for other browser filter is an object.\n\t\tvar filter = {\n\t\t\tacceptNode: function(node) {\n\t\t\t\tif (node.data.trim().length > 0) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t} else {\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tvar safeFilter = filter.acceptNode;\n\t\tsafeFilter.acceptNode = filter.acceptNode;\n\n\t\tvar treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);\n\t\tvar node;\n\t\tvar result;\n\t\twhile ((node = treeWalker.nextNode())) {\n\t\t\tresult = func(node);\n\t\t\tif(result) break;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfindRanges(view){\n\t\tvar columns = [];\n\t\tvar scrollWidth = view.contents.scrollWidth();\n\t\tvar spreads = Math.ceil( scrollWidth / this.layout.spreadWidth);\n\t\tvar count = spreads * this.layout.divisor;\n\t\tvar columnWidth = this.layout.columnWidth;\n\t\tvar gap = this.layout.gap;\n\t\tvar start, end;\n\n\t\tfor (var i = 0; i < count.pages; i++) {\n\t\t\tstart = (columnWidth + gap) * i;\n\t\t\tend = (columnWidth * (i+1)) + (gap * i);\n\t\t\tcolumns.push({\n\t\t\t\tstart: this.findStart(view.document.body, start, end),\n\t\t\t\tend: this.findEnd(view.document.body, start, end)\n\t\t\t});\n\t\t}\n\n\t\treturn columns;\n\t}\n\n\t/**\n\t * Find Start Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindStart(root, start, end){\n\t\tvar stack = [root];\n\t\tvar $el;\n\t\tvar found;\n\t\tvar $prev = root;\n\n\t\twhile (stack.length) {\n\n\t\t\t$el = stack.shift();\n\n\t\t\tfound = this.walk($el, (node) => {\n\t\t\t\tvar left, right, top, bottom;\n\t\t\t\tvar elPos;\n\t\t\t\tvar elRange;\n\n\n\t\t\t\telPos = nodeBounds(node);\n\n\t\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\t\tleft = this.horizontal ? elPos.left : elPos.top;\n\t\t\t\t\tright = this.horizontal ? elPos.right : elPos.bottom;\n\n\t\t\t\t\tif( left >= start && left <= end ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (right > start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\t\tleft = elPos.left;\n\t\t\t\t\tright = elPos.right;\n\n\t\t\t\t\tif( right <= end && right >= start ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (left < end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttop = elPos.top;\n\t\t\t\t\tbottom = elPos.bottom;\n\n\t\t\t\t\tif( top >= start && top <= end ) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else if (bottom > start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t});\n\n\t\t\tif(found) {\n\t\t\t\treturn this.findTextStartRange(found, start, end);\n\t\t\t}\n\n\t\t}\n\n\t\t// Return last element\n\t\treturn this.findTextStartRange($prev, start, end);\n\t}\n\n\t/**\n\t * Find End Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindEnd(root, start, end){\n\t\tvar stack = [root];\n\t\tvar $el;\n\t\tvar $prev = root;\n\t\tvar found;\n\n\t\twhile (stack.length) {\n\n\t\t\t$el = stack.shift();\n\n\t\t\tfound = this.walk($el, (node) => {\n\n\t\t\t\tvar left, right, top, bottom;\n\t\t\t\tvar elPos;\n\t\t\t\tvar elRange;\n\n\t\t\t\telPos = nodeBounds(node);\n\n\t\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\t\tleft = Math.round(elPos.left);\n\t\t\t\t\tright = Math.round(elPos.right);\n\n\t\t\t\t\tif(left > end && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(right > end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\t\tleft = Math.round(this.horizontal ? elPos.left : elPos.top);\n\t\t\t\t\tright = Math.round(this.horizontal ? elPos.right : elPos.bottom);\n\n\t\t\t\t\tif(right < start && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(left < start) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttop = Math.round(elPos.top);\n\t\t\t\t\tbottom = Math.round(elPos.bottom);\n\n\t\t\t\t\tif(top > end && $prev) {\n\t\t\t\t\t\treturn $prev;\n\t\t\t\t\t} else if(bottom > end) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$prev = node;\n\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t});\n\n\n\t\t\tif(found){\n\t\t\t\treturn this.findTextEndRange(found, start, end);\n\t\t\t}\n\n\t\t}\n\n\t\t// end of chapter\n\t\treturn this.findTextEndRange($prev, start, end);\n\t}\n\n\t/**\n\t * Find Text Start Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindTextStartRange(node, start, end){\n\t\tvar ranges = this.splitTextNodeIntoRanges(node);\n\t\tvar range;\n\t\tvar pos;\n\t\tvar left, top, right;\n\n\t\tfor (var i = 0; i < ranges.length; i++) {\n\t\t\trange = ranges[i];\n\n\t\t\tpos = range.getBoundingClientRect();\n\n\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\tleft = pos.left;\n\t\t\t\tif( left >= start ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\tright = pos.right;\n\t\t\t\tif( right <= end ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttop = pos.top;\n\t\t\t\tif( top >= start ) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// prev = range;\n\n\t\t}\n\n\t\treturn ranges[0];\n\t}\n\n\t/**\n\t * Find Text End Range\n\t * @private\n\t * @param {Node} root root node\n\t * @param {number} start position to start at\n\t * @param {number} end position to end at\n\t * @return {Range}\n\t */\n\tfindTextEndRange(node, start, end){\n\t\tvar ranges = this.splitTextNodeIntoRanges(node);\n\t\tvar prev;\n\t\tvar range;\n\t\tvar pos;\n\t\tvar left, right, top, bottom;\n\n\t\tfor (var i = 0; i < ranges.length; i++) {\n\t\t\trange = ranges[i];\n\n\t\t\tpos = range.getBoundingClientRect();\n\n\t\t\tif (this.horizontal && this.direction === \"ltr\") {\n\n\t\t\t\tleft = pos.left;\n\t\t\t\tright = pos.right;\n\n\t\t\t\tif(left > end && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(right > end) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else if (this.horizontal && this.direction === \"rtl\") {\n\n\t\t\t\tleft = pos.left\n\t\t\t\tright = pos.right;\n\n\t\t\t\tif(right < start && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(left < start) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttop = pos.top;\n\t\t\t\tbottom = pos.bottom;\n\n\t\t\t\tif(top > end && prev) {\n\t\t\t\t\treturn prev;\n\t\t\t\t} else if(bottom > end) {\n\t\t\t\t\treturn range;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tprev = range;\n\n\t\t}\n\n\t\t// Ends before limit\n\t\treturn ranges[ranges.length-1];\n\n\t}\n\n\t/**\n\t * Split up a text node into ranges for each word\n\t * @private\n\t * @param {Node} root root node\n\t * @param {string} [_splitter] what to split on\n\t * @return {Range[]}\n\t */\n\tsplitTextNodeIntoRanges(node, _splitter){\n\t\tvar ranges = [];\n\t\tvar textContent = node.textContent || \"\";\n\t\tvar text = textContent.trim();\n\t\tvar range;\n\t\tvar doc = node.ownerDocument;\n\t\tvar splitter = _splitter || \" \";\n\n\t\tvar pos = text.indexOf(splitter);\n\n\t\tif(pos === -1 || node.nodeType != Node.TEXT_NODE) {\n\t\t\trange = doc.createRange();\n\t\t\trange.selectNodeContents(node);\n\t\t\treturn [range];\n\t\t}\n\n\t\trange = doc.createRange();\n\t\trange.setStart(node, 0);\n\t\trange.setEnd(node, pos);\n\t\tranges.push(range);\n\t\trange = false;\n\n\t\twhile ( pos != -1 ) {\n\n\t\t\tpos = text.indexOf(splitter, pos + 1);\n\t\t\tif(pos > 0) {\n\n\t\t\t\tif(range) {\n\t\t\t\t\trange.setEnd(node, pos);\n\t\t\t\t\tranges.push(range);\n\t\t\t\t}\n\n\t\t\t\trange = doc.createRange();\n\t\t\t\trange.setStart(node, pos+1);\n\t\t\t}\n\t\t}\n\n\t\tif(range) {\n\t\t\trange.setEnd(node, text.length);\n\t\t\tranges.push(range);\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\n\t/**\n\t * Turn a pair of ranges into a pair of CFIs\n\t * @private\n\t * @param {string} cfiBase base string for an EpubCFI\n\t * @param {object} rangePair { start: Range, end: Range }\n\t * @return {object} { start: \"epubcfi(...)\", end: \"epubcfi(...)\" }\n\t */\n\trangePairToCfiPair(cfiBase, rangePair){\n\n\t\tvar startRange = rangePair.start;\n\t\tvar endRange = rangePair.end;\n\n\t\tstartRange.collapse(true);\n\t\tendRange.collapse(false);\n\n\t\tlet startCfi = new EpubCFI(startRange, cfiBase).toString();\n\t\tlet endCfi = new EpubCFI(endRange, cfiBase).toString();\n\n\t\treturn {\n\t\t\tstart: startCfi,\n\t\t\tend: endCfi\n\t\t};\n\n\t}\n\n\trangeListToCfiList(cfiBase, columns){\n\t\tvar map = [];\n\t\tvar cifPair;\n\n\t\tfor (var i = 0; i < columns.length; i++) {\n\t\t\tcifPair = this.rangePairToCfiPair(cfiBase, columns[i]);\n\n\t\t\tmap.push(cifPair);\n\n\t\t}\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Set the axis for mapping\n\t * @param {string} axis horizontal | vertical\n\t * @return {boolean} is it horizontal?\n\t */\n\taxis(axis) {\n\t\tif (axis) {\n\t\t\tthis.horizontal = (axis === \"horizontal\") ? true : false;\n\t\t}\n\t\treturn this.horizontal;\n\t}\n}\n\nexport default Mapping;\n"],"names":["Mapping","layout","direction","axis","dev","view","ranges","map","contents","cfiBase","start","end","root","result","doc","startRange","EpubCFI","endRange","selection","r","func","filter","node","safeFilter","treeWalker","columns","scrollWidth","spreads","count","columnWidth","gap","i","stack","$el","found","$prev","left","right","top","bottom","elPos","nodeBounds","range","pos","prev","_splitter","textContent","text","splitter","rangePair","startCfi","endCfi","cifPair"],"mappings":";;AAWA,MAAMA,EAAQ;AAAA,EACb,YAAYC,GAAQC,GAAWC,GAAMC,IAAI,IAAO;AAC/C,SAAK,SAASH,GACd,KAAK,aAAcE,MAAS,cAC5B,KAAK,YAAYD,KAAa,OAC9B,KAAK,OAAOE;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA,EAKD,QAAQC,GAAM;AACb,QAAIC,IAAS,KAAK,WAAWD,CAAI,GAC7BE,IAAM,KAAK,mBAAmBF,EAAK,QAAQ,SAASC,CAAM;AAE9D,WAAOC;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,KAAKC,GAAUC,GAASC,GAAOC,GAAK;AACnC,QAAIC,IAAOJ,KAAYA,EAAS,WAAWA,EAAS,SAAS,OAAO,IAChEK;AAEJ,QAAKD,GASL;AAAA,UALAC,IAAS,KAAK,mBAAmBJ,GAAS;AAAA,QACzC,OAAO,KAAK,UAAUG,GAAMF,GAAOC,CAAG;AAAA,QACtC,KAAK,KAAK,QAAQC,GAAMF,GAAOC,CAAG;AAAA,MACrC,CAAG,GAEG,KAAK,SAAS,IAAM;AACvB,YAAIG,IAAMN,EAAS,UACfO,IAAa,IAAIC,EAAQH,EAAO,KAAK,EAAE,QAAQC,CAAG,GAClDG,IAAW,IAAID,EAAQH,EAAO,GAAG,EAAE,QAAQC,CAAG,GAE9CI,IAAYJ,EAAI,YAAY,aAAY,GACxCK,IAAIL,EAAI;AACZ,QAAAI,EAAU,gBAAe,GACzBC,EAAE,SAASJ,EAAW,gBAAgBA,EAAW,WAAW,GAC5DI,EAAE,OAAOF,EAAS,cAAcA,EAAS,SAAS,GAClDC,EAAU,SAASC,CAAC;AAAA,MACpB;AAED,aAAON;AAAA;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,KAAKD,GAAMQ,GAAM;AAIhB,QAAG,EAAAR,KAAQA,EAAK,aAAa,KAAK,YAKlC;AAAA,UAAIS,IAAS;AAAA,QACZ,YAAY,SAASC,GAAM;AAC1B,iBAAIA,EAAK,KAAK,KAAI,EAAG,SAAS,IACtB,WAAW,gBAEX,WAAW;AAAA,QAEnB;AAAA,MACJ,GACMC,IAAaF,EAAO;AACxB,MAAAE,EAAW,aAAaF,EAAO;AAK/B,eAHIG,IAAa,SAAS,iBAAiBZ,GAAM,WAAW,WAAWW,GAAY,EAAK,GACpFD,GACAT,IACIS,IAAOE,EAAW,gBACzBX,IAASO,EAAKE,CAAI,GACf,CAAAT;AAAH;AAGD,aAAOA;AAAA;AAAA,EACP;AAAA,EAED,WAAWR,GAAK;AASf,aARIoB,IAAU,CAAA,GACVC,IAAcrB,EAAK,SAAS,YAAW,GACvCsB,IAAU,KAAK,KAAMD,IAAc,KAAK,OAAO,WAAW,GAC1DE,IAAQD,IAAU,KAAK,OAAO,SAC9BE,IAAc,KAAK,OAAO,aAC1BC,IAAM,KAAK,OAAO,KAClBpB,GAAOC,GAEFoB,IAAI,GAAGA,IAAIH,EAAM,OAAOG;AAChC,MAAArB,KAASmB,IAAcC,KAAOC,GAC9BpB,IAAOkB,KAAeE,IAAE,KAAOD,IAAMC,GACrCN,EAAQ,KAAK;AAAA,QACZ,OAAO,KAAK,UAAUpB,EAAK,SAAS,MAAMK,GAAOC,CAAG;AAAA,QACpD,KAAK,KAAK,QAAQN,EAAK,SAAS,MAAMK,GAAOC,CAAG;AAAA,MACpD,CAAI;AAGF,WAAOc;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,UAAUb,GAAMF,GAAOC,GAAI;AAM1B,aALIqB,IAAQ,CAACpB,CAAI,GACbqB,GACAC,GACAC,IAAQvB,GAELoB,EAAM;AA2DZ,UAzDAC,IAAMD,EAAM,SAEZE,IAAQ,KAAK,KAAKD,GAAK,CAACX,MAAS;AAChC,YAAIc,GAAMC,GAAOC,GAAKC,GAClBC;AAMJ,YAFAA,IAAQC,EAAWnB,CAAI,GAEnB,KAAK,cAAc,KAAK,cAAc,OAAO;AAKhD,cAHAc,IAAO,KAAK,aAAaI,EAAM,OAAOA,EAAM,KAC5CH,IAAQ,KAAK,aAAaG,EAAM,QAAQA,EAAM,QAE1CJ,KAAQ1B,KAAS0B,KAAQzB;AAC5B,mBAAOW;AACD,cAAIe,IAAQ3B;AAClB,mBAAOY;AAEP,UAAAa,IAAQb,GACRU,EAAM,KAAKV,CAAI;AAAA,QAGhB,WAAU,KAAK,cAAc,KAAK,cAAc,OAAO;AAKvD,cAHAc,IAAOI,EAAM,MACbH,IAAQG,EAAM,OAEVH,KAAS1B,KAAO0B,KAAS3B;AAC5B,mBAAOY;AACD,cAAIc,IAAOzB;AACjB,mBAAOW;AAEP,UAAAa,IAAQb,GACRU,EAAM,KAAKV,CAAI;AAAA,QAGrB,OAAW;AAKN,cAHAgB,IAAME,EAAM,KACZD,IAASC,EAAM,QAEXF,KAAO5B,KAAS4B,KAAO3B;AAC1B,mBAAOW;AACD,cAAIiB,IAAS7B;AACnB,mBAAOY;AAEP,UAAAa,IAAQb,GACRU,EAAM,KAAKV,CAAI;AAAA,QAGhB;AAAA,MAGL,CAAI,GAEEY;AACF,eAAO,KAAK,mBAAmBA,GAAOxB,GAAOC,CAAG;AAMlD,WAAO,KAAK,mBAAmBwB,GAAOzB,GAAOC,CAAG;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,QAAQC,GAAMF,GAAOC,GAAI;AAMxB,aALIqB,IAAQ,CAACpB,CAAI,GACbqB,GACAE,IAAQvB,GACRsB,GAEGF,EAAM;AA2DZ,UAzDAC,IAAMD,EAAM,SAEZE,IAAQ,KAAK,KAAKD,GAAK,CAACX,MAAS;AAEhC,YAAIc,GAAMC,GAAOC,GAAKC,GAClBC;AAKJ,YAFAA,IAAQC,EAAWnB,CAAI,GAEnB,KAAK,cAAc,KAAK,cAAc,OAAO;AAKhD,cAHAc,IAAO,KAAK,MAAMI,EAAM,IAAI,GAC5BH,IAAQ,KAAK,MAAMG,EAAM,KAAK,GAE3BJ,IAAOzB,KAAOwB;AAChB,mBAAOA;AACD,cAAGE,IAAQ1B;AACjB,mBAAOW;AAEP,UAAAa,IAAQb,GACRU,EAAM,KAAKV,CAAI;AAAA,QAGhB,WAAU,KAAK,cAAc,KAAK,cAAc,OAAO;AAKvD,cAHAc,IAAO,KAAK,MAAM,KAAK,aAAaI,EAAM,OAAOA,EAAM,GAAG,GAC1DH,IAAQ,KAAK,MAAM,KAAK,aAAaG,EAAM,QAAQA,EAAM,MAAM,GAE5DH,IAAQ3B,KAASyB;AACnB,mBAAOA;AACD,cAAGC,IAAO1B;AAChB,mBAAOY;AAEP,UAAAa,IAAQb,GACRU,EAAM,KAAKV,CAAI;AAAA,QAGrB,OAAW;AAKN,cAHAgB,IAAM,KAAK,MAAME,EAAM,GAAG,GAC1BD,IAAS,KAAK,MAAMC,EAAM,MAAM,GAE7BF,IAAM3B,KAAOwB;AACf,mBAAOA;AACD,cAAGI,IAAS5B;AAClB,mBAAOW;AAEP,UAAAa,IAAQb,GACRU,EAAM,KAAKV,CAAI;AAAA,QAGhB;AAAA,MAEL,CAAI,GAGEY;AACF,eAAO,KAAK,iBAAiBA,GAAOxB,GAAOC,CAAG;AAMhD,WAAO,KAAK,iBAAiBwB,GAAOzB,GAAOC,CAAG;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,mBAAmBW,GAAMZ,GAAOC,GAAI;AAMnC,aALIL,IAAS,KAAK,wBAAwBgB,CAAI,GAC1CoB,GACAC,GACAP,GAAME,GAAKD,GAENN,IAAI,GAAGA,IAAIzB,EAAO,QAAQyB;AAKlC,UAJAW,IAAQpC,EAAOyB,CAAC,GAEhBY,IAAMD,EAAM,yBAER,KAAK,cAAc,KAAK,cAAc;AAGzC,YADAN,IAAOO,EAAI,MACPP,KAAQ1B;AACX,iBAAOgC;AAAA,iBAGE,KAAK,cAAc,KAAK,cAAc;AAGhD,YADAL,IAAQM,EAAI,OACRN,KAAS1B;AACZ,iBAAO+B;AAAA,iBAKRJ,IAAMK,EAAI,KACNL,KAAO5B;AACV,eAAOgC;AASV,WAAOpC,EAAO,CAAC;AAAA,EACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,iBAAiBgB,GAAMZ,GAAOC,GAAI;AAOjC,aANIL,IAAS,KAAK,wBAAwBgB,CAAI,GAC1CsB,GACAF,GACAC,GACAP,GAAMC,GAAOC,GAAKC,GAEbR,IAAI,GAAGA,IAAIzB,EAAO,QAAQyB,KAAK;AAKvC,UAJAW,IAAQpC,EAAOyB,CAAC,GAEhBY,IAAMD,EAAM,yBAER,KAAK,cAAc,KAAK,cAAc,OAAO;AAKhD,YAHAN,IAAOO,EAAI,MACXN,IAAQM,EAAI,OAETP,IAAOzB,KAAOiC;AAChB,iBAAOA;AACD,YAAGP,IAAQ1B;AACjB,iBAAO+B;AAAA,MAGR,WAAU,KAAK,cAAc,KAAK,cAAc,OAAO;AAKvD,YAHAN,IAAOO,EAAI,MACXN,IAAQM,EAAI,OAETN,IAAQ3B,KAASkC;AACnB,iBAAOA;AACD,YAAGR,IAAO1B;AAChB,iBAAOgC;AAAA,MAGZ,OAAU;AAKN,YAHAJ,IAAMK,EAAI,KACVJ,IAASI,EAAI,QAEVL,IAAM3B,KAAOiC;AACf,iBAAOA;AACD,YAAGL,IAAS5B;AAClB,iBAAO+B;AAAA,MAGR;AAGD,MAAAE,IAAOF;AAAA,IAEP;AAGD,WAAOpC,EAAOA,EAAO,SAAO,CAAC;AAAA,EAE7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,wBAAwBgB,GAAMuB,GAAU;AACvC,QAAIvC,IAAS,CAAA,GACTwC,IAAcxB,EAAK,eAAe,IAClCyB,IAAOD,EAAY,QACnBJ,GACA5B,IAAMQ,EAAK,eACX0B,IAAWH,KAAa,KAExBF,IAAMI,EAAK,QAAQC,CAAQ;AAE/B,QAAGL,MAAQ,MAAMrB,EAAK,YAAY,KAAK;AACtC,aAAAoB,IAAQ5B,EAAI,eACZ4B,EAAM,mBAAmBpB,CAAI,GACtB,CAACoB,CAAK;AASd,SANAA,IAAQ5B,EAAI,eACZ4B,EAAM,SAASpB,GAAM,CAAC,GACtBoB,EAAM,OAAOpB,GAAMqB,CAAG,GACtBrC,EAAO,KAAKoC,CAAK,GACjBA,IAAQ,IAEAC,KAAO;AAEd,MAAAA,IAAMI,EAAK,QAAQC,GAAUL,IAAM,CAAC,GACjCA,IAAM,MAELD,MACFA,EAAM,OAAOpB,GAAMqB,CAAG,GACtBrC,EAAO,KAAKoC,CAAK,IAGlBA,IAAQ5B,EAAI,eACZ4B,EAAM,SAASpB,GAAMqB,IAAI,CAAC;AAI5B,WAAGD,MACFA,EAAM,OAAOpB,GAAMyB,EAAK,MAAM,GAC9BzC,EAAO,KAAKoC,CAAK,IAGXpC;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,mBAAmBG,GAASwC,GAAU;AAErC,QAAIlC,IAAakC,EAAU,OACvBhC,IAAWgC,EAAU;AAEzB,IAAAlC,EAAW,SAAS,EAAI,GACxBE,EAAS,SAAS,EAAK;AAEvB,QAAIiC,IAAW,IAAIlC,EAAQD,GAAYN,CAAO,EAAE,YAC5C0C,IAAS,IAAInC,EAAQC,GAAUR,CAAO,EAAE;AAE5C,WAAO;AAAA,MACN,OAAOyC;AAAA,MACP,KAAKC;AAAA,IACR;AAAA,EAEE;AAAA,EAED,mBAAmB1C,GAASgB,GAAQ;AAInC,aAHIlB,IAAM,CAAA,GACN6C,GAEKrB,IAAI,GAAGA,IAAIN,EAAQ,QAAQM;AACnC,MAAAqB,IAAU,KAAK,mBAAmB3C,GAASgB,EAAQM,CAAC,CAAC,GAErDxB,EAAI,KAAK6C,CAAO;AAIjB,WAAO7C;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,KAAKJ,GAAM;AACV,WAAIA,MACH,KAAK,aAAcA,MAAS,eAEtB,KAAK;AAAA,EACZ;AACF;","x_google_ignoreList":[0]}