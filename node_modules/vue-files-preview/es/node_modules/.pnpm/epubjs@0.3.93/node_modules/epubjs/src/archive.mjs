import { defer as d, isXml as l, parse as h } from "./utils/core.mjs";
import f from "./utils/request.mjs";
import c from "./utils/mime.mjs";
import u from "./utils/path.mjs";
import w from "../../../../jszip@3.10.1/node_modules/jszip/dist/jszip.mjs";
class L {
  constructor() {
    this.zip = void 0, this.urlCache = {}, this.checkRequirements();
  }
  /**
   * Checks to see if JSZip exists in global namspace,
   * Requires JSZip if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      this.zip = new w();
    } catch {
      throw new Error("JSZip lib not loaded");
    }
  }
  /**
   * Open an archive
   * @param  {binary} input
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  open(e, t) {
    return this.zip.loadAsync(e, { base64: t });
  }
  /**
   * Load and Open an archive
   * @param  {string} zipUrl
   * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
   * @return {Promise} zipfile
   */
  openUrl(e, t) {
    return f(e, "binary").then((function(r) {
      return this.zip.loadAsync(r, { base64: t });
    }).bind(this));
  }
  /**
   * Request a url from the archive
   * @param  {string} url  a url to request from the archive
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(e, t) {
    var r = new d(), i, n = new u(e);
    return t || (t = n.extension), t == "blob" ? i = this.getBlob(e) : i = this.getText(e), i ? i.then((function(o) {
      let a = this.handleResponse(o, t);
      r.resolve(a);
    }).bind(this)) : r.reject({
      message: "File not found in the epub: " + e,
      stack: new Error().stack
    }), r.promise;
  }
  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(e, t) {
    var r;
    return t == "json" ? r = JSON.parse(e) : l(t) ? r = h(e, "text/xml") : t == "xhtml" ? r = h(e, "application/xhtml+xml") : t == "html" || t == "htm" ? r = h(e, "text/html") : r = e, r;
  }
  /**
   * Get a Blob from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(e, t) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return t = t || c.lookup(i.name), i.async("uint8array").then(function(n) {
        return new Blob([n], { type: t });
      });
  }
  /**
   * Get Text from Archive by Url
   * @param  {string} url
   * @param  {string} [encoding]
   * @return {string}
   */
  getText(e, t) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return i.async("string").then(function(n) {
        return n;
      });
  }
  /**
   * Get a base64 encoded result from Archive by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(e, t) {
    var r = window.decodeURIComponent(e.substr(1)), i = this.zip.file(r);
    if (i)
      return t = t || c.lookup(i.name), i.async("base64").then(function(n) {
        return "data:" + t + ";base64," + n;
      });
  }
  /**
   * Create a Url from an unarchived item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(e, t) {
    var r = new d(), i = window.URL || window.webkitURL || window.mozURL, n, o, a = t && t.base64;
    return e in this.urlCache ? (r.resolve(this.urlCache[e]), r.promise) : (a ? (o = this.getBase64(e), o && o.then((function(s) {
      this.urlCache[e] = s, r.resolve(s);
    }).bind(this))) : (o = this.getBlob(e), o && o.then((function(s) {
      n = i.createObjectURL(s), this.urlCache[e] = n, r.resolve(n);
    }).bind(this))), o || r.reject({
      message: "File not found in the epub: " + e,
      stack: new Error().stack
    }), r.promise);
  }
  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the archive
   */
  revokeUrl(e) {
    var t = window.URL || window.webkitURL || window.mozURL, r = this.urlCache[e];
    r && t.revokeObjectURL(r);
  }
  destroy() {
    var e = window.URL || window.webkitURL || window.mozURL;
    for (let t in this.urlCache)
      e.revokeObjectURL(t);
    this.zip = void 0, this.urlCache = {};
  }
}
export {
  L as default
};
//# sourceMappingURL=archive.mjs.map
