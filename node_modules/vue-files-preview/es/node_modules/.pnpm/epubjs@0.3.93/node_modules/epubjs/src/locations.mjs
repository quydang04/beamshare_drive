import { defer as m, qs as v, sprint as C, locationOf as w } from "./utils/core.mjs";
import q from "./utils/queue.mjs";
import c from "./epubcfi.mjs";
import { EVENTS as W } from "./utils/constants.mjs";
import y from "../../../../event-emitter@0.3.5/node_modules/event-emitter/index.mjs";
class F {
  constructor(t, e, n) {
    this.spine = t, this.request = e, this.pause = n || 100, this.q = new q(this), this.epubcfi = new c(), this._locations = [], this._locationsWords = [], this.total = 0, this.break = 150, this._current = 0, this._wordCounter = 0, this.currentLocation = "", this._currentCfi = "", this.processingTimeout = void 0;
  }
  /**
   * Load all of sections in the book to generate locations
   * @param  {int} chars how many chars to split on
   * @return {Promise<Array<string>>} locations
   */
  generate(t) {
    return t && (this.break = t), this.q.pause(), this.spine.each((function(e) {
      e.linear && this.q.enqueue(this.process.bind(this), e);
    }).bind(this)), this.q.run().then((function() {
      return this.total = this._locations.length - 1, this._currentCfi && (this.currentLocation = this._currentCfi), this._locations;
    }).bind(this));
  }
  createRange() {
    return {
      startContainer: void 0,
      startOffset: void 0,
      endContainer: void 0,
      endOffset: void 0
    };
  }
  process(t) {
    return t.load(this.request).then((function(e) {
      var n = new m(), i = this.parse(e, t.cfiBase);
      return this._locations = this._locations.concat(i), t.unload(), this.processingTimeout = setTimeout(() => n.resolve(i), this.pause), n.promise;
    }).bind(this));
  }
  parse(t, e, n) {
    var i = [], r, d = t.ownerDocument, f = v(d, "body"), h = 0, p, _ = n || this.break, g = function(u) {
      var a = u.length, o, s = 0;
      if (u.textContent.trim().length === 0)
        return !1;
      for (h == 0 && (r = this.createRange(), r.startContainer = u, r.startOffset = 0), o = _ - h, o > a && (h += a, s = a); s < a; )
        if (o = _ - h, h === 0 && (s += 1, r = this.createRange(), r.startContainer = u, r.startOffset = s), s + o >= a)
          h += a - s, s = a;
        else {
          s += o, r.endContainer = u, r.endOffset = s;
          let l = new c(r, e).toString();
          i.push(l), h = 0;
        }
      p = u;
    };
    if (C(f, g.bind(this)), r && r.startContainer && p) {
      r.endContainer = p, r.endOffset = p.length;
      let u = new c(r, e).toString();
      i.push(u), h = 0;
    }
    return i;
  }
  /**
   * Load all of sections in the book to generate locations
   * @param  {string} startCfi start position
   * @param  {int} wordCount how many words to split on
   * @param  {int} count result count
   * @return {object} locations
   */
  generateFromWords(t, e, n) {
    var i = t ? new c(t) : void 0;
    return this.q.pause(), this._locationsWords = [], this._wordCounter = 0, this.spine.each((function(r) {
      r.linear && (i ? r.index >= i.spinePos && this.q.enqueue(this.processWords.bind(this), r, e, i, n) : this.q.enqueue(this.processWords.bind(this), r, e, i, n));
    }).bind(this)), this.q.run().then((function() {
      return this._currentCfi && (this.currentLocation = this._currentCfi), this._locationsWords;
    }).bind(this));
  }
  processWords(t, e, n, i) {
    return i && this._locationsWords.length >= i ? Promise.resolve() : t.load(this.request).then((function(r) {
      var d = new m(), f = this.parseWords(r, t, e, n), h = i - this._locationsWords.length;
      return this._locationsWords = this._locationsWords.concat(f.length >= i ? f.slice(0, h) : f), t.unload(), this.processingTimeout = setTimeout(() => d.resolve(f), this.pause), d.promise;
    }).bind(this));
  }
  //http://stackoverflow.com/questions/18679576/counting-words-in-string
  countWords(t) {
    return t = t.replace(/(^\s*)|(\s*$)/gi, ""), t = t.replace(/[ ]{2,}/gi, " "), t = t.replace(/\n /, `
`), t.split(" ").length;
  }
  parseWords(t, e, n, i) {
    var r = e.cfiBase, d = [], f = t.ownerDocument, h = v(f, "body"), p = n, _ = i ? i.spinePos !== e.index : !0, g;
    i && e.index === i.spinePos && (g = i.findNode(i.range ? i.path.steps.concat(i.start.steps) : i.path.steps, t.ownerDocument));
    var u = function(a) {
      if (!_)
        if (a === g)
          _ = !0;
        else
          return !1;
      if (a.textContent.length < 10 && a.textContent.trim().length === 0)
        return !1;
      var o = this.countWords(a.textContent), s, l = 0;
      if (o === 0)
        return !1;
      for (s = p - this._wordCounter, s > o && (this._wordCounter += o, l = o); l < o; )
        if (s = p - this._wordCounter, l + s >= o)
          this._wordCounter += o - l, l = o;
        else {
          l += s;
          let b = new c(a, r);
          d.push({ cfi: b.toString(), wordCount: this._wordCounter }), this._wordCounter = 0;
        }
    };
    return C(h, u.bind(this)), d;
  }
  /**
   * Get a location from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  locationFromCfi(t) {
    let e;
    return c.prototype.isCfiString(t) && (t = new c(t)), this._locations.length === 0 ? -1 : (e = w(t, this._locations, this.epubcfi.compare), e > this.total ? this.total : e);
  }
  /**
   * Get a percentage position in locations from an EpubCFI
   * @param {EpubCFI} cfi
   * @return {number}
   */
  percentageFromCfi(t) {
    if (this._locations.length === 0)
      return null;
    var e = this.locationFromCfi(t);
    return this.percentageFromLocation(e);
  }
  /**
   * Get a percentage position from a location index
   * @param {number} location
   * @return {number}
   */
  percentageFromLocation(t) {
    return !t || !this.total ? 0 : t / this.total;
  }
  /**
   * Get an EpubCFI from location index
   * @param {number} loc
   * @return {EpubCFI} cfi
   */
  cfiFromLocation(t) {
    var e = -1;
    return typeof t != "number" && (t = parseInt(t)), t >= 0 && t < this._locations.length && (e = this._locations[t]), e;
  }
  /**
   * Get an EpubCFI from location percentage
   * @param {number} percentage
   * @return {EpubCFI} cfi
   */
  cfiFromPercentage(t) {
    let e;
    if (t > 1 && console.warn("Normalize cfiFromPercentage value to between 0 - 1"), t >= 1) {
      let n = new c(this._locations[this.total]);
      return n.collapse(), n.toString();
    }
    return e = Math.ceil(this.total * t), this.cfiFromLocation(e);
  }
  /**
   * Load locations from JSON
   * @param {json} locations
   */
  load(t) {
    return typeof t == "string" ? this._locations = JSON.parse(t) : this._locations = t, this.total = this._locations.length - 1, this._locations;
  }
  /**
   * Save locations to JSON
   * @return {json}
   */
  save() {
    return JSON.stringify(this._locations);
  }
  getCurrent() {
    return this._current;
  }
  setCurrent(t) {
    var e;
    if (typeof t == "string")
      this._currentCfi = t;
    else if (typeof t == "number")
      this._current = t;
    else
      return;
    this._locations.length !== 0 && (typeof t == "string" ? (e = this.locationFromCfi(t), this._current = e) : e = t, this.emit(W.LOCATIONS.CHANGED, {
      percentage: this.percentageFromLocation(e)
    }));
  }
  /**
   * Get the current location
   */
  get currentLocation() {
    return this._current;
  }
  /**
   * Set the current location
   */
  set currentLocation(t) {
    this.setCurrent(t);
  }
  /**
   * Locations length
   */
  length() {
    return this._locations.length;
  }
  destroy() {
    this.spine = void 0, this.request = void 0, this.pause = void 0, this.q.stop(), this.q = void 0, this.epubcfi = void 0, this._locations = void 0, this.total = void 0, this.break = void 0, this._current = void 0, this.currentLocation = void 0, this._currentCfi = void 0, clearTimeout(this.processingTimeout);
  }
}
y(F.prototype);
export {
  F as default
};
//# sourceMappingURL=locations.mjs.map
