import y from "../../../../event-emitter@0.3.5/node_modules/event-emitter/index.mjs";
import { extend as c, defer as r } from "./utils/core.mjs";
import a from "./utils/url.mjs";
import g from "./utils/path.mjs";
import w from "./spine.mjs";
import b from "./locations.mjs";
import O from "./container.mjs";
import f from "./packaging.mjs";
import d from "./navigation.mjs";
import P from "./resources.mjs";
import l from "./pagelist.mjs";
import k from "./rendition.mjs";
import E from "./archive.mjs";
import v from "./utils/request.mjs";
import q from "./epubcfi.mjs";
import A from "./store.mjs";
import p from "./displayoptions.mjs";
import { EVENTS as I, EPUBJS_VERSION as L } from "./utils/constants.mjs";
const m = "META-INF/container.xml", N = "META-INF/com.apple.ibooks.display-options.xml", n = {
  BINARY: "binary",
  BASE64: "base64",
  EPUB: "epub",
  OPF: "opf",
  MANIFEST: "json",
  DIRECTORY: "directory"
};
class R {
  constructor(e, i) {
    typeof i > "u" && typeof e != "string" && !(e instanceof Blob) && !(e instanceof ArrayBuffer) && (i = e, e = void 0), this.settings = c(this.settings || {}, {
      requestMethod: void 0,
      requestCredentials: void 0,
      requestHeaders: void 0,
      encoding: void 0,
      replacements: void 0,
      canonical: void 0,
      openAs: void 0,
      store: void 0
    }), c(this.settings, i), this.opening = new r(), this.opened = this.opening.promise, this.isOpen = !1, this.loading = {
      manifest: new r(),
      spine: new r(),
      metadata: new r(),
      cover: new r(),
      navigation: new r(),
      pageList: new r(),
      resources: new r(),
      displayOptions: new r()
    }, this.loaded = {
      manifest: this.loading.manifest.promise,
      spine: this.loading.spine.promise,
      metadata: this.loading.metadata.promise,
      cover: this.loading.cover.promise,
      navigation: this.loading.navigation.promise,
      pageList: this.loading.pageList.promise,
      resources: this.loading.resources.promise,
      displayOptions: this.loading.displayOptions.promise
    }, this.ready = Promise.all([
      this.loaded.manifest,
      this.loaded.spine,
      this.loaded.metadata,
      this.loaded.cover,
      this.loaded.navigation,
      this.loaded.resources,
      this.loaded.displayOptions
    ]), this.isRendered = !1, this.request = this.settings.requestMethod || v, this.spine = new w(), this.locations = new b(this.spine, this.load.bind(this)), this.navigation = void 0, this.pageList = void 0, this.url = void 0, this.path = void 0, this.archived = !1, this.archive = void 0, this.storage = void 0, this.resources = void 0, this.rendition = void 0, this.container = void 0, this.packaging = void 0, this.displayOptions = void 0, this.settings.store && this.store(this.settings.store), e && this.open(e, this.settings.openAs).catch((s) => {
      var t = new Error("Cannot load book at " + e);
      this.emit(I.BOOK.OPEN_FAILED, t);
    });
  }
  /**
   * Open a epub or url
   * @param {string | ArrayBuffer} input Url, Path or ArrayBuffer
   * @param {string} [what="binary", "base64", "epub", "opf", "json", "directory"] force opening as a certain type
   * @returns {Promise} of when the book has been loaded
   * @example book.open("/path/to/book.epub")
   */
  open(e, i) {
    var s, t = i || this.determineType(e);
    return t === n.BINARY ? (this.archived = !0, this.url = new a("/", ""), s = this.openEpub(e)) : t === n.BASE64 ? (this.archived = !0, this.url = new a("/", ""), s = this.openEpub(e, t)) : t === n.EPUB ? (this.archived = !0, this.url = new a("/", ""), s = this.request(e, "binary", this.settings.requestCredentials, this.settings.requestHeaders).then(this.openEpub.bind(this))) : t == n.OPF ? (this.url = new a(e), s = this.openPackaging(this.url.Path.toString())) : t == n.MANIFEST ? (this.url = new a(e), s = this.openManifest(this.url.Path.toString())) : (this.url = new a(e), s = this.openContainer(m).then(this.openPackaging.bind(this))), s;
  }
  /**
   * Open an archived epub
   * @private
   * @param  {binary} data
   * @param  {string} [encoding]
   * @return {Promise}
   */
  openEpub(e, i) {
    return this.unarchive(e, i || this.settings.encoding).then(() => this.openContainer(m)).then((s) => this.openPackaging(s));
  }
  /**
   * Open the epub container
   * @private
   * @param  {string} url
   * @return {string} packagePath
   */
  openContainer(e) {
    return this.load(e).then((i) => (this.container = new O(i), this.resolve(this.container.packagePath)));
  }
  /**
   * Open the Open Packaging Format Xml
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openPackaging(e) {
    return this.path = new g(e), this.load(e).then((i) => (this.packaging = new f(i), this.unpack(this.packaging)));
  }
  /**
   * Open the manifest JSON
   * @private
   * @param  {string} url
   * @return {Promise}
   */
  openManifest(e) {
    return this.path = new g(e), this.load(e).then((i) => (this.packaging = new f(), this.packaging.load(i), this.unpack(this.packaging)));
  }
  /**
   * Load a resource from the Book
   * @param  {string} path path to the resource to load
   * @return {Promise}     returns a promise with the requested resource
   */
  load(e) {
    var i = this.resolve(e);
    return this.archived ? this.archive.request(i) : this.request(i, null, this.settings.requestCredentials, this.settings.requestHeaders);
  }
  /**
   * Resolve a path to it's absolute position in the Book
   * @param  {string} path
   * @param  {boolean} [absolute] force resolving the full URL
   * @return {string}          the resolved path string
   */
  resolve(e, i) {
    if (e) {
      var s = e, t = e.indexOf("://") > -1;
      return t ? e : (this.path && (s = this.path.resolve(e)), i != !1 && this.url && (s = this.url.resolve(s)), s);
    }
  }
  /**
   * Get a canonical link to a path
   * @param  {string} path
   * @return {string} the canonical path string
   */
  canonical(e) {
    var i = e;
    return e ? (this.settings.canonical ? i = this.settings.canonical(e) : i = this.resolve(e, !0), i) : "";
  }
  /**
   * Determine the type of they input passed to open
   * @private
   * @param  {string} input
   * @return {string}  binary | directory | epub | opf
   */
  determineType(e) {
    var i, s, t;
    if (this.settings.encoding === "base64")
      return n.BASE64;
    if (typeof e != "string")
      return n.BINARY;
    if (i = new a(e), s = i.path(), t = s.extension, t && (t = t.replace(/\?.*$/, "")), !t)
      return n.DIRECTORY;
    if (t === "epub")
      return n.EPUB;
    if (t === "opf")
      return n.OPF;
    if (t === "json")
      return n.MANIFEST;
  }
  /**
   * unpack the contents of the Books packaging
   * @private
   * @param {Packaging} packaging object
   */
  unpack(e) {
    this.package = e, this.packaging.metadata.layout === "" ? this.load(this.url.resolve(N)).then((i) => {
      this.displayOptions = new p(i), this.loading.displayOptions.resolve(this.displayOptions);
    }).catch((i) => {
      this.displayOptions = new p(), this.loading.displayOptions.resolve(this.displayOptions);
    }) : (this.displayOptions = new p(), this.loading.displayOptions.resolve(this.displayOptions)), this.spine.unpack(this.packaging, this.resolve.bind(this), this.canonical.bind(this)), this.resources = new P(this.packaging.manifest, {
      archive: this.archive,
      resolver: this.resolve.bind(this),
      request: this.request.bind(this),
      replacements: this.settings.replacements || (this.archived ? "blobUrl" : "base64")
    }), this.loadNavigation(this.packaging).then(() => {
      this.loading.navigation.resolve(this.navigation);
    }), this.packaging.coverPath && (this.cover = this.resolve(this.packaging.coverPath)), this.loading.manifest.resolve(this.packaging.manifest), this.loading.metadata.resolve(this.packaging.metadata), this.loading.spine.resolve(this.spine), this.loading.cover.resolve(this.cover), this.loading.resources.resolve(this.resources), this.loading.pageList.resolve(this.pageList), this.isOpen = !0, this.archived || this.settings.replacements && this.settings.replacements != "none" ? this.replacements().then(() => {
      this.loaded.displayOptions.then(() => {
        this.opening.resolve(this);
      });
    }).catch((i) => {
      console.error(i);
    }) : this.loaded.displayOptions.then(() => {
      this.opening.resolve(this);
    });
  }
  /**
   * Load Navigation and PageList from package
   * @private
   * @param {Packaging} packaging
   */
  loadNavigation(e) {
    let i = e.navPath || e.ncxPath, s = e.toc;
    return s ? new Promise((t, o) => {
      this.navigation = new d(s), e.pageList && (this.pageList = new l(e.pageList)), t(this.navigation);
    }) : i ? this.load(i, "xml").then((t) => (this.navigation = new d(t), this.pageList = new l(t), this.navigation)) : new Promise((t, o) => {
      this.navigation = new d(), this.pageList = new l(), t(this.navigation);
    });
  }
  /**
   * Gets a Section of the Book from the Spine
   * Alias for `book.spine.get`
   * @param {string} target
   * @return {Section}
   */
  section(e) {
    return this.spine.get(e);
  }
  /**
   * Sugar to render a book to an element
   * @param  {element | string} element element or string to add a rendition to
   * @param  {object} [options]
   * @return {Rendition}
   */
  renderTo(e, i) {
    return this.rendition = new k(this, i), this.rendition.attachTo(e), this.rendition;
  }
  /**
   * Set if request should use withCredentials
   * @param {boolean} credentials
   */
  setRequestCredentials(e) {
    this.settings.requestCredentials = e;
  }
  /**
   * Set headers request should use
   * @param {object} headers
   */
  setRequestHeaders(e) {
    this.settings.requestHeaders = e;
  }
  /**
   * Unarchive a zipped epub
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Archive}
   */
  unarchive(e, i) {
    return this.archive = new E(), this.archive.open(e, i);
  }
  /**
   * Store the epubs contents
   * @private
   * @param  {binary} input epub data
   * @param  {string} [encoding]
   * @return {Store}
   */
  store(e) {
    let i = this.settings.replacements && this.settings.replacements !== "none", s = this.url, t = this.settings.requestMethod || v.bind(this);
    return this.storage = new A(e, t, this.resolve.bind(this)), this.request = this.storage.request.bind(this.storage), this.opened.then(() => {
      this.archived && (this.storage.requester = this.archive.request.bind(this.archive));
      let o = (h, u) => {
        u.output = this.resources.substitute(h, u.url);
      };
      this.resources.settings.replacements = i || "blobUrl", this.resources.replacements().then(() => this.resources.replaceCss()), this.storage.on("offline", () => {
        this.url = new a("/", ""), this.spine.hooks.serialize.register(o);
      }), this.storage.on("online", () => {
        this.url = s, this.spine.hooks.serialize.deregister(o);
      });
    }), this.storage;
  }
  /**
   * Get the cover url
   * @return {Promise<?string>} coverUrl
   */
  coverUrl() {
    return this.loaded.cover.then(() => this.cover ? this.archived ? this.archive.createUrl(this.cover) : this.cover : null);
  }
  /**
   * Load replacement urls
   * @private
   * @return {Promise} completed loading urls
   */
  replacements() {
    return this.spine.hooks.serialize.register((e, i) => {
      i.output = this.resources.substitute(e, i.url);
    }), this.resources.replacements().then(() => this.resources.replaceCss());
  }
  /**
   * Find a DOM Range for a given CFI Range
   * @param  {EpubCFI} cfiRange a epub cfi range
   * @return {Promise}
   */
  getRange(e) {
    var i = new q(e), s = this.spine.get(i.spinePos), t = this.load.bind(this);
    return s ? s.load(t).then(function(o) {
      var h = i.toRange(s.document);
      return h;
    }) : new Promise((o, h) => {
      h("CFI could not be found");
    });
  }
  /**
   * Generates the Book Key using the identifier in the manifest or other string provided
   * @param  {string} [identifier] to use instead of metadata identifier
   * @return {string} key
   */
  key(e) {
    var i = e || this.packaging.metadata.identifier || this.url.filename;
    return `epubjs:${L}:${i}`;
  }
  /**
   * Destroy the Book and all associated objects
   */
  destroy() {
    this.opened = void 0, this.loading = void 0, this.loaded = void 0, this.ready = void 0, this.isOpen = !1, this.isRendered = !1, this.spine && this.spine.destroy(), this.locations && this.locations.destroy(), this.pageList && this.pageList.destroy(), this.archive && this.archive.destroy(), this.resources && this.resources.destroy(), this.container && this.container.destroy(), this.packaging && this.packaging.destroy(), this.rendition && this.rendition.destroy(), this.displayOptions && this.displayOptions.destroy(), this.spine = void 0, this.locations = void 0, this.pageList = void 0, this.archive = void 0, this.resources = void 0, this.container = void 0, this.packaging = void 0, this.rendition = void 0, this.navigation = void 0, this.url = void 0, this.path = void 0, this.archived = !1;
  }
}
y(R.prototype);
export {
  R as default
};
//# sourceMappingURL=book.mjs.map
