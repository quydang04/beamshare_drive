import d from "./epubcfi.mjs";
import p from "./utils/hook.mjs";
import o from "./section.mjs";
import { replaceBase as u, replaceCanonical as a, replaceMeta as I } from "./utils/replacements.mjs";
class b {
  constructor() {
    this.spineItems = [], this.spineByHref = {}, this.spineById = {}, this.hooks = {}, this.hooks.serialize = new p(), this.hooks.content = new p(), this.hooks.content.register(u), this.hooks.content.register(a), this.hooks.content.register(I), this.epubcfi = new d(), this.loaded = !1, this.items = void 0, this.manifest = void 0, this.spineNodeIndex = void 0, this.baseUrl = void 0, this.length = void 0;
  }
  /**
   * Unpack items from a opf into spine items
   * @param  {Packaging} _package
   * @param  {method} resolver URL resolver
   * @param  {method} canonical Resolve canonical url
   */
  unpack(e, i, n) {
    this.items = e.spine, this.manifest = e.manifest, this.spineNodeIndex = e.spineNodeIndex, this.baseUrl = e.baseUrl || e.basePath || "", this.length = this.items.length, this.items.forEach((s, l) => {
      var r = this.manifest[s.idref], f;
      s.index = l, s.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, s.index, s.id), s.href && (s.url = i(s.href, !0), s.canonical = n(s.href)), r && (s.href = r.href, s.url = i(s.href, !0), s.canonical = n(s.href), r.properties.length && s.properties.push.apply(s.properties, r.properties)), s.linear === "yes" ? (s.prev = (function() {
        let t = s.index;
        for (; t > 0; ) {
          let h = this.get(t - 1);
          if (h && h.linear)
            return h;
          t -= 1;
        }
      }).bind(this), s.next = (function() {
        let t = s.index;
        for (; t < this.spineItems.length - 1; ) {
          let h = this.get(t + 1);
          if (h && h.linear)
            return h;
          t += 1;
        }
      }).bind(this)) : (s.prev = function() {
      }, s.next = function() {
      }), f = new o(s, this.hooks), this.append(f);
    }), this.loaded = !0;
  }
  /**
   * Get an item from the spine
   * @param  {string|number} [target]
   * @return {Section} section
   * @example spine.get();
   * @example spine.get(1);
   * @example spine.get("chap1.html");
   * @example spine.get("#id1234");
   */
  get(e) {
    var i = 0;
    if (typeof e > "u")
      for (; i < this.spineItems.length; ) {
        let n = this.spineItems[i];
        if (n && n.linear)
          break;
        i += 1;
      }
    else this.epubcfi.isCfiString(e) ? i = new d(e).spinePos : typeof e == "number" || isNaN(e) === !1 ? i = e : typeof e == "string" && e.indexOf("#") === 0 ? i = this.spineById[e.substring(1)] : typeof e == "string" && (e = e.split("#")[0], i = this.spineByHref[e] || this.spineByHref[encodeURI(e)]);
    return this.spineItems[i] || null;
  }
  /**
   * Append a Section to the Spine
   * @private
   * @param  {Section} section
   */
  append(e) {
    var i = this.spineItems.length;
    return e.index = i, this.spineItems.push(e), this.spineByHref[decodeURI(e.href)] = i, this.spineByHref[encodeURI(e.href)] = i, this.spineByHref[e.href] = i, this.spineById[e.idref] = i, i;
  }
  /**
   * Prepend a Section to the Spine
   * @private
   * @param  {Section} section
   */
  prepend(e) {
    return this.spineByHref[e.href] = 0, this.spineById[e.idref] = 0, this.spineItems.forEach(function(i, n) {
      i.index = n;
    }), 0;
  }
  // insert(section, index) {
  //
  // };
  /**
   * Remove a Section from the Spine
   * @private
   * @param  {Section} section
   */
  remove(e) {
    var i = this.spineItems.indexOf(e);
    if (i > -1)
      return delete this.spineByHref[e.href], delete this.spineById[e.idref], this.spineItems.splice(i, 1);
  }
  /**
   * Loop over the Sections in the Spine
   * @return {method} forEach
   */
  each() {
    return this.spineItems.forEach.apply(this.spineItems, arguments);
  }
  /**
   * Find the first Section in the Spine
   * @return {Section} first section
   */
  first() {
    let e = 0;
    do {
      let i = this.get(e);
      if (i && i.linear)
        return i;
      e += 1;
    } while (e < this.spineItems.length);
  }
  /**
   * Find the last Section in the Spine
   * @return {Section} last section
   */
  last() {
    let e = this.spineItems.length - 1;
    do {
      let i = this.get(e);
      if (i && i.linear)
        return i;
      e -= 1;
    } while (e >= 0);
  }
  destroy() {
    this.each((e) => e.destroy()), this.spineItems = void 0, this.spineByHref = void 0, this.spineById = void 0, this.hooks.serialize.clear(), this.hooks.content.clear(), this.hooks = void 0, this.epubcfi = void 0, this.loaded = !1, this.items = void 0, this.manifest = void 0, this.spineNodeIndex = void 0, this.baseUrl = void 0, this.length = void 0;
  }
}
export {
  b as default
};
//# sourceMappingURL=spine.mjs.map
