{"version":3,"file":"archive.mjs","sources":["../../../../../../../../node_modules/.pnpm/epubjs@0.3.93/node_modules/epubjs/src/archive.js"],"sourcesContent":["import {defer, isXml, parse} from \"./utils/core\";\nimport request from \"./utils/request\";\nimport mime from \"./utils/mime\";\nimport Path from \"./utils/path\";\nimport JSZip from \"jszip/dist/jszip\";\n\n/**\n * Handles Unzipping a requesting files from an Epub Archive\n * @class\n */\nclass Archive {\n\n\tconstructor() {\n\t\tthis.zip = undefined;\n\t\tthis.urlCache = {};\n\n\t\tthis.checkRequirements();\n\n\t}\n\n\t/**\n\t * Checks to see if JSZip exists in global namspace,\n\t * Requires JSZip if it isn't there\n\t * @private\n\t */\n\tcheckRequirements(){\n\t\ttry {\n\t\t\tthis.zip = new JSZip();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"JSZip lib not loaded\");\n\t\t}\n\t}\n\n\t/**\n\t * Open an archive\n\t * @param  {binary} input\n\t * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n\t * @return {Promise} zipfile\n\t */\n\topen(input, isBase64){\n\t\treturn this.zip.loadAsync(input, {\"base64\": isBase64});\n\t}\n\n\t/**\n\t * Load and Open an archive\n\t * @param  {string} zipUrl\n\t * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded\n\t * @return {Promise} zipfile\n\t */\n\topenUrl(zipUrl, isBase64){\n\t\treturn request(zipUrl, \"binary\")\n\t\t\t.then(function(data){\n\t\t\t\treturn this.zip.loadAsync(data, {\"base64\": isBase64});\n\t\t\t}.bind(this));\n\t}\n\n\t/**\n\t * Request a url from the archive\n\t * @param  {string} url  a url to request from the archive\n\t * @param  {string} [type] specify the type of the returned result\n\t * @return {Promise<Blob | string | JSON | Document | XMLDocument>}\n\t */\n\trequest(url, type){\n\t\tvar deferred = new defer();\n\t\tvar response;\n\t\tvar path = new Path(url);\n\n\t\t// If type isn't set, determine it from the file extension\n\t\tif(!type) {\n\t\t\ttype = path.extension;\n\t\t}\n\n\t\tif(type == \"blob\"){\n\t\t\tresponse = this.getBlob(url);\n\t\t} else {\n\t\t\tresponse = this.getText(url);\n\t\t}\n\n\t\tif (response) {\n\t\t\tresponse.then(function (r) {\n\t\t\t\tlet result = this.handleResponse(r, type);\n\t\t\t\tdeferred.resolve(result);\n\t\t\t}.bind(this));\n\t\t} else {\n\t\t\tdeferred.reject({\n\t\t\t\tmessage : \"File not found in the epub: \" + url,\n\t\t\t\tstack : new Error().stack\n\t\t\t});\n\t\t}\n\t\treturn deferred.promise;\n\t}\n\n\t/**\n\t * Handle the response from request\n\t * @private\n\t * @param  {any} response\n\t * @param  {string} [type]\n\t * @return {any} the parsed result\n\t */\n\thandleResponse(response, type){\n\t\tvar r;\n\n\t\tif(type == \"json\") {\n\t\t\tr = JSON.parse(response);\n\t\t}\n\t\telse\n\t\tif(isXml(type)) {\n\t\t\tr = parse(response, \"text/xml\");\n\t\t}\n\t\telse\n\t\tif(type == \"xhtml\") {\n\t\t\tr = parse(response, \"application/xhtml+xml\");\n\t\t}\n\t\telse\n\t\tif(type == \"html\" || type == \"htm\") {\n\t\t\tr = parse(response, \"text/html\");\n\t\t } else {\n\t\t\t r = response;\n\t\t }\n\n\t\treturn r;\n\t}\n\n\t/**\n\t * Get a Blob from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [mimeType]\n\t * @return {Blob}\n\t */\n\tgetBlob(url, mimeType){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\tmimeType = mimeType || mime.lookup(entry.name);\n\t\t\treturn entry.async(\"uint8array\").then(function(uint8array) {\n\t\t\t\treturn new Blob([uint8array], {type : mimeType});\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get Text from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [encoding]\n\t * @return {string}\n\t */\n\tgetText(url, encoding){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\treturn entry.async(\"string\").then(function(text) {\n\t\t\t\treturn text;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get a base64 encoded result from Archive by Url\n\t * @param  {string} url\n\t * @param  {string} [mimeType]\n\t * @return {string} base64 encoded\n\t */\n\tgetBase64(url, mimeType){\n\t\tvar decodededUrl = window.decodeURIComponent(url.substr(1)); // Remove first slash\n\t\tvar entry = this.zip.file(decodededUrl);\n\n\t\tif(entry) {\n\t\t\tmimeType = mimeType || mime.lookup(entry.name);\n\t\t\treturn entry.async(\"base64\").then(function(data) {\n\t\t\t\treturn \"data:\" + mimeType + \";base64,\" + data;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create a Url from an unarchived item\n\t * @param  {string} url\n\t * @param  {object} [options.base64] use base64 encoding or blob url\n\t * @return {Promise} url promise with Url string\n\t */\n\tcreateUrl(url, options){\n\t\tvar deferred = new defer();\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tvar tempUrl;\n\t\tvar response;\n\t\tvar useBase64 = options && options.base64;\n\n\t\tif(url in this.urlCache) {\n\t\t\tdeferred.resolve(this.urlCache[url]);\n\t\t\treturn deferred.promise;\n\t\t}\n\n\t\tif (useBase64) {\n\t\t\tresponse = this.getBase64(url);\n\n\t\t\tif (response) {\n\t\t\t\tresponse.then(function(tempUrl) {\n\n\t\t\t\t\tthis.urlCache[url] = tempUrl;\n\t\t\t\t\tdeferred.resolve(tempUrl);\n\n\t\t\t\t}.bind(this));\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tresponse = this.getBlob(url);\n\n\t\t\tif (response) {\n\t\t\t\tresponse.then(function(blob) {\n\n\t\t\t\t\ttempUrl = _URL.createObjectURL(blob);\n\t\t\t\t\tthis.urlCache[url] = tempUrl;\n\t\t\t\t\tdeferred.resolve(tempUrl);\n\n\t\t\t\t}.bind(this));\n\n\t\t\t}\n\t\t}\n\n\n\t\tif (!response) {\n\t\t\tdeferred.reject({\n\t\t\t\tmessage : \"File not found in the epub: \" + url,\n\t\t\t\tstack : new Error().stack\n\t\t\t});\n\t\t}\n\n\t\treturn deferred.promise;\n\t}\n\n\t/**\n\t * Revoke Temp Url for a archive item\n\t * @param  {string} url url of the item in the archive\n\t */\n\trevokeUrl(url){\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tvar fromCache = this.urlCache[url];\n\t\tif(fromCache) _URL.revokeObjectURL(fromCache);\n\t}\n\n\tdestroy() {\n\t\tvar _URL = window.URL || window.webkitURL || window.mozURL;\n\t\tfor (let fromCache in this.urlCache) {\n\t\t\t_URL.revokeObjectURL(fromCache);\n\t\t}\n\t\tthis.zip = undefined;\n\t\tthis.urlCache = {};\n\t}\n}\n\nexport default Archive;\n"],"names":["Archive","JSZip","input","isBase64","zipUrl","request","data","url","type","deferred","defer","response","path","Path","r","result","isXml","parse","mimeType","decodededUrl","entry","mime","uint8array","encoding","text","options","_URL","tempUrl","useBase64","blob","fromCache"],"mappings":"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","x_google_ignoreList":[0]}