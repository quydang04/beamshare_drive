import m from "../../../../event-emitter@0.3.5/node_modules/event-emitter/index.mjs";
import x from "./epubcfi.mjs";
import { EVENTS as c } from "./utils/constants.mjs";
class k {
  constructor(t) {
    this.rendition = t, this.highlights = [], this.underlines = [], this.marks = [], this._annotations = {}, this._annotationsBySectionIndex = {}, this.rendition.hooks.render.register(this.inject.bind(this)), this.rendition.hooks.unloaded.register(this.clear.bind(this));
  }
  /**
   * Add an annotation to store
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} [cb] Callback after annotation is added
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   * @returns {Annotation} annotation
   */
  add(t, n, i, e, o, a) {
    let h = encodeURI(n + t), s = new x(n).spinePos, r = new u({
      type: t,
      cfiRange: n,
      data: i,
      sectionIndex: s,
      cb: e,
      className: o,
      styles: a
    });
    return this._annotations[h] = r, s in this._annotationsBySectionIndex ? this._annotationsBySectionIndex[s].push(h) : this._annotationsBySectionIndex[s] = [h], this.rendition.views().forEach((l) => {
      r.sectionIndex === l.index && r.attach(l);
    }), r;
  }
  /**
   * Remove an annotation from store
   * @param {EpubCFI} cfiRange EpubCFI range the annotation is attached to
   * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
   */
  remove(t, n) {
    let i = encodeURI(t + n);
    if (i in this._annotations) {
      let e = this._annotations[i];
      if (n && e.type !== n)
        return;
      this.rendition.views().forEach((a) => {
        this._removeFromAnnotationBySectionIndex(e.sectionIndex, i), e.sectionIndex === a.index && e.detach(a);
      }), delete this._annotations[i];
    }
  }
  /**
   * Remove an annotations by Section Index
   * @private
   */
  _removeFromAnnotationBySectionIndex(t, n) {
    this._annotationsBySectionIndex[t] = this._annotationsAt(t).filter((i) => i !== n);
  }
  /**
   * Get annotations by Section Index
   * @private
   */
  _annotationsAt(t) {
    return this._annotationsBySectionIndex[t];
  }
  /**
   * Add a highlight to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  highlight(t, n, i, e, o) {
    return this.add("highlight", t, n, i, e, o);
  }
  /**
   * Add a underline to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   * @param {string} className CSS class to assign to annotation
   * @param {object} styles CSS styles to assign to annotation
   */
  underline(t, n, i, e, o) {
    return this.add("underline", t, n, i, e, o);
  }
  /**
   * Add a mark to the store
   * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
   * @param {object} data Data to assign to annotation
   * @param {function} cb Callback after annotation is clicked
   */
  mark(t, n, i) {
    return this.add("mark", t, n, i);
  }
  /**
   * iterate over annotations in the store
   */
  each() {
    return this._annotations.forEach.apply(this._annotations, arguments);
  }
  /**
   * Hook for injecting annotation into a view
   * @param {View} view
   * @private
   */
  inject(t) {
    let n = t.index;
    n in this._annotationsBySectionIndex && this._annotationsBySectionIndex[n].forEach((e) => {
      this._annotations[e].attach(t);
    });
  }
  /**
   * Hook for removing annotation from a view
   * @param {View} view
   * @private
   */
  clear(t) {
    let n = t.index;
    n in this._annotationsBySectionIndex && this._annotationsBySectionIndex[n].forEach((e) => {
      this._annotations[e].detach(t);
    });
  }
  /**
   * [Not Implemented] Show annotations
   * @TODO: needs implementation in View
   */
  show() {
  }
  /**
   * [Not Implemented] Hide annotations
   * @TODO: needs implementation in View
   */
  hide() {
  }
}
class u {
  constructor({
    type: t,
    cfiRange: n,
    data: i,
    sectionIndex: e,
    cb: o,
    className: a,
    styles: h
  }) {
    this.type = t, this.cfiRange = n, this.data = i, this.sectionIndex = e, this.mark = void 0, this.cb = o, this.className = a, this.styles = h;
  }
  /**
   * Update stored data
   * @param {object} data
   */
  update(t) {
    this.data = t;
  }
  /**
   * Add to a view
   * @param {View} view
   */
  attach(t) {
    let { cfiRange: n, data: i, type: e, mark: o, cb: a, className: h, styles: d } = this, s;
    return e === "highlight" ? s = t.highlight(n, i, a, h, d) : e === "underline" ? s = t.underline(n, i, a, h, d) : e === "mark" && (s = t.mark(n, i, a)), this.mark = s, this.emit(c.ANNOTATION.ATTACH, s), s;
  }
  /**
   * Remove from a view
   * @param {View} view
   */
  detach(t) {
    let { cfiRange: n, type: i } = this, e;
    return t && (i === "highlight" ? e = t.unhighlight(n) : i === "underline" ? e = t.ununderline(n) : i === "mark" && (e = t.unmark(n))), this.mark = void 0, this.emit(c.ANNOTATION.DETACH, e), e;
  }
  /**
   * [Not Implemented] Get text of an annotation
   * @TODO: needs implementation in contents
   */
  text() {
  }
}
m(u.prototype);
export {
  k as default
};
//# sourceMappingURL=annotations.mjs.map
