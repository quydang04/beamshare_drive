import { qs as o, indexOfElementNode as v, qsa as u, qsp as s } from "./utils/core.mjs";
class P {
  constructor(e) {
    this.manifest = {}, this.navPath = "", this.ncxPath = "", this.coverPath = "", this.spineNodeIndex = 0, this.spine = [], this.metadata = {}, e && this.parse(e);
  }
  /**
   * Parse OPF XML
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  parse(e) {
    var i, t, r;
    if (!e)
      throw new Error("Package File Not Found");
    if (i = o(e, "metadata"), !i)
      throw new Error("No Metadata Found");
    if (t = o(e, "manifest"), !t)
      throw new Error("No Manifest Found");
    if (r = o(e, "spine"), !r)
      throw new Error("No Spine Found");
    return this.manifest = this.parseManifest(t), this.navPath = this.findNavPath(t), this.ncxPath = this.findNcxPath(t, r), this.coverPath = this.findCoverPath(e), this.spineNodeIndex = v(r), this.spine = this.parseSpine(r, this.manifest), this.uniqueIdentifier = this.findUniqueIdentifier(e), this.metadata = this.parseMetadata(i), this.metadata.direction = r.getAttribute("page-progression-direction"), {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex
    };
  }
  /**
   * Parse Metadata
   * @private
   * @param  {node} xml
   * @return {object} metadata
   */
  parseMetadata(e) {
    var i = {};
    return i.title = this.getElementText(e, "title"), i.creator = this.getElementText(e, "creator"), i.description = this.getElementText(e, "description"), i.pubdate = this.getElementText(e, "date"), i.publisher = this.getElementText(e, "publisher"), i.identifier = this.getElementText(e, "identifier"), i.language = this.getElementText(e, "language"), i.rights = this.getElementText(e, "rights"), i.modified_date = this.getPropertyText(e, "dcterms:modified"), i.layout = this.getPropertyText(e, "rendition:layout"), i.orientation = this.getPropertyText(e, "rendition:orientation"), i.flow = this.getPropertyText(e, "rendition:flow"), i.viewport = this.getPropertyText(e, "rendition:viewport"), i.media_active_class = this.getPropertyText(e, "media:active-class"), i.spread = this.getPropertyText(e, "rendition:spread"), i;
  }
  /**
   * Parse Manifest
   * @private
   * @param  {node} manifestXml
   * @return {object} manifest
   */
  parseManifest(e) {
    var i = {}, t = u(e, "item"), r = Array.prototype.slice.call(t);
    return r.forEach(function(n) {
      var a = n.getAttribute("id"), p = n.getAttribute("href") || "", f = n.getAttribute("media-type") || "", d = n.getAttribute("media-overlay") || "", h = n.getAttribute("properties") || "";
      i[a] = {
        href: p,
        // "url" : href,
        type: f,
        overlay: d,
        properties: h.length ? h.split(" ") : []
      };
    }), i;
  }
  /**
   * Parse Spine
   * @private
   * @param  {node} spineXml
   * @param  {Packaging.manifest} manifest
   * @return {object} spine
   */
  parseSpine(e, i) {
    var t = [], r = u(e, "itemref"), n = Array.prototype.slice.call(r);
    return n.forEach(function(a, p) {
      var f = a.getAttribute("idref"), d = a.getAttribute("properties") || "", h = d.length ? d.split(" ") : [], l = {
        id: a.getAttribute("id"),
        idref: f,
        linear: a.getAttribute("linear") || "yes",
        properties: h,
        // "href" : manifest[Id].href,
        // "url" :  manifest[Id].url,
        index: p
        // "cfiBase" : cfiBase
      };
      t.push(l);
    }), t;
  }
  /**
   * Find Unique Identifier
   * @private
   * @param  {node} packageXml
   * @return {string} Unique Identifier text
   */
  findUniqueIdentifier(e) {
    var i = e.documentElement.getAttribute("unique-identifier");
    if (!i)
      return "";
    var t = e.getElementById(i);
    return t && t.localName === "identifier" && t.namespaceURI === "http://purl.org/dc/elements/1.1/" && t.childNodes.length > 0 ? t.childNodes[0].nodeValue.trim() : "";
  }
  /**
   * Find TOC NAV
   * @private
   * @param {element} manifestNode
   * @return {string}
   */
  findNavPath(e) {
    var i = s(e, "item", { properties: "nav" });
    return i ? i.getAttribute("href") : !1;
  }
  /**
   * Find TOC NCX
   * media-type="application/x-dtbncx+xml" href="toc.ncx"
   * @private
   * @param {element} manifestNode
   * @param {element} spineNode
   * @return {string}
   */
  findNcxPath(e, i) {
    var t = s(e, "item", { "media-type": "application/x-dtbncx+xml" }), r;
    return t || (r = i.getAttribute("toc"), r && (t = e.querySelector(`#${r}`))), t ? t.getAttribute("href") : !1;
  }
  /**
   * Find the Cover Path
   * <item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />
   * Fallback for Epub 2.0
   * @private
   * @param  {node} packageXml
   * @return {string} href
   */
  findCoverPath(e) {
    var i = o(e, "package");
    i.getAttribute("version");
    var t = s(e, "item", { properties: "cover-image" });
    if (t) return t.getAttribute("href");
    var r = s(e, "meta", { name: "cover" });
    if (r) {
      var n = r.getAttribute("content"), a = e.getElementById(n);
      return a ? a.getAttribute("href") : "";
    } else
      return !1;
  }
  /**
   * Get text of a namespaced element
   * @private
   * @param  {node} xml
   * @param  {string} tag
   * @return {string} text
   */
  getElementText(e, i) {
    var t = e.getElementsByTagNameNS("http://purl.org/dc/elements/1.1/", i), r;
    return !t || t.length === 0 ? "" : (r = t[0], r.childNodes.length ? r.childNodes[0].nodeValue : "");
  }
  /**
   * Get text by property
   * @private
   * @param  {node} xml
   * @param  {string} property
   * @return {string} text
   */
  getPropertyText(e, i) {
    var t = s(e, "meta", { property: i });
    return t && t.childNodes.length ? t.childNodes[0].nodeValue : "";
  }
  /**
   * Load JSON Manifest
   * @param  {document} packageDocument OPF XML
   * @return {object} parsed package parts
   */
  load(e) {
    this.metadata = e.metadata;
    let i = e.readingOrder || e.spine;
    return this.spine = i.map((t, r) => (t.index = r, t.linear = t.linear || "yes", t)), e.resources.forEach((t, r) => {
      this.manifest[r] = t, t.rel && t.rel[0] === "cover" && (this.coverPath = t.href);
    }), this.spineNodeIndex = 0, this.toc = e.toc.map((t, r) => (t.label = t.title, t)), {
      metadata: this.metadata,
      spine: this.spine,
      manifest: this.manifest,
      navPath: this.navPath,
      ncxPath: this.ncxPath,
      coverPath: this.coverPath,
      spineNodeIndex: this.spineNodeIndex,
      toc: this.toc
    };
  }
  destroy() {
    this.manifest = void 0, this.navPath = void 0, this.ncxPath = void 0, this.coverPath = void 0, this.spineNodeIndex = void 0, this.spine = void 0, this.metadata = void 0;
  }
}
export {
  P as default
};
//# sourceMappingURL=packaging.mjs.map
