import { qs as u, querySelectorByType as o, filterChildren as l, qsa as d } from "./utils/core.mjs";
class v {
  constructor(t) {
    this.toc = [], this.tocByHref = {}, this.tocById = {}, this.landmarks = [], this.landmarksByType = {}, this.length = 0, t && this.parse(t);
  }
  /**
   * Parse out the navigation items
   * @param {document} xml navigation html / xhtml / ncx
   */
  parse(t) {
    let e = t.nodeType, r, n;
    e && (r = u(t, "html"), n = u(t, "ncx")), e ? r ? (this.toc = this.parseNav(t), this.landmarks = this.parseLandmarks(t)) : n && (this.toc = this.parseNcx(t)) : this.toc = this.load(t), this.length = 0, this.unpack(this.toc);
  }
  /**
   * Unpack navigation items
   * @private
   * @param  {array} toc
   */
  unpack(t) {
    for (var e, r = 0; r < t.length; r++)
      e = t[r], e.href && (this.tocByHref[e.href] = r), e.id && (this.tocById[e.id] = r), this.length++, e.subitems.length && this.unpack(e.subitems);
  }
  /**
   * Get an item from the navigation
   * @param  {string} target
   * @return {object} navItem
   */
  get(t) {
    var e;
    return t ? (t.indexOf("#") === 0 ? e = this.tocById[t.substring(1)] : t in this.tocByHref && (e = this.tocByHref[t]), this.getByIndex(t, e, this.toc)) : this.toc;
  }
  /**
   * Get an item from navigation subitems recursively by index
   * @param  {string} target
   * @param  {number} index
   * @param  {array} navItems
   * @return {object} navItem
   */
  getByIndex(t, e, r) {
    if (r.length === 0)
      return;
    const n = r[e];
    if (n && (t === n.id || t === n.href))
      return n;
    {
      let i;
      for (let a = 0; a < r.length && (i = this.getByIndex(t, e, r[a].subitems), !i); ++a)
        ;
      return i;
    }
  }
  /**
   * Get a landmark by type
   * List of types: https://idpf.github.io/epub-vocabs/structure/
   * @param  {string} type
   * @return {object} landmarkItem
   */
  landmark(t) {
    var e;
    return t ? (e = this.landmarksByType[t], this.landmarks[e]) : this.landmarks;
  }
  /**
   * Parse toc from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNav(t) {
    var e = o(t, "nav", "toc"), r = [];
    if (!e) return r;
    let n = l(e, "ol", !0);
    return n && (r = this.parseNavList(n)), r;
  }
  /**
   * Parses lists in the toc
   * @param  {document} navListHtml
   * @param  {string} parent id
   * @return {array} navigation list
   */
  parseNavList(t, e) {
    const r = [];
    if (!t || !t.children) return r;
    for (let n = 0; n < t.children.length; n++) {
      const i = this.navItem(t.children[n], e);
      i && r.push(i);
    }
    return r;
  }
  /**
   * Create a navItem
   * @private
   * @param  {element} item
   * @return {object} navItem
   */
  navItem(t, e) {
    let r = t.getAttribute("id") || void 0, n = l(t, "a", !0) || l(t, "span", !0);
    if (!n)
      return;
    let i = n.getAttribute("href") || "";
    r || (r = i);
    let a = n.textContent || "", s = [], h = l(t, "ol", !0);
    return h && (s = this.parseNavList(h, r)), {
      id: r,
      href: i,
      label: a,
      subitems: s,
      parent: e
    };
  }
  /**
   * Parse landmarks from a Epub > 3.0 Nav
   * @private
   * @param  {document} navHtml
   * @return {array} landmarks list
   */
  parseLandmarks(t) {
    var e = o(t, "nav", "landmarks"), r = e ? d(e, "li") : [], n = r.length, i, a = [], s;
    if (!r || n === 0) return a;
    for (i = 0; i < n; ++i)
      s = this.landmarkItem(r[i]), s && (a.push(s), this.landmarksByType[s.type] = i);
    return a;
  }
  /**
   * Create a landmarkItem
   * @private
   * @param  {element} item
   * @return {object} landmarkItem
   */
  landmarkItem(t) {
    let e = l(t, "a", !0);
    if (!e)
      return;
    let r = e.getAttributeNS("http://www.idpf.org/2007/ops", "type") || void 0, n = e.getAttribute("href") || "", i = e.textContent || "";
    return {
      href: n,
      label: i,
      type: r
    };
  }
  /**
   * Parse from a Epub > 3.0 NC
   * @private
   * @param  {document} navHtml
   * @return {array} navigation list
   */
  parseNcx(t) {
    var e = d(t, "navPoint"), r = e.length, n, i = {}, a = [], s, h;
    if (!e || r === 0) return a;
    for (n = 0; n < r; ++n)
      s = this.ncxItem(e[n]), i[s.id] = s, s.parent ? (h = i[s.parent], h.subitems.push(s)) : a.push(s);
    return a;
  }
  /**
   * Create a ncxItem
   * @private
   * @param  {element} item
   * @return {object} ncxItem
   */
  ncxItem(t) {
    var e = t.getAttribute("id") || !1, r = u(t, "content"), n = r.getAttribute("src"), i = u(t, "navLabel"), a = i.textContent ? i.textContent : "", s = [], h = t.parentNode, f;
    return h && (h.nodeName === "navPoint" || h.nodeName.split(":").slice(-1)[0] === "navPoint") && (f = h.getAttribute("id")), {
      id: e,
      href: n,
      label: a,
      subitems: s,
      parent: f
    };
  }
  /**
   * Load Spine Items
   * @param  {object} json the items to be loaded
   * @return {Array} navItems
   */
  load(t) {
    return t.map((e) => (e.label = e.title, e.subitems = e.children ? this.load(e.children) : [], e));
  }
  /**
   * forEach pass through
   * @param  {Function} fn function to run on each item
   * @return {method} forEach loop
   */
  forEach(t) {
    return this.toc.forEach(t);
  }
}
export {
  v as default
};
//# sourceMappingURL=navigation.mjs.map
