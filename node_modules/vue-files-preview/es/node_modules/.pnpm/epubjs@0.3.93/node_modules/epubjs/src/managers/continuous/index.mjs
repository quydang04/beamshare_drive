import { extend as w, defer as v, requestAnimationFrame as D } from "../../utils/core.mjs";
import S from "../default/index.mjs";
import y from "../helpers/snap.mjs";
import { EVENTS as o } from "../../utils/constants.mjs";
import x from "../../../../../../lodash@4.17.21/node_modules/lodash/debounce.mjs";
class R extends S {
  constructor(t) {
    super(t), this.name = "continuous", this.settings = w(this.settings || {}, {
      infinite: !0,
      overflow: void 0,
      axis: void 0,
      writingMode: void 0,
      flow: "scrolled",
      offset: 500,
      offsetDelta: 250,
      width: void 0,
      height: void 0,
      snap: !1,
      afterScrolledTimeout: 10,
      allowScriptedContent: !1,
      allowPopups: !1
    }), w(this.settings, t.settings || {}), t.settings.gap != "undefined" && t.settings.gap === 0 && (this.settings.gap = t.settings.gap), this.viewSettings = {
      ignoreClass: this.settings.ignoreClass,
      axis: this.settings.axis,
      flow: this.settings.flow,
      layout: this.layout,
      width: 0,
      height: 0,
      forceEvenPages: !1,
      allowScriptedContent: this.settings.allowScriptedContent,
      allowPopups: this.settings.allowPopups
    }, this.scrollTop = 0, this.scrollLeft = 0;
  }
  display(t, e) {
    return S.prototype.display.call(this, t, e).then((function() {
      return this.fill();
    }).bind(this));
  }
  fill(t) {
    var e = t || new v();
    return this.q.enqueue(() => this.check()).then((s) => {
      s ? this.fill(e) : e.resolve();
    }), e.promise;
  }
  moveTo(t) {
    var e = 0, s = 0;
    this.isPaginated ? (e = Math.floor(t.left / this.layout.delta) * this.layout.delta, e + this.settings.offsetDelta) : (s = t.top, t.top + this.settings.offsetDelta), (e > 0 || s > 0) && this.scrollBy(e, s, !0);
  }
  afterResized(t) {
    this.emit(o.MANAGERS.RESIZE, t.section);
  }
  // Remove Previous Listeners if present
  removeShownListeners(t) {
    t.onDisplayed = function() {
    };
  }
  add(t) {
    var e = this.createView(t);
    return this.views.append(e), e.on(o.VIEWS.RESIZED, (s) => {
      e.expanded = !0;
    }), e.on(o.VIEWS.AXIS, (s) => {
      this.updateAxis(s);
    }), e.on(o.VIEWS.WRITING_MODE, (s) => {
      this.updateWritingMode(s);
    }), e.onDisplayed = this.afterDisplayed.bind(this), e.onResize = this.afterResized.bind(this), e.display(this.request);
  }
  append(t) {
    var e = this.createView(t);
    return e.on(o.VIEWS.RESIZED, (s) => {
      e.expanded = !0;
    }), e.on(o.VIEWS.AXIS, (s) => {
      this.updateAxis(s);
    }), e.on(o.VIEWS.WRITING_MODE, (s) => {
      this.updateWritingMode(s);
    }), this.views.append(e), e.onDisplayed = this.afterDisplayed.bind(this), e;
  }
  prepend(t) {
    var e = this.createView(t);
    return e.on(o.VIEWS.RESIZED, (s) => {
      this.counter(s), e.expanded = !0;
    }), e.on(o.VIEWS.AXIS, (s) => {
      this.updateAxis(s);
    }), e.on(o.VIEWS.WRITING_MODE, (s) => {
      this.updateWritingMode(s);
    }), this.views.prepend(e), e.onDisplayed = this.afterDisplayed.bind(this), e;
  }
  counter(t) {
    this.settings.axis === "vertical" ? this.scrollBy(0, t.heightDelta, !0) : this.scrollBy(t.widthDelta, 0, !0);
  }
  update(t) {
    for (var e = this.bounds(), s = this.views.all(), n = s.length, i = typeof t < "u" ? t : this.settings.offset || 0, h, r, l = new v(), a = [], d = 0; d < n; d++)
      if (r = s[d], h = this.isVisible(r, i, i, e), h === !0)
        if (r.displayed)
          r.show();
        else {
          let u = r.display(this.request).then(function(c) {
            c.show();
          }, (c) => {
            r.hide();
          });
          a.push(u);
        }
      else
        this.q.enqueue(r.destroy.bind(r)), clearTimeout(this.trimTimeout), this.trimTimeout = setTimeout((function() {
          this.q.enqueue(this.trim.bind(this));
        }).bind(this), 250);
    return a.length ? Promise.all(a).catch((u) => {
      l.reject(u);
    }) : (l.resolve(), l.promise);
  }
  check(t, e) {
    var s = new v(), n = [], i = this.settings.axis === "horizontal", h = this.settings.offset || 0;
    t && i && (h = t), e && !i && (h = e);
    var r = this._bounds;
    let l = i ? this.scrollLeft : this.scrollTop, a = i ? Math.floor(r.width) : r.height, d = i ? this.container.scrollWidth : this.container.scrollHeight, u = this.writingMode && this.writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal", c = this.settings.rtlScrollType, g = this.settings.direction === "rtl";
    this.settings.fullsize ? (i && g && c === "negative" || !i && g && c === "default") && (l = l * -1) : (g && c === "default" && u === "horizontal" && (l = d - a - l), g && c === "negative" && u === "horizontal" && (l = l * -1));
    let m = () => {
      let p = this.views.first(), f = p && p.section.prev();
      f && n.push(this.prepend(f));
    }, T = () => {
      let p = this.views.last(), f = p && p.section.next();
      f && n.push(this.append(f));
    }, b = l + a + h, E = l - h;
    b >= d && T(), E < 0 && m();
    let L = n.map((p) => p.display(this.request));
    return n.length ? Promise.all(L).then(() => this.check()).then(() => this.update(h), (p) => p) : (this.q.enqueue((function() {
      this.update();
    }).bind(this)), s.resolve(!1), s.promise);
  }
  trim() {
    for (var t = new v(), e = this.views.displayed(), s = e[0], n = e[e.length - 1], i = this.views.indexOf(s), h = this.views.indexOf(n), r = this.views.slice(0, i), l = this.views.slice(h + 1), a = 0; a < r.length - 1; a++)
      this.erase(r[a], r);
    for (var d = 1; d < l.length; d++)
      this.erase(l[d]);
    return t.resolve(), t.promise;
  }
  erase(t, e) {
    var s, n;
    this.settings.fullsize ? (s = window.scrollY, n = window.scrollX) : (s = this.container.scrollTop, n = this.container.scrollLeft);
    var i = t.bounds();
    this.views.remove(t), e && (this.settings.axis === "vertical" ? this.scrollTo(0, s - i.height, !0) : this.settings.direction === "rtl" ? this.settings.fullsize ? this.scrollTo(n + Math.floor(i.width), 0, !0) : this.scrollTo(n, 0, !0) : this.scrollTo(n - Math.floor(i.width), 0, !0));
  }
  addEventListeners(t) {
    window.addEventListener("unload", (function(e) {
      this.ignore = !0, this.destroy();
    }).bind(this)), this.addScrollListeners(), this.isPaginated && this.settings.snap && (this.snapper = new y(this, this.settings.snap && typeof this.settings.snap == "object" && this.settings.snap));
  }
  addScrollListeners() {
    var t;
    this.tick = D;
    let e = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
    this.scrollDeltaVert = 0, this.scrollDeltaHorz = 0, this.settings.fullsize ? (t = window, this.scrollTop = window.scrollY * e, this.scrollLeft = window.scrollX * e) : (t = this.container, this.scrollTop = this.container.scrollTop, this.scrollLeft = this.container.scrollLeft), this._onScroll = this.onScroll.bind(this), t.addEventListener("scroll", this._onScroll), this._scrolled = x(this.scrolled.bind(this), 30), this.didScroll = !1;
  }
  removeEventListeners() {
    var t;
    this.settings.fullsize ? t = window : t = this.container, t.removeEventListener("scroll", this._onScroll), this._onScroll = void 0;
  }
  onScroll() {
    let t, e, s = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
    this.settings.fullsize ? (t = window.scrollY * s, e = window.scrollX * s) : (t = this.container.scrollTop, e = this.container.scrollLeft), this.scrollTop = t, this.scrollLeft = e, this.ignore ? this.ignore = !1 : this._scrolled(), this.scrollDeltaVert += Math.abs(t - this.prevScrollTop), this.scrollDeltaHorz += Math.abs(e - this.prevScrollLeft), this.prevScrollTop = t, this.prevScrollLeft = e, clearTimeout(this.scrollTimeout), this.scrollTimeout = setTimeout((function() {
      this.scrollDeltaVert = 0, this.scrollDeltaHorz = 0;
    }).bind(this), 150), clearTimeout(this.afterScrolled), this.didScroll = !1;
  }
  scrolled() {
    this.q.enqueue((function() {
      return this.check();
    }).bind(this)), this.emit(o.MANAGERS.SCROLL, {
      top: this.scrollTop,
      left: this.scrollLeft
    }), clearTimeout(this.afterScrolled), this.afterScrolled = setTimeout((function() {
      this.snapper && this.snapper.supportsTouch && this.snapper.needsSnap() || this.emit(o.MANAGERS.SCROLLED, {
        top: this.scrollTop,
        left: this.scrollLeft
      });
    }).bind(this), this.settings.afterScrolledTimeout);
  }
  next() {
    let t = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
    this.views.length && (this.isPaginated && this.settings.axis === "horizontal" ? this.scrollBy(t, 0, !0) : this.scrollBy(0, this.layout.height, !0), this.q.enqueue((function() {
      return this.check();
    }).bind(this)));
  }
  prev() {
    let t = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
    this.views.length && (this.isPaginated && this.settings.axis === "horizontal" ? this.scrollBy(-t, 0, !0) : this.scrollBy(0, -this.layout.height, !0), this.q.enqueue((function() {
      return this.check();
    }).bind(this)));
  }
  updateFlow(t) {
    this.rendered && this.snapper && (this.snapper.destroy(), this.snapper = void 0), super.updateFlow(t, "scroll"), this.rendered && this.isPaginated && this.settings.snap && (this.snapper = new y(this, this.settings.snap && typeof this.settings.snap == "object" && this.settings.snap));
  }
  destroy() {
    super.destroy(), this.snapper && this.snapper.destroy();
  }
}
export {
  R as default
};
//# sourceMappingURL=index.mjs.map
