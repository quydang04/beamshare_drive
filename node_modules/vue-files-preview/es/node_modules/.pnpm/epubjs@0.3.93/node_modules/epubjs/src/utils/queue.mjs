import { requestAnimationFrame as u, defer as n } from "./core.mjs";
class a {
  constructor(e) {
    this._q = [], this.context = e, this.tick = u, this.running = !1, this.paused = !1;
  }
  /**
   * Add an item to the queue
   * @return {Promise}
   */
  enqueue() {
    var e, i, t, s = [].shift.call(arguments), r = arguments;
    if (!s)
      throw new Error("No Task Provided");
    return typeof s == "function" ? (e = new n(), i = e.promise, t = {
      task: s,
      args: r,
      //"context"  : context,
      deferred: e,
      promise: i
    }) : t = {
      promise: s
    }, this._q.push(t), this.paused == !1 && !this.running && this.run(), t.promise;
  }
  /**
   * Run one item
   * @return {Promise}
   */
  dequeue() {
    var e, i, t;
    if (this._q.length && !this.paused) {
      if (e = this._q.shift(), i = e.task, i)
        return t = i.apply(this.context, e.args), t && typeof t.then == "function" ? t.then((function() {
          e.deferred.resolve.apply(this.context, arguments);
        }).bind(this), (function() {
          e.deferred.reject.apply(this.context, arguments);
        }).bind(this)) : (e.deferred.resolve.apply(this.context, t), e.promise);
      if (e.promise)
        return e.promise;
    } else
      return e = new n(), e.deferred.resolve(), e.promise;
  }
  // Run All Immediately
  dump() {
    for (; this._q.length; )
      this.dequeue();
  }
  /**
   * Run all tasks sequentially, at convince
   * @return {Promise}
   */
  run() {
    return this.running || (this.running = !0, this.defered = new n()), this.tick.call(window, () => {
      this._q.length ? this.dequeue().then((function() {
        this.run();
      }).bind(this)) : (this.defered.resolve(), this.running = void 0);
    }), this.paused == !0 && (this.paused = !1), this.defered.promise;
  }
  /**
   * Flush all, as quickly as possible
   * @return {Promise}
   */
  flush() {
    if (this.running)
      return this.running;
    if (this._q.length)
      return this.running = this.dequeue().then((function() {
        return this.running = void 0, this.flush();
      }).bind(this)), this.running;
  }
  /**
   * Clear all items in wait
   */
  clear() {
    this._q = [];
  }
  /**
   * Get the number of tasks in the queue
   * @return {number} tasks
   */
  length() {
    return this._q.length;
  }
  /**
   * Pause a running queue
   */
  pause() {
    this.paused = !0;
  }
  /**
   * End the queue
   */
  stop() {
    this._q = [], this.running = !1, this.paused = !0;
  }
}
export {
  a as default
};
//# sourceMappingURL=queue.mjs.map
