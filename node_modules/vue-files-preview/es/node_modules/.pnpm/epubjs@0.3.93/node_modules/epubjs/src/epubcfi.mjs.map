{"version":3,"file":"epubcfi.mjs","sources":["../../../../../../../../node_modules/.pnpm/epubjs@0.3.93/node_modules/epubjs/src/epubcfi.js"],"sourcesContent":["import {extend, type, findChildren, RangeObject, isNumber} from \"./utils/core\";\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\n\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\nclass EpubCFI {\n\tconstructor(cfiFrom, base, ignoreClass){\n\t\tvar type;\n\n\t\tthis.str = \"\";\n\n\t\tthis.base = {};\n\t\tthis.spinePos = 0; // For compatibility\n\n\t\tthis.range = false; // true || false;\n\n\t\tthis.path = {};\n\t\tthis.start = null;\n\t\tthis.end = null;\n\n\t\t// Allow instantiation without the \"new\" keyword\n\t\tif (!(this instanceof EpubCFI)) {\n\t\t\treturn new EpubCFI(cfiFrom, base, ignoreClass);\n\t\t}\n\n\t\tif(typeof base === \"string\") {\n\t\t\tthis.base = this.parseComponent(base);\n\t\t} else if(typeof base === \"object\" && base.steps) {\n\t\t\tthis.base = base;\n\t\t}\n\n\t\ttype = this.checkType(cfiFrom);\n\n\n\t\tif(type === \"string\") {\n\t\t\tthis.str = cfiFrom;\n\t\t\treturn extend(this, this.parse(cfiFrom));\n\t\t} else if (type === \"range\") {\n\t\t\treturn extend(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"node\") {\n\t\t\treturn extend(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"EpubCFI\" && cfiFrom.path) {\n\t\t\treturn cfiFrom;\n\t\t} else if (!cfiFrom) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new TypeError(\"not a valid argument for EpubCFI\");\n\t\t}\n\n\t}\n\n\t/**\n\t * Check the type of constructor input\n\t * @private\n\t */\n\tcheckType(cfi) {\n\n\t\tif (this.isCfiString(cfi)) {\n\t\t\treturn \"string\";\n\t\t// Is a range object\n\t\t} else if (cfi && typeof cfi === \"object\" && (type(cfi) === \"Range\" || typeof(cfi.startContainer) != \"undefined\")){\n\t\t\treturn \"range\";\n\t\t} else if (cfi && typeof cfi === \"object\" && typeof(cfi.nodeType) != \"undefined\" ){ // || typeof cfi === \"function\"\n\t\t\treturn \"node\";\n\t\t} else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI){\n\t\t\treturn \"EpubCFI\";\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a cfi string to a CFI object representation\n\t * @param {string} cfiStr\n\t * @returns {object} cfi\n\t */\n\tparse(cfiStr) {\n\t\tvar cfi = {\n\t\t\tspinePos: -1,\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\t\tvar baseComponent, pathComponent, range;\n\n\t\tif(typeof cfiStr !== \"string\") {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tif(cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length-1] === \")\") {\n\t\t\t// Remove initial epubcfi( and ending )\n\t\t\tcfiStr = cfiStr.slice(8, cfiStr.length-1);\n\t\t}\n\n\t\tbaseComponent = this.getChapterComponent(cfiStr);\n\n\t\t// Make sure this is a valid cfi or return\n\t\tif(!baseComponent) {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tcfi.base = this.parseComponent(baseComponent);\n\n\t\tpathComponent = this.getPathComponent(cfiStr);\n\t\tcfi.path = this.parseComponent(pathComponent);\n\n\t\trange = this.getRange(cfiStr);\n\n\t\tif(range) {\n\t\t\tcfi.range = true;\n\t\t\tcfi.start = this.parseComponent(range[0]);\n\t\t\tcfi.end = this.parseComponent(range[1]);\n\t\t}\n\n\t\t// Get spine node position\n\t\t// cfi.spineSegment = cfi.base.steps[1];\n\n\t\t// Chapter segment is always the second step\n\t\tcfi.spinePos = cfi.base.steps[1].index;\n\n\t\treturn cfi;\n\t}\n\n\tparseComponent(componentStr){\n\t\tvar component = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar parts = componentStr.split(\":\");\n\t\tvar steps = parts[0].split(\"/\");\n\t\tvar terminal;\n\n\t\tif(parts.length > 1) {\n\t\t\tterminal = parts[1];\n\t\t\tcomponent.terminal = this.parseTerminal(terminal);\n\t\t}\n\n\t\tif (steps[0] === \"\") {\n\t\t\tsteps.shift(); // Ignore the first slash\n\t\t}\n\n\t\tcomponent.steps = steps.map(function(step){\n\t\t\treturn this.parseStep(step);\n\t\t}.bind(this));\n\n\t\treturn component;\n\t}\n\n\tparseStep(stepStr){\n\t\tvar type, num, index, has_brackets, id;\n\n\t\thas_brackets = stepStr.match(/\\[(.*)\\]/);\n\t\tif(has_brackets && has_brackets[1]){\n\t\t\tid = has_brackets[1];\n\t\t}\n\n\t\t//-- Check if step is a text node or element\n\t\tnum = parseInt(stepStr);\n\n\t\tif(isNaN(num)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(num % 2 === 0) { // Even = is an element\n\t\t\ttype = \"element\";\n\t\t\tindex = num / 2 - 1;\n\t\t} else {\n\t\t\ttype = \"text\";\n\t\t\tindex = (num - 1 ) / 2;\n\t\t}\n\n\t\treturn {\n\t\t\t\"type\" : type,\n\t\t\t\"index\" : index,\n\t\t\t\"id\" : id || null\n\t\t};\n\t}\n\n\tparseTerminal(termialStr){\n\t\tvar characterOffset, textLocationAssertion;\n\t\tvar assertion = termialStr.match(/\\[(.*)\\]/);\n\n\t\tif(assertion && assertion[1]){\n\t\t\tcharacterOffset = parseInt(termialStr.split(\"[\")[0]);\n\t\t\ttextLocationAssertion = assertion[1];\n\t\t} else {\n\t\t\tcharacterOffset = parseInt(termialStr);\n\t\t}\n\n\t\tif (!isNumber(characterOffset)) {\n\t\t\tcharacterOffset = null;\n\t\t}\n\n\t\treturn {\n\t\t\t\"offset\": characterOffset,\n\t\t\t\"assertion\": textLocationAssertion\n\t\t};\n\n\t}\n\n\tgetChapterComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\treturn indirection[0];\n\t}\n\n\tgetPathComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\tif(indirection[1]) {\n\t\t\tlet ranges = indirection[1].split(\",\");\n\t\t\treturn ranges[0];\n\t\t}\n\n\t}\n\n\tgetRange(cfiStr) {\n\n\t\tvar ranges = cfiStr.split(\",\");\n\n\t\tif(ranges.length === 3){\n\t\t\treturn [\n\t\t\t\tranges[1],\n\t\t\t\tranges[2]\n\t\t\t];\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetCharecterOffsetComponent(cfiStr) {\n\t\tvar splitStr = cfiStr.split(\":\");\n\t\treturn splitStr[1] || \"\";\n\t}\n\n\tjoinSteps(steps) {\n\t\tif(!steps) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn steps.map(function(part){\n\t\t\tvar segment = \"\";\n\n\t\t\tif(part.type === \"element\") {\n\t\t\t\tsegment += (part.index + 1) * 2;\n\t\t\t}\n\n\t\t\tif(part.type === \"text\") {\n\t\t\t\tsegment += 1 + (2 * part.index); // TODO: double check that this is odd\n\t\t\t}\n\n\t\t\tif(part.id) {\n\t\t\t\tsegment += \"[\" + part.id + \"]\";\n\t\t\t}\n\n\t\t\treturn segment;\n\n\t\t}).join(\"/\");\n\n\t}\n\n\tsegmentString(segment) {\n\t\tvar segmentString = \"/\";\n\n\t\tsegmentString += this.joinSteps(segment.steps);\n\n\t\tif(segment.terminal && segment.terminal.offset != null){\n\t\t\tsegmentString += \":\" + segment.terminal.offset;\n\t\t}\n\n\t\tif(segment.terminal && segment.terminal.assertion != null){\n\t\t\tsegmentString += \"[\" + segment.terminal.assertion + \"]\";\n\t\t}\n\n\t\treturn segmentString;\n\t}\n\n\t/**\n\t * Convert CFI to a epubcfi(...) string\n\t * @returns {string} epubcfi\n\t */\n\ttoString() {\n\t\tvar cfiString = \"epubcfi(\";\n\n\t\tcfiString += this.segmentString(this.base);\n\n\t\tcfiString += \"!\";\n\t\tcfiString += this.segmentString(this.path);\n\n\t\t// Add Range, if present\n\t\tif(this.range && this.start) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.start);\n\t\t}\n\n\t\tif(this.range && this.end) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.end);\n\t\t}\n\n\t\tcfiString += \")\";\n\n\t\treturn cfiString;\n\t}\n\n\n\t/**\n\t * Compare which of two CFIs is earlier in the text\n\t * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n\t */\n\tcompare(cfiOne, cfiTwo) {\n\t\tvar stepsA, stepsB;\n\t\tvar terminalA, terminalB;\n\n\t\tvar rangeAStartSteps, rangeAEndSteps;\n\t\tvar rangeBEndSteps, rangeBEndSteps;\n\t\tvar rangeAStartTerminal, rangeAEndTerminal;\n\t\tvar rangeBStartTerminal, rangeBEndTerminal;\n\n\t\tif(typeof cfiOne === \"string\") {\n\t\t\tcfiOne = new EpubCFI(cfiOne);\n\t\t}\n\t\tif(typeof cfiTwo === \"string\") {\n\t\t\tcfiTwo = new EpubCFI(cfiTwo);\n\t\t}\n\t\t// Compare Spine Positions\n\t\tif(cfiOne.spinePos > cfiTwo.spinePos) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(cfiOne.spinePos < cfiTwo.spinePos) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (cfiOne.range) {\n\t\t\tstepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n\t\t\tterminalA = cfiOne.start.terminal;\n\t\t} else {\n\t\t\tstepsA = cfiOne.path.steps;\n\t\t\tterminalA = cfiOne.path.terminal;\n\t\t}\n\n\t\tif (cfiTwo.range) {\n\t\t\tstepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n\t\t\tterminalB = cfiTwo.start.terminal;\n\t\t} else {\n\t\t\tstepsB = cfiTwo.path.steps;\n\t\t\tterminalB = cfiTwo.path.terminal;\n\t\t}\n\n\t\t// Compare Each Step in the First item\n\t\tfor (var i = 0; i < stepsA.length; i++) {\n\t\t\tif(!stepsA[i]) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(!stepsB[i]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index > stepsB[i].index) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index < stepsB[i].index) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// Otherwise continue checking\n\t\t}\n\n\t\t// All steps in First equal to Second and First is Less Specific\n\t\tif(stepsA.length < stepsB.length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Compare the character offset of the text node\n\t\tif(terminalA.offset > terminalB.offset) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(terminalA.offset < terminalB.offset) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// CFI's are equal\n\t\treturn 0;\n\t}\n\n\tstep(node) {\n\t\tvar nodeType = (node.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : node.id,\n\t\t\t\"tagName\" : node.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.position(node)\n\t\t};\n\t}\n\n\tfilteredStep(node, ignoreClass) {\n\t\tvar filteredNode = this.filter(node, ignoreClass);\n\t\tvar nodeType;\n\n\t\t// Node filtered, so ignore\n\t\tif (!filteredNode) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise add the filter node in\n\t\tnodeType = (filteredNode.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : filteredNode.id,\n\t\t\t\"tagName\" : filteredNode.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.filteredPosition(filteredNode, ignoreClass)\n\t\t};\n\t}\n\n\tpathTo(node, offset, ignoreClass) {\n\t\tvar segment = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar currentNode = node;\n\t\tvar step;\n\n\t\twhile(currentNode && currentNode.parentNode &&\n\t\t\t\t\tcurrentNode.parentNode.nodeType != DOCUMENT_NODE) {\n\n\t\t\tif (ignoreClass) {\n\t\t\t\tstep = this.filteredStep(currentNode, ignoreClass);\n\t\t\t} else {\n\t\t\t\tstep = this.step(currentNode);\n\t\t\t}\n\n\t\t\tif (step) {\n\t\t\t\tsegment.steps.unshift(step);\n\t\t\t}\n\n\t\t\tcurrentNode = currentNode.parentNode;\n\n\t\t}\n\n\t\tif (offset != null && offset >= 0) {\n\n\t\t\tsegment.terminal.offset = offset;\n\n\t\t\t// Make sure we are getting to a textNode if there is an offset\n\t\t\tif(segment.steps[segment.steps.length-1].type != \"text\") {\n\t\t\t\tsegment.steps.push({\n\t\t\t\t\t\"type\" : \"text\",\n\t\t\t\t\t\"index\" : 0\n\t\t\t\t});\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn segment;\n\t}\n\n\tequalStep(stepA, stepB) {\n\t\tif (!stepA || !stepB) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(stepA.index === stepB.index &&\n\t\t\t stepA.id === stepB.id &&\n\t\t\t stepA.type === stepB.type) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create a CFI object from a Range\n\t * @param {Range} range\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromRange(range, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tvar start = range.startContainer;\n\t\tvar end = range.endContainer;\n\n\t\tvar startOffset = range.startOffset;\n\t\tvar endOffset = range.endOffset;\n\n\t\tvar needsIgnoring = false;\n\n\t\tif (ignoreClass) {\n\t\t\t// Tell pathTo if / what to ignore\n\t\t\tneedsIgnoring = (start.ownerDocument.querySelector(\".\" + ignoreClass) != null);\n\t\t}\n\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tif (range.collapsed) {\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\t\t\tcfi.path = this.pathTo(start, startOffset, ignoreClass);\n\t\t} else {\n\t\t\tcfi.range = true;\n\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.start = this.pathTo(start, startOffset, ignoreClass);\n\t\t\tif (needsIgnoring) {\n\t\t\t\tendOffset = this.patchOffset(end, endOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.end = this.pathTo(end, endOffset, ignoreClass);\n\n\t\t\t// Create a new empty path\n\t\t\tcfi.path = {\n\t\t\t\tsteps: [],\n\t\t\t\tterminal: null\n\t\t\t};\n\n\t\t\t// Push steps that are shared between start and end to the common path\n\t\t\tvar len = cfi.start.steps.length;\n\t\t\tvar i;\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n\t\t\t\t\tif(i === len-1) {\n\t\t\t\t\t\t// Last step is equal, check terminals\n\t\t\t\t\t\tif(cfi.start.terminal === cfi.end.terminal) {\n\t\t\t\t\t\t\t// CFI's are equal\n\t\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t\t\t// Not a range\n\t\t\t\t\t\t\tcfi.range = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n\t\t\tcfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);\n\n\t\t\t// TODO: Add Sanity check to make sure that the end if greater than the start\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Create a CFI object from a Node\n\t * @param {Node} anchor\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromNode(anchor, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tcfi.path = this.pathTo(anchor, null, ignoreClass);\n\n\t\treturn cfi;\n\t}\n\n\tfilter(anchor, ignoreClass) {\n\t\tvar needsIgnoring;\n\t\tvar sibling; // to join with\n\t\tvar parent, previousSibling, nextSibling;\n\t\tvar isText = false;\n\n\t\tif (anchor.nodeType === TEXT_NODE) {\n\t\t\tisText = true;\n\t\t\tparent = anchor.parentNode;\n\t\t\tneedsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n\t\t} else {\n\t\t\tisText = false;\n\t\t\tneedsIgnoring = anchor.classList.contains(ignoreClass);\n\t\t}\n\n\t\tif (needsIgnoring && isText) {\n\t\t\tpreviousSibling = parent.previousSibling;\n\t\t\tnextSibling = parent.nextSibling;\n\n\t\t\t// If the sibling is a text node, join the nodes\n\t\t\tif (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = previousSibling;\n\t\t\t} else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = nextSibling;\n\t\t\t}\n\n\t\t\tif (sibling) {\n\t\t\t\treturn sibling;\n\t\t\t} else {\n\t\t\t\t// Parent will be ignored on next step\n\t\t\t\treturn anchor;\n\t\t\t}\n\n\t\t} else if (needsIgnoring && !isText) {\n\t\t\t// Otherwise just skip the element node\n\t\t\treturn false;\n\t\t} else {\n\t\t\t// No need to filter\n\t\t\treturn anchor;\n\t\t}\n\n\t}\n\n\tpatchOffset(anchor, offset, ignoreClass) {\n\t\tif (anchor.nodeType != TEXT_NODE) {\n\t\t\tthrow new Error(\"Anchor must be a text node\");\n\t\t}\n\n\t\tvar curr = anchor;\n\t\tvar totalOffset = offset;\n\n\t\t// If the parent is a ignored node, get offset from it's start\n\t\tif (anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\tcurr = anchor.parentNode;\n\t\t}\n\n\t\twhile (curr.previousSibling) {\n\t\t\tif(curr.previousSibling.nodeType === ELEMENT_NODE) {\n\t\t\t\t// Originally a text node, so join\n\t\t\t\tif(curr.previousSibling.classList.contains(ignoreClass)){\n\t\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t\t} else {\n\t\t\t\t\tbreak; // Normal node, dont join\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If the previous sibling is a text node, join the nodes\n\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t}\n\n\t\t\tcurr = curr.previousSibling;\n\t\t}\n\n\t\treturn totalOffset;\n\n\t}\n\n\tnormalizedMap(children, nodeType, ignoreClass) {\n\t\tvar output = {};\n\t\tvar prevIndex = -1;\n\t\tvar i, len = children.length;\n\t\tvar currNodeType;\n\t\tvar prevNodeType;\n\n\t\tfor (i = 0; i < len; i++) {\n\n\t\t\tcurrNodeType = children[i].nodeType;\n\n\t\t\t// Check if needs ignoring\n\t\t\tif (currNodeType === ELEMENT_NODE &&\n\t\t\t\t\tchildren[i].classList.contains(ignoreClass)) {\n\t\t\t\tcurrNodeType = TEXT_NODE;\n\t\t\t}\n\n\t\t\tif (i > 0 &&\n\t\t\t\t\tcurrNodeType === TEXT_NODE &&\n\t\t\t\t\tprevNodeType === TEXT_NODE) {\n\t\t\t\t// join text nodes\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t} else if (nodeType === currNodeType){\n\t\t\t\tprevIndex = prevIndex + 1;\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t}\n\n\t\t\tprevNodeType = currNodeType;\n\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tposition(anchor) {\n\t\tvar children, index;\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tif (!children) {\n\t\t\t\tchildren = findChildren(anchor.parentNode);\n\t\t\t}\n\t\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\t\t} else {\n\t\t\tchildren = this.textNodes(anchor.parentNode);\n\t\t\tindex = children.indexOf(anchor);\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfilteredPosition(anchor, ignoreClass) {\n\t\tvar children, index, map;\n\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tmap = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n\t\t} else {\n\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t// Inside an ignored node\n\t\t\tif(anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\t\tanchor = anchor.parentNode;\n\t\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t}\n\t\t\tmap = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\t}\n\n\n\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\n\t\treturn map[index];\n\t}\n\n\tstepsToXpath(steps) {\n\t\tvar xpath = [\".\", \"*\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\txpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\txpath.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\txpath.push(\"*[\" + position + \"]\");\n\t\t\t}\n\t\t});\n\n\t\treturn xpath.join(\"/\");\n\t}\n\n\n\t/*\n\n\tTo get the last step if needed:\n\n\t// Get the terminal step\n\tlastStep = steps[steps.length-1];\n\t// Get the query string\n\tquery = this.stepsToQuery(steps);\n\t// Find the containing element\n\tstartContainerParent = doc.querySelector(query);\n\t// Find the text node within that element\n\tif(startContainerParent && lastStep.type == \"text\") {\n\t\tcontainer = startContainerParent.childNodes[lastStep.index];\n\t}\n\t*/\n\tstepsToQuerySelector(steps) {\n\t\tvar query = [\"html\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\tquery.push(\"#\" + step.id);\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\t// unsupported in querySelector\n\t\t\t\t// query.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\tquery.push(\"*:nth-child(\" + position + \")\");\n\t\t\t}\n\t\t});\n\n\t\treturn query.join(\">\");\n\n\t}\n\n\ttextNodes(container, ignoreClass) {\n\t\treturn Array.prototype.slice.call(container.childNodes).\n\t\t\tfilter(function (node) {\n\t\t\t\tif (node.nodeType === TEXT_NODE) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (ignoreClass && node.classList.contains(ignoreClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t}\n\n\twalkToNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container = doc.documentElement;\n\t\tvar children;\n\t\tvar step;\n\t\tvar len = steps.length;\n\t\tvar i;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tstep = steps[i];\n\n\t\t\tif(step.type === \"element\") {\n\t\t\t\t//better to get a container using id as some times step.index may not be correct\n\t\t\t\t//For ex.https://github.com/futurepress/epub.js/issues/561\n\t\t\t\tif(step.id) {\n\t\t\t\t\tcontainer = doc.getElementById(step.id);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildren = container.children || findChildren(container);\n\t\t\t\t\tcontainer = children[step.index];\n\t\t\t\t}\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\tcontainer = this.textNodes(container, ignoreClass)[step.index];\n\t\t\t}\n\t\t\tif(!container) {\n\t\t\t\t//Break the for loop as due to incorrect index we can get error if\n\t\t\t\t//container is undefined so that other functionailties works fine\n\t\t\t\t//like navigation\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfindNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container;\n\t\tvar xpath;\n\n\t\tif(!ignoreClass && typeof doc.evaluate != \"undefined\") {\n\t\t\txpath = this.stepsToXpath(steps);\n\t\t\tcontainer = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\t\t} else if(ignoreClass) {\n\t\t\tcontainer = this.walkToNode(steps, doc, ignoreClass);\n\t\t} else {\n\t\t\tcontainer = this.walkToNode(steps, doc);\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfixMiss(steps, offset, _doc, ignoreClass) {\n\t\tvar container = this.findNode(steps.slice(0,-1), _doc, ignoreClass);\n\t\tvar children = container.childNodes;\n\t\tvar map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\tvar child;\n\t\tvar len;\n\t\tvar lastStepIndex = steps[steps.length-1].index;\n\n\t\tfor (let childIndex in map) {\n\t\t\tif (!map.hasOwnProperty(childIndex)) return;\n\n\t\t\tif(map[childIndex] === lastStepIndex) {\n\t\t\t\tchild = children[childIndex];\n\t\t\t\tlen = child.textContent.length;\n\t\t\t\tif(offset > len) {\n\t\t\t\t\toffset = offset - len;\n\t\t\t\t} else {\n\t\t\t\t\tif (child.nodeType === ELEMENT_NODE) {\n\t\t\t\t\t\tcontainer = child.childNodes[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainer = child;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcontainer: container,\n\t\t\toffset: offset\n\t\t};\n\n\t}\n\n\t/**\n\t * Creates a DOM range representing a CFI\n\t * @param {document} _doc document referenced in the base\n\t * @param {string} [ignoreClass]\n\t * @return {Range}\n\t */\n\ttoRange(_doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar range;\n\t\tvar start, end, startContainer, endContainer;\n\t\tvar cfi = this;\n\t\tvar startSteps, endSteps;\n\t\tvar needsIgnoring = ignoreClass ? (doc.querySelector(\".\" + ignoreClass) != null) : false;\n\t\tvar missed;\n\n\t\tif (typeof(doc.createRange) !== \"undefined\") {\n\t\t\trange = doc.createRange();\n\t\t} else {\n\t\t\trange = new RangeObject();\n\t\t}\n\n\t\tif (cfi.range) {\n\t\t\tstart = cfi.start;\n\t\t\tstartSteps = cfi.path.steps.concat(start.steps);\n\t\t\tstartContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t\tend = cfi.end;\n\t\t\tendSteps = cfi.path.steps.concat(end.steps);\n\t\t\tendContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t} else {\n\t\t\tstart = cfi.path;\n\t\t\tstartSteps = cfi.path.steps;\n\t\t\tstartContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n\t\t}\n\n\t\tif(startContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(start.terminal.offset != null) {\n\t\t\t\t\trange.setStart(startContainer, start.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setStart(startContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setStart(missed.container, missed.offset);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log(\"No startContainer found for\", this.toString());\n\t\t\t// No start found\n\t\t\treturn null;\n\t\t}\n\n\t\tif (endContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(end.terminal.offset != null) {\n\t\t\t\t\trange.setEnd(endContainer, end.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setEnd(endContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setEnd(missed.container, missed.offset);\n\t\t\t}\n\t\t}\n\n\n\t\t// doc.defaultView.getSelection().addRange(range);\n\t\treturn range;\n\t}\n\n\t/**\n\t * Check if a string is wrapped with \"epubcfi()\"\n\t * @param {string} str\n\t * @returns {boolean}\n\t */\n\tisCfiString(str) {\n\t\tif(typeof str === \"string\" &&\n\t\t\tstr.indexOf(\"epubcfi(\") === 0 &&\n\t\t\tstr[str.length-1] === \")\") {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgenerateChapterComponent(_spineNodeIndex, _pos, id) {\n\t\tvar pos = parseInt(_pos),\n\t\t\t\tspineNodeIndex = (_spineNodeIndex + 1) * 2,\n\t\t\t\tcfi = \"/\"+spineNodeIndex+\"/\";\n\n\t\tcfi += (pos + 1) * 2;\n\n\t\tif(id) {\n\t\t\tcfi += \"[\" + id + \"]\";\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Collapse a CFI Range to a single CFI Position\n\t * @param {boolean} [toStart=false]\n\t */\n\tcollapse(toStart) {\n\t\tif (!this.range) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.range = false;\n\n\t\tif (toStart) {\n\t\t\tthis.path.steps = this.path.steps.concat(this.start.steps);\n\t\t\tthis.path.terminal = this.start.terminal;\n\t\t} else {\n\t\t\tthis.path.steps = this.path.steps.concat(this.end.steps);\n\t\t\tthis.path.terminal = this.end.terminal;\n\t\t}\n\n\t}\n}\n\nexport default EpubCFI;\n"],"names":["ELEMENT_NODE","TEXT_NODE","DOCUMENT_NODE","EpubCFI","cfiFrom","base","ignoreClass","type","extend","cfi","cfiStr","baseComponent","pathComponent","range","componentStr","component","parts","steps","terminal","step","stepStr","num","index","has_brackets","id","termialStr","characterOffset","textLocationAssertion","assertion","isNumber","indirection","ranges","splitStr","part","segment","segmentString","cfiString","cfiOne","cfiTwo","stepsA","stepsB","terminalA","terminalB","i","node","nodeType","filteredNode","offset","currentNode","stepA","stepB","start","end","startOffset","endOffset","needsIgnoring","len","anchor","sibling","parent","previousSibling","nextSibling","isText","curr","totalOffset","children","output","prevIndex","currNodeType","prevNodeType","findChildren","map","xpath","position","query","container","_doc","doc","child","lastStepIndex","childIndex","startContainer","endContainer","startSteps","endSteps","missed","RangeObject","str","_spineNodeIndex","_pos","pos","spineNodeIndex","toStart"],"mappings":"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","x_google_ignoreList":[0]}