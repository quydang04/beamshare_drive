import { substitute as h } from "./utils/replacements.mjs";
import { blob2base64 as f, createBase64Url as a, createBlobUrl as u } from "./utils/core.mjs";
import m from "./utils/url.mjs";
import p from "./utils/mime.mjs";
import c from "./utils/path.mjs";
import d from "../../../../path-webpack@0.0.3/node_modules/path-webpack/path.mjs";
class P {
  constructor(e, t) {
    this.settings = {
      replacements: t && t.replacements || "base64",
      archive: t && t.archive,
      resolver: t && t.resolver,
      request: t && t.request
    }, this.process(e);
  }
  /**
   * Process resources
   * @param {Manifest} manifest
   */
  process(e) {
    this.manifest = e, this.resources = Object.keys(e).map(function(t) {
      return e[t];
    }), this.replacementUrls = [], this.html = [], this.assets = [], this.css = [], this.urls = [], this.cssUrls = [], this.split(), this.splitUrls();
  }
  /**
   * Split resources by type
   * @private
   */
  split() {
    this.html = this.resources.filter(function(e) {
      if (e.type === "application/xhtml+xml" || e.type === "text/html")
        return !0;
    }), this.assets = this.resources.filter(function(e) {
      if (e.type !== "application/xhtml+xml" && e.type !== "text/html")
        return !0;
    }), this.css = this.resources.filter(function(e) {
      if (e.type === "text/css")
        return !0;
    });
  }
  /**
   * Convert split resources into Urls
   * @private
   */
  splitUrls() {
    this.urls = this.assets.map((function(e) {
      return e.href;
    }).bind(this)), this.cssUrls = this.css.map(function(e) {
      return e.href;
    });
  }
  /**
   * Create a url to a resource
   * @param {string} url
   * @return {Promise<string>} Promise resolves with url string
   */
  createUrl(e) {
    var t = new m(e), s = p.lookup(t.filename);
    return this.settings.archive ? this.settings.archive.createUrl(e, { base64: this.settings.replacements === "base64" }) : this.settings.replacements === "base64" ? this.settings.request(e, "blob").then((r) => f(r)).then((r) => a(r, s)) : this.settings.request(e, "blob").then((r) => u(r, s));
  }
  /**
   * Create blob urls for all the assets
   * @return {Promise}         returns replacement urls
   */
  replacements() {
    if (this.settings.replacements === "none")
      return new Promise((function(t) {
        t(this.urls);
      }).bind(this));
    var e = this.urls.map((t) => {
      var s = this.settings.resolver(t);
      return this.createUrl(s).catch((r) => (console.error(r), null));
    });
    return Promise.all(e).then((t) => (this.replacementUrls = t.filter((s) => typeof s == "string"), t));
  }
  /**
   * Replace URLs in CSS resources
   * @private
   * @param  {Archive} [archive]
   * @param  {method} [resolver]
   * @return {Promise}
   */
  replaceCss(e, t) {
    var s = [];
    return e = e || this.settings.archive, t = t || this.settings.resolver, this.cssUrls.forEach((function(r) {
      var l = this.createCssFile(r, e, t).then((function(i) {
        var n = this.urls.indexOf(r);
        n > -1 && (this.replacementUrls[n] = i);
      }).bind(this));
      s.push(l);
    }).bind(this)), Promise.all(s);
  }
  /**
   * Create a new CSS file with the replaced URLs
   * @private
   * @param  {string} href the original css file
   * @return {Promise}  returns a BlobUrl to the new CSS file or a data url
   */
  createCssFile(e) {
    var t;
    if (d.isAbsolute(e))
      return new Promise(function(i) {
        i();
      });
    var s = this.settings.resolver(e), r;
    this.settings.archive ? r = this.settings.archive.getText(s) : r = this.settings.request(s, "text");
    var l = this.urls.map((i) => {
      var n = this.settings.resolver(i), o = new c(s).relative(n);
      return o;
    });
    return r ? r.then((i) => (i = h(i, l, this.replacementUrls), this.settings.replacements === "base64" ? t = a(i, "text/css") : t = u(i, "text/css"), t), (i) => new Promise(function(n) {
      n();
    })) : new Promise(function(i) {
      i();
    });
  }
  /**
   * Resolve all resources URLs relative to an absolute URL
   * @param  {string} absolute to be resolved to
   * @param  {resolver} [resolver]
   * @return {string[]} array with relative Urls
   */
  relativeTo(e, t) {
    return t = t || this.settings.resolver, this.urls.map((function(s) {
      var r = t(s), l = new c(e).relative(r);
      return l;
    }).bind(this));
  }
  /**
   * Get a URL for a resource
   * @param  {string} path
   * @return {string} url
   */
  get(e) {
    var t = this.urls.indexOf(e);
    if (t !== -1)
      return this.replacementUrls.length ? new Promise((function(s, r) {
        s(this.replacementUrls[t]);
      }).bind(this)) : this.createUrl(e);
  }
  /**
   * Substitute urls in content, with replacements,
   * relative to a url if provided
   * @param  {string} content
   * @param  {string} [url]   url to resolve to
   * @return {string}         content with urls substituted
   */
  substitute(e, t) {
    var s;
    return t ? s = this.relativeTo(t) : s = this.urls, h(e, s, this.replacementUrls);
  }
  destroy() {
    this.settings = void 0, this.manifest = void 0, this.resources = void 0, this.replacementUrls = void 0, this.html = void 0, this.assets = void 0, this.css = void 0, this.urls = void 0, this.cssUrls = void 0;
  }
}
export {
  P as default
};
//# sourceMappingURL=resources.mjs.map
