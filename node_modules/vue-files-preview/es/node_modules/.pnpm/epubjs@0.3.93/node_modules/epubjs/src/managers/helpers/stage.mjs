import { uuid as d, extend as c, isNumber as o, isElement as f, windowBounds as h } from "../../utils/core.mjs";
import g from "../../../../../../lodash@4.17.21/node_modules/lodash/throttle.mjs";
class w {
  constructor(t) {
    this.settings = t || {}, this.id = "epubjs-container-" + d(), this.container = this.create(this.settings), this.settings.hidden && (this.wrapper = this.wrap(this.container));
  }
  /*
  * Creates an element to render to.
  * Resizes to passed width and height or to the elements size
  */
  create(t) {
    let e = t.height, n = t.width, r = t.overflow || !1, l = t.axis || "vertical", s = t.direction;
    c(this.settings, t), t.height && o(t.height) && (e = t.height + "px"), t.width && o(t.width) && (n = t.width + "px");
    let i = document.createElement("div");
    return i.id = this.id, i.classList.add("epub-container"), i.style.wordSpacing = "0", i.style.lineHeight = "0", i.style.verticalAlign = "top", i.style.position = "relative", l === "horizontal" && (i.style.display = "flex", i.style.flexDirection = "row", i.style.flexWrap = "nowrap"), n && (i.style.width = n), e && (i.style.height = e), r && (r === "scroll" && l === "vertical" ? (i.style["overflow-y"] = r, i.style["overflow-x"] = "hidden") : r === "scroll" && l === "horizontal" ? (i.style["overflow-y"] = "hidden", i.style["overflow-x"] = r) : i.style.overflow = r), s && (i.dir = s, i.style.direction = s), s && this.settings.fullsize && (document.body.style.direction = s), i;
  }
  wrap(t) {
    var e = document.createElement("div");
    return e.style.visibility = "hidden", e.style.overflow = "hidden", e.style.width = "0", e.style.height = "0", e.appendChild(t), e;
  }
  getElement(t) {
    var e;
    if (f(t) ? e = t : typeof t == "string" && (e = document.getElementById(t)), !e)
      throw new Error("Not an Element");
    return e;
  }
  attachTo(t) {
    var e = this.getElement(t), n;
    if (e)
      return this.settings.hidden ? n = this.wrapper : n = this.container, e.appendChild(n), this.element = e, e;
  }
  getContainer() {
    return this.container;
  }
  onResize(t) {
    (!o(this.settings.width) || !o(this.settings.height)) && (this.resizeFunc = g(t, 50), window.addEventListener("resize", this.resizeFunc, !1));
  }
  onOrientationChange(t) {
    this.orientationChangeFunc = t, window.addEventListener("orientationchange", this.orientationChangeFunc, !1);
  }
  size(t, e) {
    var n;
    let r = t || this.settings.width, l = e || this.settings.height;
    t === null ? (n = this.element.getBoundingClientRect(), n.width && (t = Math.floor(n.width), this.container.style.width = t + "px")) : o(t) ? this.container.style.width = t + "px" : this.container.style.width = t, e === null ? (n = n || this.element.getBoundingClientRect(), n.height && (e = n.height, this.container.style.height = e + "px")) : o(e) ? this.container.style.height = e + "px" : this.container.style.height = e, o(t) || (t = this.container.clientWidth), o(e) || (e = this.container.clientHeight), this.containerStyles = window.getComputedStyle(this.container), this.containerPadding = {
      left: parseFloat(this.containerStyles["padding-left"]) || 0,
      right: parseFloat(this.containerStyles["padding-right"]) || 0,
      top: parseFloat(this.containerStyles["padding-top"]) || 0,
      bottom: parseFloat(this.containerStyles["padding-bottom"]) || 0
    };
    let s = h(), i = window.getComputedStyle(document.body), a = {
      left: parseFloat(i["padding-left"]) || 0,
      right: parseFloat(i["padding-right"]) || 0,
      top: parseFloat(i["padding-top"]) || 0,
      bottom: parseFloat(i["padding-bottom"]) || 0
    };
    return r || (t = s.width - a.left - a.right), (this.settings.fullsize && !l || !l) && (e = s.height - a.top - a.bottom), {
      width: t - this.containerPadding.left - this.containerPadding.right,
      height: e - this.containerPadding.top - this.containerPadding.bottom
    };
  }
  bounds() {
    let t;
    return this.container.style.overflow !== "visible" && (t = this.container && this.container.getBoundingClientRect()), !t || !t.width || !t.height ? h() : t;
  }
  getSheet() {
    var t = document.createElement("style");
    return t.appendChild(document.createTextNode("")), document.head.appendChild(t), t.sheet;
  }
  addStyleRules(t, e) {
    var n = "#" + this.id + " ", r = "";
    this.sheet || (this.sheet = this.getSheet()), e.forEach(function(l) {
      for (var s in l)
        l.hasOwnProperty(s) && (r += s + ":" + l[s] + ";");
    }), this.sheet.insertRule(n + t + " {" + r + "}", 0);
  }
  axis(t) {
    t === "horizontal" ? (this.container.style.display = "flex", this.container.style.flexDirection = "row", this.container.style.flexWrap = "nowrap") : this.container.style.display = "block", this.settings.axis = t;
  }
  // orientation(orientation) {
  // 	if (orientation === "landscape") {
  //
  // 	} else {
  //
  // 	}
  //
  // 	this.orientation = orientation;
  // }
  direction(t) {
    this.container && (this.container.dir = t, this.container.style.direction = t), this.settings.fullsize && (document.body.style.direction = t), this.settings.dir = t;
  }
  overflow(t) {
    this.container && (t === "scroll" && this.settings.axis === "vertical" ? (this.container.style["overflow-y"] = t, this.container.style["overflow-x"] = "hidden") : t === "scroll" && this.settings.axis === "horizontal" ? (this.container.style["overflow-y"] = "hidden", this.container.style["overflow-x"] = t) : this.container.style.overflow = t), this.settings.overflow = t;
  }
  destroy() {
    this.element && (this.settings.hidden ? this.wrapper : this.container, this.element.contains(this.container) && this.element.removeChild(this.container), window.removeEventListener("resize", this.resizeFunc), window.removeEventListener("orientationChange", this.orientationChangeFunc));
  }
}
export {
  w as default
};
//# sourceMappingURL=stage.mjs.map
