import { defer as h, isXml as w, parse as d } from "./utils/core.mjs";
import c from "./utils/request.mjs";
import l from "./utils/mime.mjs";
import v from "./utils/path.mjs";
import m from "../../../../event-emitter@0.3.5/node_modules/event-emitter/index.mjs";
import f from "../../../../localforage@1.10.0/node_modules/localforage/dist/localforage.mjs";
class g {
  constructor(e, t, r) {
    this.urlCache = {}, this.storage = void 0, this.name = e, this.requester = t || c, this.resolver = r, this.online = !0, this.checkRequirements(), this.addListeners();
  }
  /**
   * Checks to see if localForage exists in global namspace,
   * Requires localForage if it isn't there
   * @private
   */
  checkRequirements() {
    try {
      let e;
      typeof f > "u" && (e = f), this.storage = e.createInstance({
        name: this.name
      });
    } catch {
      throw new Error("localForage lib not loaded");
    }
  }
  /**
   * Add online and offline event listeners
   * @private
   */
  addListeners() {
    this._status = this.status.bind(this), window.addEventListener("online", this._status), window.addEventListener("offline", this._status);
  }
  /**
   * Remove online and offline event listeners
   * @private
   */
  removeListeners() {
    window.removeEventListener("online", this._status), window.removeEventListener("offline", this._status), this._status = void 0;
  }
  /**
   * Update the online / offline status
   * @private
   */
  status(e) {
    let t = navigator.onLine;
    this.online = t, t ? this.emit("online", this) : this.emit("offline", this);
  }
  /**
   * Add all of a book resources to the store
   * @param  {Resources} resources  book resources
   * @param  {boolean} [force] force resaving resources
   * @return {Promise<object>} store objects
   */
  add(e, t) {
    let r = e.resources.map((s) => {
      let { href: i } = s, n = this.resolver(i), o = window.encodeURIComponent(n);
      return this.storage.getItem(o).then((a) => !a || t ? this.requester(n, "binary").then((u) => this.storage.setItem(o, u)) : a);
    });
    return Promise.all(r);
  }
  /**
   * Put binary data from a url to storage
   * @param  {string} url  a url to request from storage
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob>}
   */
  put(e, t, r) {
    let s = window.encodeURIComponent(e);
    return this.storage.getItem(s).then((i) => i || this.requester(e, "binary", t, r).then((n) => this.storage.setItem(s, n)));
  }
  /**
   * Request a url
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @param  {boolean} [withCredentials]
   * @param  {object} [headers]
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  request(e, t, r, s) {
    return this.online ? this.requester(e, t, r, s).then((i) => (this.put(e), i)) : this.retrieve(e, t);
  }
  /**
   * Request a url from storage
   * @param  {string} url  a url to request from storage
   * @param  {string} [type] specify the type of the returned result
   * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
   */
  retrieve(e, t) {
    new h();
    var r, s = new v(e);
    return t || (t = s.extension), t == "blob" ? r = this.getBlob(e) : r = this.getText(e), r.then((i) => {
      var n = new h(), o;
      return i ? (o = this.handleResponse(i, t), n.resolve(o)) : n.reject({
        message: "File not found in storage: " + e,
        stack: new Error().stack
      }), n.promise;
    });
  }
  /**
   * Handle the response from request
   * @private
   * @param  {any} response
   * @param  {string} [type]
   * @return {any} the parsed result
   */
  handleResponse(e, t) {
    var r;
    return t == "json" ? r = JSON.parse(e) : w(t) ? r = d(e, "text/xml") : t == "xhtml" ? r = d(e, "application/xhtml+xml") : t == "html" || t == "htm" ? r = d(e, "text/html") : r = e, r;
  }
  /**
   * Get a Blob from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {Blob}
   */
  getBlob(e, t) {
    let r = window.encodeURIComponent(e);
    return this.storage.getItem(r).then(function(s) {
      if (s)
        return t = t || l.lookup(e), new Blob([s], { type: t });
    });
  }
  /**
   * Get Text from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string}
   */
  getText(e, t) {
    let r = window.encodeURIComponent(e);
    return t = t || l.lookup(e), this.storage.getItem(r).then(function(s) {
      var i = new h(), n = new FileReader(), o;
      if (s)
        return o = new Blob([s], { type: t }), n.addEventListener("loadend", () => {
          i.resolve(n.result);
        }), n.readAsText(o, t), i.promise;
    });
  }
  /**
   * Get a base64 encoded result from Storage by Url
   * @param  {string} url
   * @param  {string} [mimeType]
   * @return {string} base64 encoded
   */
  getBase64(e, t) {
    let r = window.encodeURIComponent(e);
    return t = t || l.lookup(e), this.storage.getItem(r).then((s) => {
      var i = new h(), n = new FileReader(), o;
      if (s)
        return o = new Blob([s], { type: t }), n.addEventListener("loadend", () => {
          i.resolve(n.result);
        }), n.readAsDataURL(o, t), i.promise;
    });
  }
  /**
   * Create a Url from a stored item
   * @param  {string} url
   * @param  {object} [options.base64] use base64 encoding or blob url
   * @return {Promise} url promise with Url string
   */
  createUrl(e, t) {
    var r = new h(), s = window.URL || window.webkitURL || window.mozURL, i, n, o = t && t.base64;
    return e in this.urlCache ? (r.resolve(this.urlCache[e]), r.promise) : (o ? (n = this.getBase64(e), n && n.then((function(a) {
      this.urlCache[e] = a, r.resolve(a);
    }).bind(this))) : (n = this.getBlob(e), n && n.then((function(a) {
      i = s.createObjectURL(a), this.urlCache[e] = i, r.resolve(i);
    }).bind(this))), n || r.reject({
      message: "File not found in storage: " + e,
      stack: new Error().stack
    }), r.promise);
  }
  /**
   * Revoke Temp Url for a archive item
   * @param  {string} url url of the item in the store
   */
  revokeUrl(e) {
    var t = window.URL || window.webkitURL || window.mozURL, r = this.urlCache[e];
    r && t.revokeObjectURL(r);
  }
  destroy() {
    var e = window.URL || window.webkitURL || window.mozURL;
    for (let t in this.urlCache)
      e.revokeObjectURL(t);
    this.urlCache = {}, this.removeListeners();
  }
}
m(g.prototype);
export {
  g as default
};
//# sourceMappingURL=store.mjs.map
