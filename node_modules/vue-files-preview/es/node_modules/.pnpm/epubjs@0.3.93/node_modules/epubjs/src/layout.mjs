import { extend as n } from "./utils/core.mjs";
import { EVENTS as u } from "./utils/constants.mjs";
import c from "../../../../event-emitter@0.3.5/node_modules/event-emitter/index.mjs";
class m {
  constructor(i) {
    this.settings = i, this.name = i.layout || "reflowable", this._spread = i.spread !== "none", this._minSpreadWidth = i.minSpreadWidth || 800, this._evenSpreads = i.evenSpreads || !1, i.flow === "scrolled" || i.flow === "scrolled-continuous" || i.flow === "scrolled-doc" ? this._flow = "scrolled" : this._flow = "paginated", this.width = 0, this.height = 0, this.spreadWidth = 0, this.delta = 0, this.columnWidth = 0, this.gap = 0, this.divisor = 1, this.props = {
      name: this.name,
      spread: this._spread,
      flow: this._flow,
      width: 0,
      height: 0,
      spreadWidth: 0,
      delta: 0,
      columnWidth: 0,
      gap: 0,
      divisor: 1
    };
  }
  /**
   * Switch the flow between paginated and scrolled
   * @param  {string} flow paginated | scrolled
   * @return {string} simplified flow
   */
  flow(i) {
    return typeof i < "u" && (i === "scrolled" || i === "scrolled-continuous" || i === "scrolled-doc" ? this._flow = "scrolled" : this._flow = "paginated", this.update({ flow: this._flow })), this._flow;
  }
  /**
   * Switch between using spreads or not, and set the
   * width at which they switch to single.
   * @param  {string} spread "none" | "always" | "auto"
   * @param  {number} min integer in pixels
   * @return {boolean} spread true | false
   */
  spread(i, t) {
    return i && (this._spread = i !== "none", this.update({ spread: this._spread })), t >= 0 && (this._minSpreadWidth = t), this._spread;
  }
  /**
   * Calculate the dimensions of the pagination
   * @param  {number} _width  width of the rendering
   * @param  {number} _height height of the rendering
   * @param  {number} _gap    width of the gap between columns
   */
  calculate(i, t, s) {
    var e = 1, a = s || 0, h = i, p = t, r = Math.floor(h / 12), d, o, l, f;
    this._spread && h >= this._minSpreadWidth ? e = 2 : e = 1, this.name === "reflowable" && this._flow === "paginated" && !(s >= 0) && (a = r % 2 === 0 ? r : r - 1), this.name === "pre-paginated" && (a = 0), e > 1 ? (d = h / e - a, l = d + a) : (d = h, l = h), this.name === "pre-paginated" && e > 1 && (h = d), o = d * e + a, f = h, this.width = h, this.height = p, this.spreadWidth = o, this.pageWidth = l, this.delta = f, this.columnWidth = d, this.gap = a, this.divisor = e, this.update({
      width: h,
      height: p,
      spreadWidth: o,
      pageWidth: l,
      delta: f,
      columnWidth: d,
      gap: a,
      divisor: e
    });
  }
  /**
   * Apply Css to a Document
   * @param  {Contents} contents
   * @return {Promise}
   */
  format(i, t, s) {
    var e;
    return this.name === "pre-paginated" ? e = i.fit(this.columnWidth, this.height, t) : this._flow === "paginated" ? e = i.columns(this.width, this.height, this.columnWidth, this.gap, this.settings.direction) : s && s === "horizontal" ? e = i.size(null, this.height) : e = i.size(this.width, null), e;
  }
  /**
   * Count number of pages
   * @param  {number} totalLength
   * @param  {number} pageLength
   * @return {{spreads: Number, pages: Number}}
   */
  count(i, t) {
    let s, e;
    return this.name === "pre-paginated" ? (s = 1, e = 1) : this._flow === "paginated" ? (t = t || this.delta, s = Math.ceil(i / t), e = s * this.divisor) : (t = t || this.height, s = Math.ceil(i / t), e = s), {
      spreads: s,
      pages: e
    };
  }
  /**
   * Update props that have changed
   * @private
   * @param  {object} props
   */
  update(i) {
    if (Object.keys(i).forEach((t) => {
      this.props[t] === i[t] && delete i[t];
    }), Object.keys(i).length > 0) {
      let t = n(this.props, i);
      this.emit(u.LAYOUT.UPDATED, t, i);
    }
  }
}
c(m.prototype);
export {
  m as default
};
//# sourceMappingURL=layout.mjs.map
