import { commonjsGlobal as Xe, getDefaultExportFromCjs as qe } from "../../../../../../_virtual/_commonjsHelpers.mjs";
import { commonjsRequire as Ve } from "../../../../../../_virtual/_commonjs-dynamic-modules.mjs";
import { __module as Qe } from "../../../../../../_virtual/jszip.mjs";
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function($e, tt) {
  (function(v) {
    $e.exports = v();
  })(function() {
    return function v(N, y, d) {
      function f(w, l) {
        if (!y[w]) {
          if (!N[w]) {
            var h = typeof Ve == "function" && Ve;
            if (!l && h) return h(w, !0);
            if (p) return p(w, !0);
            var x = new Error("Cannot find module '" + w + "'");
            throw x.code = "MODULE_NOT_FOUND", x;
          }
          var u = y[w] = { exports: {} };
          N[w][0].call(u.exports, function(z) {
            var A = N[w][1][z];
            return f(A || z);
          }, u, u.exports, v, N, y, d);
        }
        return y[w].exports;
      }
      for (var p = typeof Ve == "function" && Ve, o = 0; o < d.length; o++) f(d[o]);
      return f;
    }({ 1: [function(v, N, y) {
      var d = v("./utils"), f = v("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      y.encode = function(o) {
        for (var w = [], l, h, x, u, z, A, r, n = 0, s = o.length, b = s, O = d.getTypeOf(o) !== "string"; n < o.length; )
          b = s - n, O ? (l = o[n++], h = n < s ? o[n++] : 0, x = n < s ? o[n++] : 0) : (l = o.charCodeAt(n++), h = n < s ? o.charCodeAt(n++) : 0, x = n < s ? o.charCodeAt(n++) : 0), u = l >> 2, z = (l & 3) << 4 | h >> 4, A = b > 1 ? (h & 15) << 2 | x >> 6 : 64, r = b > 2 ? x & 63 : 64, w.push(p.charAt(u) + p.charAt(z) + p.charAt(A) + p.charAt(r));
        return w.join("");
      }, y.decode = function(o) {
        var w, l, h, x, u, z, A, r = 0, n = 0, s = "data:";
        if (o.substr(0, s.length) === s)
          throw new Error("Invalid base64 input, it looks like a data url.");
        o = o.replace(/[^A-Za-z0-9+/=]/g, "");
        var b = o.length * 3 / 4;
        if (o.charAt(o.length - 1) === p.charAt(64) && b--, o.charAt(o.length - 2) === p.charAt(64) && b--, b % 1 !== 0)
          throw new Error("Invalid base64 input, bad content length.");
        var O;
        for (f.uint8array ? O = new Uint8Array(b | 0) : O = new Array(b | 0); r < o.length; )
          x = p.indexOf(o.charAt(r++)), u = p.indexOf(o.charAt(r++)), z = p.indexOf(o.charAt(r++)), A = p.indexOf(o.charAt(r++)), w = x << 2 | u >> 4, l = (u & 15) << 4 | z >> 2, h = (z & 3) << 6 | A, O[n++] = w, z !== 64 && (O[n++] = l), A !== 64 && (O[n++] = h);
        return O;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(v, N, y) {
      var d = v("./external"), f = v("./stream/DataWorker"), p = v("./stream/Crc32Probe"), o = v("./stream/DataLengthProbe");
      function w(l, h, x, u, z) {
        this.compressedSize = l, this.uncompressedSize = h, this.crc32 = x, this.compression = u, this.compressedContent = z;
      }
      w.prototype = {
        /**
         * Create a worker to get the uncompressed content.
         * @return {GenericWorker} the worker.
         */
        getContentWorker: function() {
          var l = new f(d.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new o("data_length")), h = this;
          return l.on("end", function() {
            if (this.streamInfo.data_length !== h.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), l;
        },
        /**
         * Create a worker to get the compressed content.
         * @return {GenericWorker} the worker.
         */
        getCompressedWorker: function() {
          return new f(d.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        }
      }, w.createWorkerFrom = function(l, h, x) {
        return l.pipe(new p()).pipe(new o("uncompressedSize")).pipe(h.compressWorker(x)).pipe(new o("compressedSize")).withStreamInfo("compression", h);
      }, N.exports = w;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(v, N, y) {
      var d = v("./stream/GenericWorker");
      y.STORE = {
        magic: "\0\0",
        compressWorker: function() {
          return new d("STORE compression");
        },
        uncompressWorker: function() {
          return new d("STORE decompression");
        }
      }, y.DEFLATE = v("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(v, N, y) {
      var d = v("./utils");
      function f() {
        for (var l, h = [], x = 0; x < 256; x++) {
          l = x;
          for (var u = 0; u < 8; u++)
            l = l & 1 ? 3988292384 ^ l >>> 1 : l >>> 1;
          h[x] = l;
        }
        return h;
      }
      var p = f();
      function o(l, h, x, u) {
        var z = p, A = u + x;
        l = l ^ -1;
        for (var r = u; r < A; r++)
          l = l >>> 8 ^ z[(l ^ h[r]) & 255];
        return l ^ -1;
      }
      function w(l, h, x, u) {
        var z = p, A = u + x;
        l = l ^ -1;
        for (var r = u; r < A; r++)
          l = l >>> 8 ^ z[(l ^ h.charCodeAt(r)) & 255];
        return l ^ -1;
      }
      N.exports = function(h, x) {
        if (typeof h > "u" || !h.length)
          return 0;
        var u = d.getTypeOf(h) !== "string";
        return u ? o(x | 0, h, h.length, 0) : w(x | 0, h, h.length, 0);
      };
    }, { "./utils": 32 }], 5: [function(v, N, y) {
      y.base64 = !1, y.binary = !1, y.dir = !1, y.createFolders = !0, y.date = null, y.compression = null, y.compressionOptions = null, y.comment = null, y.unixPermissions = null, y.dosPermissions = null;
    }, {}], 6: [function(v, N, y) {
      var d = null;
      typeof Promise < "u" ? d = Promise : d = v("lie"), N.exports = {
        Promise: d
      };
    }, { lie: 37 }], 7: [function(v, N, y) {
      var d = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", f = v("pako"), p = v("./utils"), o = v("./stream/GenericWorker"), w = d ? "uint8array" : "array";
      y.magic = "\b\0";
      function l(h, x) {
        o.call(this, "FlateWorker/" + h), this._pako = null, this._pakoAction = h, this._pakoOptions = x, this.meta = {};
      }
      p.inherits(l, o), l.prototype.processChunk = function(h) {
        this.meta = h.meta, this._pako === null && this._createPako(), this._pako.push(p.transformTo(w, h.data), !1);
      }, l.prototype.flush = function() {
        o.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, l.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this._pako = null;
      }, l.prototype._createPako = function() {
        this._pako = new f[this._pakoAction]({
          raw: !0,
          level: this._pakoOptions.level || -1
          // default compression
        });
        var h = this;
        this._pako.onData = function(x) {
          h.push({
            data: x,
            meta: h.meta
          });
        };
      }, y.compressWorker = function(h) {
        return new l("Deflate", h);
      }, y.uncompressWorker = function() {
        return new l("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(v, N, y) {
      var d = v("../utils"), f = v("../stream/GenericWorker"), p = v("../utf8"), o = v("../crc32"), w = v("../signature"), l = function(n, s) {
        var b = "", O;
        for (O = 0; O < s; O++)
          b += String.fromCharCode(n & 255), n = n >>> 8;
        return b;
      }, h = function(n, s) {
        var b = n;
        return n || (b = s ? 16893 : 33204), (b & 65535) << 16;
      }, x = function(n) {
        return (n || 0) & 63;
      }, u = function(n, s, b, O, c, g) {
        var k = n.file, S = n.compression, R = g !== p.utf8encode, I = d.transformTo("string", g(k.name)), P = d.transformTo("string", p.utf8encode(k.name)), L = k.comment, G = d.transformTo("string", g(L)), J = d.transformTo("string", p.utf8encode(L)), X = P.length !== k.name.length, te = J.length !== L.length, V, j, q = "", fe = "", ce = "", Y = k.dir, se = k.date, ie = {
          crc32: 0,
          compressedSize: 0,
          uncompressedSize: 0
        };
        (!s || b) && (ie.crc32 = n.crc32, ie.compressedSize = n.compressedSize, ie.uncompressedSize = n.uncompressedSize);
        var we = 0;
        s && (we |= 8), !R && (X || te) && (we |= 2048);
        var me = 0, de = 0;
        Y && (me |= 16), c === "UNIX" ? (de = 798, me |= h(k.unixPermissions, Y)) : (de = 20, me |= x(k.dosPermissions)), V = se.getUTCHours(), V = V << 6, V = V | se.getUTCMinutes(), V = V << 5, V = V | se.getUTCSeconds() / 2, j = se.getUTCFullYear() - 1980, j = j << 4, j = j | se.getUTCMonth() + 1, j = j << 5, j = j | se.getUTCDate(), X && (fe = // Version
        l(1, 1) + // NameCRC32
        l(o(I), 4) + // UnicodeName
        P, q += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        l(fe.length, 2) + // content
        fe), te && (ce = // Version
        l(1, 1) + // CommentCRC32
        l(o(G), 4) + // UnicodeName
        J, q += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        l(ce.length, 2) + // content
        ce);
        var $ = "";
        $ += `
\0`, $ += l(we, 2), $ += S.magic, $ += l(V, 2), $ += l(j, 2), $ += l(ie.crc32, 4), $ += l(ie.compressedSize, 4), $ += l(ie.uncompressedSize, 4), $ += l(I.length, 2), $ += l(q.length, 2);
        var ge = w.LOCAL_FILE_HEADER + $ + I + q, pe = w.CENTRAL_FILE_HEADER + // version made by (00: DOS)
        l(de, 2) + // file header (common to file and central directory)
        $ + // file comment length
        l(G.length, 2) + // disk number start
        "\0\0\0\0" + // external file attributes
        l(me, 4) + // relative offset of local header
        l(O, 4) + // file name
        I + // extra field
        q + // file comment
        G;
        return {
          fileRecord: ge,
          dirRecord: pe
        };
      }, z = function(n, s, b, O, c) {
        var g = "", k = d.transformTo("string", c(O));
        return g = w.CENTRAL_DIRECTORY_END + // number of this disk
        "\0\0\0\0" + // total number of entries in the central directory on this disk
        l(n, 2) + // total number of entries in the central directory
        l(n, 2) + // size of the central directory   4 bytes
        l(s, 4) + // offset of start of central directory with respect to the starting disk number
        l(b, 4) + // .ZIP file comment length
        l(k.length, 2) + // .ZIP file comment
        k, g;
      }, A = function(n) {
        var s = "";
        return s = w.DATA_DESCRIPTOR + // crc-32                          4 bytes
        l(n.crc32, 4) + // compressed size                 4 bytes
        l(n.compressedSize, 4) + // uncompressed size               4 bytes
        l(n.uncompressedSize, 4), s;
      };
      function r(n, s, b, O) {
        f.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = s, this.zipPlatform = b, this.encodeFileName = O, this.streamFiles = n, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      d.inherits(r, f), r.prototype.push = function(n) {
        var s = n.meta.percent || 0, b = this.entriesCount, O = this._sources.length;
        this.accumulate ? this.contentBuffer.push(n) : (this.bytesWritten += n.data.length, f.prototype.push.call(this, {
          data: n.data,
          meta: {
            currentFile: this.currentFile,
            percent: b ? (s + 100 * (b - O - 1)) / b : 100
          }
        }));
      }, r.prototype.openedSource = function(n) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = n.file.name;
        var s = this.streamFiles && !n.file.dir;
        if (s) {
          var b = u(n, s, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({
            data: b.fileRecord,
            meta: { percent: 0 }
          });
        } else
          this.accumulate = !0;
      }, r.prototype.closedSource = function(n) {
        this.accumulate = !1;
        var s = this.streamFiles && !n.file.dir, b = u(n, s, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(b.dirRecord), s)
          this.push({
            data: A(n),
            meta: { percent: 100 }
          });
        else
          for (this.push({
            data: b.fileRecord,
            meta: { percent: 0 }
          }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, r.prototype.flush = function() {
        for (var n = this.bytesWritten, s = 0; s < this.dirRecords.length; s++)
          this.push({
            data: this.dirRecords[s],
            meta: { percent: 100 }
          });
        var b = this.bytesWritten - n, O = z(this.dirRecords.length, b, n, this.zipComment, this.encodeFileName);
        this.push({
          data: O,
          meta: { percent: 100 }
        });
      }, r.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, r.prototype.registerPrevious = function(n) {
        this._sources.push(n);
        var s = this;
        return n.on("data", function(b) {
          s.processChunk(b);
        }), n.on("end", function() {
          s.closedSource(s.previous.streamInfo), s._sources.length ? s.prepareNextSource() : s.end();
        }), n.on("error", function(b) {
          s.error(b);
        }), this;
      }, r.prototype.resume = function() {
        if (!f.prototype.resume.call(this))
          return !1;
        if (!this.previous && this._sources.length)
          return this.prepareNextSource(), !0;
        if (!this.previous && !this._sources.length && !this.generatedError)
          return this.end(), !0;
      }, r.prototype.error = function(n) {
        var s = this._sources;
        if (!f.prototype.error.call(this, n))
          return !1;
        for (var b = 0; b < s.length; b++)
          try {
            s[b].error(n);
          } catch {
          }
        return !0;
      }, r.prototype.lock = function() {
        f.prototype.lock.call(this);
        for (var n = this._sources, s = 0; s < n.length; s++)
          n[s].lock();
      }, N.exports = r;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(v, N, y) {
      var d = v("../compressions"), f = v("./ZipFileWorker"), p = function(o, w) {
        var l = o || w, h = d[l];
        if (!h)
          throw new Error(l + " is not a valid compression method !");
        return h;
      };
      y.generateWorker = function(o, w, l) {
        var h = new f(w.streamFiles, l, w.platform, w.encodeFileName), x = 0;
        try {
          o.forEach(function(u, z) {
            x++;
            var A = p(z.options.compression, w.compression), r = z.options.compressionOptions || w.compressionOptions || {}, n = z.dir, s = z.date;
            z._compressWorker(A, r).withStreamInfo("file", {
              name: u,
              dir: n,
              date: s,
              comment: z.comment || "",
              unixPermissions: z.unixPermissions,
              dosPermissions: z.dosPermissions
            }).pipe(h);
          }), h.entriesCount = x;
        } catch (u) {
          h.error(u);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(v, N, y) {
      function d() {
        if (!(this instanceof d))
          return new d();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var f = new d();
          for (var p in this)
            typeof this[p] != "function" && (f[p] = this[p]);
          return f;
        };
      }
      d.prototype = v("./object"), d.prototype.loadAsync = v("./load"), d.support = v("./support"), d.defaults = v("./defaults"), d.version = "3.10.1", d.loadAsync = function(f, p) {
        return new d().loadAsync(f, p);
      }, d.external = v("./external"), N.exports = d;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(v, N, y) {
      var d = v("./utils"), f = v("./external"), p = v("./utf8"), o = v("./zipEntries"), w = v("./stream/Crc32Probe"), l = v("./nodejsUtils");
      function h(x) {
        return new f.Promise(function(u, z) {
          var A = x.decompressed.getContentWorker().pipe(new w());
          A.on("error", function(r) {
            z(r);
          }).on("end", function() {
            A.streamInfo.crc32 !== x.decompressed.crc32 ? z(new Error("Corrupted zip : CRC32 mismatch")) : u();
          }).resume();
        });
      }
      N.exports = function(x, u) {
        var z = this;
        return u = d.extend(u || {}, {
          base64: !1,
          checkCRC32: !1,
          optimizedBinaryString: !1,
          createFolders: !1,
          decodeFileName: p.utf8decode
        }), l.isNode && l.isStream(x) ? f.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : d.prepareContent("the loaded zip file", x, !0, u.optimizedBinaryString, u.base64).then(function(A) {
          var r = new o(u);
          return r.load(A), r;
        }).then(function(r) {
          var n = [f.Promise.resolve(r)], s = r.files;
          if (u.checkCRC32)
            for (var b = 0; b < s.length; b++)
              n.push(h(s[b]));
          return f.Promise.all(n);
        }).then(function(r) {
          for (var n = r.shift(), s = n.files, b = 0; b < s.length; b++) {
            var O = s[b], c = O.fileNameStr, g = d.resolve(O.fileNameStr);
            z.file(g, O.decompressed, {
              binary: !0,
              optimizedBinaryString: !0,
              date: O.date,
              dir: O.dir,
              comment: O.fileCommentStr.length ? O.fileCommentStr : null,
              unixPermissions: O.unixPermissions,
              dosPermissions: O.dosPermissions,
              createFolders: u.createFolders
            }), O.dir || (z.file(g).unsafeOriginalName = c);
          }
          return n.zipComment.length && (z.comment = n.zipComment), z;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(v, N, y) {
      var d = v("../utils"), f = v("../stream/GenericWorker");
      function p(o, w) {
        f.call(this, "Nodejs stream input adapter for " + o), this._upstreamEnded = !1, this._bindStream(w);
      }
      d.inherits(p, f), p.prototype._bindStream = function(o) {
        var w = this;
        this._stream = o, o.pause(), o.on("data", function(l) {
          w.push({
            data: l,
            meta: {
              percent: 0
            }
          });
        }).on("error", function(l) {
          w.isPaused ? this.generatedError = l : w.error(l);
        }).on("end", function() {
          w.isPaused ? w._upstreamEnded = !0 : w.end();
        });
      }, p.prototype.pause = function() {
        return f.prototype.pause.call(this) ? (this._stream.pause(), !0) : !1;
      }, p.prototype.resume = function() {
        return f.prototype.resume.call(this) ? (this._upstreamEnded ? this.end() : this._stream.resume(), !0) : !1;
      }, N.exports = p;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(v, N, y) {
      var d = v("readable-stream").Readable, f = v("../utils");
      f.inherits(p, d);
      function p(o, w, l) {
        d.call(this, w), this._helper = o;
        var h = this;
        o.on("data", function(x, u) {
          h.push(x) || h._helper.pause(), l && l(u);
        }).on("error", function(x) {
          h.emit("error", x);
        }).on("end", function() {
          h.push(null);
        });
      }
      p.prototype._read = function() {
        this._helper.resume();
      }, N.exports = p;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(v, N, y) {
      N.exports = {
        /**
         * True if this is running in Nodejs, will be undefined in a browser.
         * In a browser, browserify won't include this file and the whole module
         * will be resolved an empty object.
         */
        isNode: typeof Buffer < "u",
        /**
         * Create a new nodejs Buffer from an existing content.
         * @param {Object} data the data to pass to the constructor.
         * @param {String} encoding the encoding to use.
         * @return {Buffer} a new Buffer.
         */
        newBufferFrom: function(d, f) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(d, f);
          if (typeof d == "number")
            throw new Error('The "data" argument must not be a number');
          return new Buffer(d, f);
        },
        /**
         * Create a new nodejs Buffer with the specified size.
         * @param {Integer} size the size of the buffer.
         * @return {Buffer} a new Buffer.
         */
        allocBuffer: function(d) {
          if (Buffer.alloc)
            return Buffer.alloc(d);
          var f = new Buffer(d);
          return f.fill(0), f;
        },
        /**
         * Find out if an object is a Buffer.
         * @param {Object} b the object to test.
         * @return {Boolean} true if the object is a Buffer, false otherwise.
         */
        isBuffer: function(d) {
          return Buffer.isBuffer(d);
        },
        isStream: function(d) {
          return d && typeof d.on == "function" && typeof d.pause == "function" && typeof d.resume == "function";
        }
      };
    }, {}], 15: [function(v, N, y) {
      var d = v("./utf8"), f = v("./utils"), p = v("./stream/GenericWorker"), o = v("./stream/StreamHelper"), w = v("./defaults"), l = v("./compressedObject"), h = v("./zipObject"), x = v("./generate"), u = v("./nodejsUtils"), z = v("./nodejs/NodejsStreamInputAdapter"), A = function(c, g, k) {
        var S = f.getTypeOf(g), R, I = f.extend(k || {}, w);
        I.date = I.date || /* @__PURE__ */ new Date(), I.compression !== null && (I.compression = I.compression.toUpperCase()), typeof I.unixPermissions == "string" && (I.unixPermissions = parseInt(I.unixPermissions, 8)), I.unixPermissions && I.unixPermissions & 16384 && (I.dir = !0), I.dosPermissions && I.dosPermissions & 16 && (I.dir = !0), I.dir && (c = n(c)), I.createFolders && (R = r(c)) && s.call(this, R, !0);
        var P = S === "string" && I.binary === !1 && I.base64 === !1;
        (!k || typeof k.binary > "u") && (I.binary = !P);
        var L = g instanceof l && g.uncompressedSize === 0;
        (L || I.dir || !g || g.length === 0) && (I.base64 = !1, I.binary = !0, g = "", I.compression = "STORE", S = "string");
        var G = null;
        g instanceof l || g instanceof p ? G = g : u.isNode && u.isStream(g) ? G = new z(c, g) : G = f.prepareContent(c, g, I.binary, I.optimizedBinaryString, I.base64);
        var J = new h(c, G, I);
        this.files[c] = J;
      }, r = function(c) {
        c.slice(-1) === "/" && (c = c.substring(0, c.length - 1));
        var g = c.lastIndexOf("/");
        return g > 0 ? c.substring(0, g) : "";
      }, n = function(c) {
        return c.slice(-1) !== "/" && (c += "/"), c;
      }, s = function(c, g) {
        return g = typeof g < "u" ? g : w.createFolders, c = n(c), this.files[c] || A.call(this, c, null, {
          dir: !0,
          createFolders: g
        }), this.files[c];
      };
      function b(c) {
        return Object.prototype.toString.call(c) === "[object RegExp]";
      }
      var O = {
        /**
         * @see loadAsync
         */
        load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Call a callback function for each entry at this folder level.
         * @param {Function} cb the callback function:
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         */
        forEach: function(c) {
          var g, k, S;
          for (g in this.files)
            S = this.files[g], k = g.slice(this.root.length, g.length), k && g.slice(0, this.root.length) === this.root && c(k, S);
        },
        /**
         * Filter nested files/folders with the specified function.
         * @param {Function} search the predicate to use :
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         * @return {Array} An array of matching elements.
         */
        filter: function(c) {
          var g = [];
          return this.forEach(function(k, S) {
            c(k, S) && g.push(S);
          }), g;
        },
        /**
         * Add a file to the zip file, or search a file.
         * @param   {string|RegExp} name The name of the file to add (if data is defined),
         * the name of the file to find (if no data) or a regex to match files.
         * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
         * @param   {Object} o     File options
         * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
         * a file (when searching by string) or an array of files (when searching by regex).
         */
        file: function(c, g, k) {
          if (arguments.length === 1)
            if (b(c)) {
              var S = c;
              return this.filter(function(I, P) {
                return !P.dir && S.test(I);
              });
            } else {
              var R = this.files[this.root + c];
              return R && !R.dir ? R : null;
            }
          else
            c = this.root + c, A.call(this, c, g, k);
          return this;
        },
        /**
         * Add a directory to the zip file, or search.
         * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
         * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
         */
        folder: function(c) {
          if (!c)
            return this;
          if (b(c))
            return this.filter(function(R, I) {
              return I.dir && c.test(R);
            });
          var g = this.root + c, k = s.call(this, g), S = this.clone();
          return S.root = k.name, S;
        },
        /**
         * Delete a file, or a directory and all sub-files, from the zip
         * @param {string} name the name of the file to delete
         * @return {JSZip} this JSZip object
         */
        remove: function(c) {
          c = this.root + c;
          var g = this.files[c];
          if (g || (c.slice(-1) !== "/" && (c += "/"), g = this.files[c]), g && !g.dir)
            delete this.files[c];
          else
            for (var k = this.filter(function(R, I) {
              return I.name.slice(0, c.length) === c;
            }), S = 0; S < k.length; S++)
              delete this.files[k[S].name];
          return this;
        },
        /**
         * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
         */
        generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Generate the complete zip file as an internal stream.
         * @param {Object} options the options to generate the zip file :
         * - compression, "STORE" by default.
         * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
         * @return {StreamHelper} the streamed zip file.
         */
        generateInternalStream: function(c) {
          var g, k = {};
          try {
            if (k = f.extend(c || {}, {
              streamFiles: !1,
              compression: "STORE",
              compressionOptions: null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: "application/zip",
              encodeFileName: d.utf8encode
            }), k.type = k.type.toLowerCase(), k.compression = k.compression.toUpperCase(), k.type === "binarystring" && (k.type = "string"), !k.type)
              throw new Error("No output type specified.");
            f.checkSupport(k.type), (k.platform === "darwin" || k.platform === "freebsd" || k.platform === "linux" || k.platform === "sunos") && (k.platform = "UNIX"), k.platform === "win32" && (k.platform = "DOS");
            var S = k.comment || this.comment || "";
            g = x.generateWorker(this, k, S);
          } catch (R) {
            g = new p("error"), g.error(R);
          }
          return new o(g, k.type || "string", k.mimeType);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateAsync: function(c, g) {
          return this.generateInternalStream(c).accumulate(g);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateNodeStream: function(c, g) {
          return c = c || {}, c.type || (c.type = "nodebuffer"), this.generateInternalStream(c).toNodejsStream(g);
        }
      };
      N.exports = O;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(v, N, y) {
      N.exports = v("stream");
    }, { stream: void 0 }], 17: [function(v, N, y) {
      var d = v("./DataReader"), f = v("../utils");
      function p(o) {
        d.call(this, o);
        for (var w = 0; w < this.data.length; w++)
          o[w] = o[w] & 255;
      }
      f.inherits(p, d), p.prototype.byteAt = function(o) {
        return this.data[this.zero + o];
      }, p.prototype.lastIndexOfSignature = function(o) {
        for (var w = o.charCodeAt(0), l = o.charCodeAt(1), h = o.charCodeAt(2), x = o.charCodeAt(3), u = this.length - 4; u >= 0; --u)
          if (this.data[u] === w && this.data[u + 1] === l && this.data[u + 2] === h && this.data[u + 3] === x)
            return u - this.zero;
        return -1;
      }, p.prototype.readAndCheckSignature = function(o) {
        var w = o.charCodeAt(0), l = o.charCodeAt(1), h = o.charCodeAt(2), x = o.charCodeAt(3), u = this.readData(4);
        return w === u[0] && l === u[1] && h === u[2] && x === u[3];
      }, p.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return [];
        var w = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, w;
      }, N.exports = p;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(v, N, y) {
      var d = v("../utils");
      function f(p) {
        this.data = p, this.length = p.length, this.index = 0, this.zero = 0;
      }
      f.prototype = {
        /**
         * Check that the offset will not go too far.
         * @param {string} offset the additional offset to check.
         * @throws {Error} an Error if the offset is out of bounds.
         */
        checkOffset: function(p) {
          this.checkIndex(this.index + p);
        },
        /**
         * Check that the specified index will not be too far.
         * @param {string} newIndex the index to check.
         * @throws {Error} an Error if the index is out of bounds.
         */
        checkIndex: function(p) {
          if (this.length < this.zero + p || p < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + p + "). Corrupted zip ?");
        },
        /**
         * Change the index.
         * @param {number} newIndex The new index.
         * @throws {Error} if the new index is out of the data.
         */
        setIndex: function(p) {
          this.checkIndex(p), this.index = p;
        },
        /**
         * Skip the next n bytes.
         * @param {number} n the number of bytes to skip.
         * @throws {Error} if the new index is out of the data.
         */
        skip: function(p) {
          this.setIndex(this.index + p);
        },
        /**
         * Get the byte at the specified index.
         * @param {number} i the index to use.
         * @return {number} a byte.
         */
        byteAt: function() {
        },
        /**
         * Get the next number with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {number} the corresponding number.
         */
        readInt: function(p) {
          var o = 0, w;
          for (this.checkOffset(p), w = this.index + p - 1; w >= this.index; w--)
            o = (o << 8) + this.byteAt(w);
          return this.index += p, o;
        },
        /**
         * Get the next string with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {string} the corresponding string.
         */
        readString: function(p) {
          return d.transformTo("string", this.readData(p));
        },
        /**
         * Get raw data without conversion, <size> bytes.
         * @param {number} size the number of bytes to read.
         * @return {Object} the raw data, implementation specific.
         */
        readData: function() {
        },
        /**
         * Find the last occurrence of a zip signature (4 bytes).
         * @param {string} sig the signature to find.
         * @return {number} the index of the last occurrence, -1 if not found.
         */
        lastIndexOfSignature: function() {
        },
        /**
         * Read the signature (4 bytes) at the current position and compare it with sig.
         * @param {string} sig the expected signature
         * @return {boolean} true if the signature matches, false otherwise.
         */
        readAndCheckSignature: function() {
        },
        /**
         * Get the next date.
         * @return {Date} the date.
         */
        readDate: function() {
          var p = this.readInt(4);
          return new Date(Date.UTC(
            (p >> 25 & 127) + 1980,
            // year
            (p >> 21 & 15) - 1,
            // month
            p >> 16 & 31,
            // day
            p >> 11 & 31,
            // hour
            p >> 5 & 63,
            // minute
            (p & 31) << 1
          ));
        }
      }, N.exports = f;
    }, { "../utils": 32 }], 19: [function(v, N, y) {
      var d = v("./Uint8ArrayReader"), f = v("../utils");
      function p(o) {
        d.call(this, o);
      }
      f.inherits(p, d), p.prototype.readData = function(o) {
        this.checkOffset(o);
        var w = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, w;
      }, N.exports = p;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(v, N, y) {
      var d = v("./DataReader"), f = v("../utils");
      function p(o) {
        d.call(this, o);
      }
      f.inherits(p, d), p.prototype.byteAt = function(o) {
        return this.data.charCodeAt(this.zero + o);
      }, p.prototype.lastIndexOfSignature = function(o) {
        return this.data.lastIndexOf(o) - this.zero;
      }, p.prototype.readAndCheckSignature = function(o) {
        var w = this.readData(4);
        return o === w;
      }, p.prototype.readData = function(o) {
        this.checkOffset(o);
        var w = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, w;
      }, N.exports = p;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(v, N, y) {
      var d = v("./ArrayReader"), f = v("../utils");
      function p(o) {
        d.call(this, o);
      }
      f.inherits(p, d), p.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return new Uint8Array(0);
        var w = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, w;
      }, N.exports = p;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(v, N, y) {
      var d = v("../utils"), f = v("../support"), p = v("./ArrayReader"), o = v("./StringReader"), w = v("./NodeBufferReader"), l = v("./Uint8ArrayReader");
      N.exports = function(h) {
        var x = d.getTypeOf(h);
        return d.checkSupport(x), x === "string" && !f.uint8array ? new o(h) : x === "nodebuffer" ? new w(h) : f.uint8array ? new l(d.transformTo("uint8array", h)) : new p(d.transformTo("array", h));
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(v, N, y) {
      y.LOCAL_FILE_HEADER = "PK", y.CENTRAL_FILE_HEADER = "PK", y.CENTRAL_DIRECTORY_END = "PK", y.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", y.ZIP64_CENTRAL_DIRECTORY_END = "PK", y.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(v, N, y) {
      var d = v("./GenericWorker"), f = v("../utils");
      function p(o) {
        d.call(this, "ConvertWorker to " + o), this.destType = o;
      }
      f.inherits(p, d), p.prototype.processChunk = function(o) {
        this.push({
          data: f.transformTo(this.destType, o.data),
          meta: o.meta
        });
      }, N.exports = p;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(v, N, y) {
      var d = v("./GenericWorker"), f = v("../crc32"), p = v("../utils");
      function o() {
        d.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      p.inherits(o, d), o.prototype.processChunk = function(w) {
        this.streamInfo.crc32 = f(w.data, this.streamInfo.crc32 || 0), this.push(w);
      }, N.exports = o;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(v, N, y) {
      var d = v("../utils"), f = v("./GenericWorker");
      function p(o) {
        f.call(this, "DataLengthProbe for " + o), this.propName = o, this.withStreamInfo(o, 0);
      }
      d.inherits(p, f), p.prototype.processChunk = function(o) {
        if (o) {
          var w = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = w + o.data.length;
        }
        f.prototype.processChunk.call(this, o);
      }, N.exports = p;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(v, N, y) {
      var d = v("../utils"), f = v("./GenericWorker"), p = 16 * 1024;
      function o(w) {
        f.call(this, "DataWorker");
        var l = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, w.then(function(h) {
          l.dataIsReady = !0, l.data = h, l.max = h && h.length || 0, l.type = d.getTypeOf(h), l.isPaused || l._tickAndRepeat();
        }, function(h) {
          l.error(h);
        });
      }
      d.inherits(o, f), o.prototype.cleanUp = function() {
        f.prototype.cleanUp.call(this), this.data = null;
      }, o.prototype.resume = function() {
        return f.prototype.resume.call(this) ? (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, d.delay(this._tickAndRepeat, [], this)), !0) : !1;
      }, o.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, !(this.isPaused || this.isFinished) && (this._tick(), this.isFinished || (d.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, o.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var w = p, l = null, h = Math.min(this.max, this.index + w);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, h);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, h);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, h);
            break;
        }
        return this.index = h, this.push({
          data: l,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }, N.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(v, N, y) {
      function d(f) {
        this.name = f || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
          data: [],
          end: [],
          error: []
        }, this.previous = null;
      }
      d.prototype = {
        /**
         * Push a chunk to the next workers.
         * @param {Object} chunk the chunk to push
         */
        push: function(f) {
          this.emit("data", f);
        },
        /**
         * End the stream.
         * @return {Boolean} true if this call ended the worker, false otherwise.
         */
        end: function() {
          if (this.isFinished)
            return !1;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = !0;
          } catch (f) {
            this.emit("error", f);
          }
          return !0;
        },
        /**
         * End the stream with an error.
         * @param {Error} e the error which caused the premature end.
         * @return {Boolean} true if this call ended the worker with an error, false otherwise.
         */
        error: function(f) {
          return this.isFinished ? !1 : (this.isPaused ? this.generatedError = f : (this.isFinished = !0, this.emit("error", f), this.previous && this.previous.error(f), this.cleanUp()), !0);
        },
        /**
         * Add a callback on an event.
         * @param {String} name the name of the event (data, end, error)
         * @param {Function} listener the function to call when the event is triggered
         * @return {GenericWorker} the current object for chainability
         */
        on: function(f, p) {
          return this._listeners[f].push(p), this;
        },
        /**
         * Clean any references when a worker is ending.
         */
        cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        },
        /**
         * Trigger an event. This will call registered callback with the provided arg.
         * @param {String} name the name of the event (data, end, error)
         * @param {Object} arg the argument to call the callback with.
         */
        emit: function(f, p) {
          if (this._listeners[f])
            for (var o = 0; o < this._listeners[f].length; o++)
              this._listeners[f][o].call(this, p);
        },
        /**
         * Chain a worker with an other.
         * @param {Worker} next the worker receiving events from the current one.
         * @return {worker} the next worker for chainability
         */
        pipe: function(f) {
          return f.registerPrevious(this);
        },
        /**
         * Same as `pipe` in the other direction.
         * Using an API with `pipe(next)` is very easy.
         * Implementing the API with the point of view of the next one registering
         * a source is easier, see the ZipFileWorker.
         * @param {Worker} previous the previous worker, sending events to this one
         * @return {Worker} the current worker for chainability
         */
        registerPrevious: function(f) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = f.streamInfo, this.mergeStreamInfo(), this.previous = f;
          var p = this;
          return f.on("data", function(o) {
            p.processChunk(o);
          }), f.on("end", function() {
            p.end();
          }), f.on("error", function(o) {
            p.error(o);
          }), this;
        },
        /**
         * Pause the stream so it doesn't send events anymore.
         * @return {Boolean} true if this call paused the worker, false otherwise.
         */
        pause: function() {
          return this.isPaused || this.isFinished ? !1 : (this.isPaused = !0, this.previous && this.previous.pause(), !0);
        },
        /**
         * Resume a paused stream.
         * @return {Boolean} true if this call resumed the worker, false otherwise.
         */
        resume: function() {
          if (!this.isPaused || this.isFinished)
            return !1;
          this.isPaused = !1;
          var f = !1;
          return this.generatedError && (this.error(this.generatedError), f = !0), this.previous && this.previous.resume(), !f;
        },
        /**
         * Flush any remaining bytes as the stream is ending.
         */
        flush: function() {
        },
        /**
         * Process a chunk. This is usually the method overridden.
         * @param {Object} chunk the chunk to process.
         */
        processChunk: function(f) {
          this.push(f);
        },
        /**
         * Add a key/value to be added in the workers chain streamInfo once activated.
         * @param {String} key the key to use
         * @param {Object} value the associated value
         * @return {Worker} the current worker for chainability
         */
        withStreamInfo: function(f, p) {
          return this.extraStreamInfo[f] = p, this.mergeStreamInfo(), this;
        },
        /**
         * Merge this worker's streamInfo into the chain's streamInfo.
         */
        mergeStreamInfo: function() {
          for (var f in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, f) && (this.streamInfo[f] = this.extraStreamInfo[f]);
        },
        /**
         * Lock the stream to prevent further updates on the workers chain.
         * After calling this method, all calls to pipe will fail.
         */
        lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = !0, this.previous && this.previous.lock();
        },
        /**
         *
         * Pretty print the workers chain.
         */
        toString: function() {
          var f = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + f : f;
        }
      }, N.exports = d;
    }, {}], 29: [function(v, N, y) {
      var d = v("../utils"), f = v("./ConvertWorker"), p = v("./GenericWorker"), o = v("../base64"), w = v("../support"), l = v("../external"), h = null;
      if (w.nodestream)
        try {
          h = v("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function x(r, n, s) {
        switch (r) {
          case "blob":
            return d.newBlob(d.transformTo("arraybuffer", n), s);
          case "base64":
            return o.encode(n);
          default:
            return d.transformTo(r, n);
        }
      }
      function u(r, n) {
        var s, b = 0, O = null, c = 0;
        for (s = 0; s < n.length; s++)
          c += n[s].length;
        switch (r) {
          case "string":
            return n.join("");
          case "array":
            return Array.prototype.concat.apply([], n);
          case "uint8array":
            for (O = new Uint8Array(c), s = 0; s < n.length; s++)
              O.set(n[s], b), b += n[s].length;
            return O;
          case "nodebuffer":
            return Buffer.concat(n);
          default:
            throw new Error("concat : unsupported type '" + r + "'");
        }
      }
      function z(r, n) {
        return new l.Promise(function(s, b) {
          var O = [], c = r._internalType, g = r._outputType, k = r._mimeType;
          r.on("data", function(S, R) {
            O.push(S), n && n(R);
          }).on("error", function(S) {
            O = [], b(S);
          }).on("end", function() {
            try {
              var S = x(g, u(c, O), k);
              s(S);
            } catch (R) {
              b(R);
            }
            O = [];
          }).resume();
        });
      }
      function A(r, n, s) {
        var b = n;
        switch (n) {
          case "blob":
          case "arraybuffer":
            b = "uint8array";
            break;
          case "base64":
            b = "string";
            break;
        }
        try {
          this._internalType = b, this._outputType = n, this._mimeType = s, d.checkSupport(b), this._worker = r.pipe(new f(b)), r.lock();
        } catch (O) {
          this._worker = new p("error"), this._worker.error(O);
        }
      }
      A.prototype = {
        /**
         * Listen a StreamHelper, accumulate its content and concatenate it into a
         * complete block.
         * @param {Function} updateCb the update callback.
         * @return Promise the promise for the accumulation.
         */
        accumulate: function(r) {
          return z(this, r);
        },
        /**
         * Add a listener on an event triggered on a stream.
         * @param {String} evt the name of the event
         * @param {Function} fn the listener
         * @return {StreamHelper} the current helper.
         */
        on: function(r, n) {
          var s = this;
          return r === "data" ? this._worker.on(r, function(b) {
            n.call(s, b.data, b.meta);
          }) : this._worker.on(r, function() {
            d.delay(n, arguments, s);
          }), this;
        },
        /**
         * Resume the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        resume: function() {
          return d.delay(this._worker.resume, [], this._worker), this;
        },
        /**
         * Pause the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        pause: function() {
          return this._worker.pause(), this;
        },
        /**
         * Return a nodejs stream for this helper.
         * @param {Function} updateCb the update callback.
         * @return {NodejsStreamOutputAdapter} the nodejs stream.
         */
        toNodejsStream: function(r) {
          if (d.checkSupport("nodestream"), this._outputType !== "nodebuffer")
            throw new Error(this._outputType + " is not supported by this method");
          return new h(this, {
            objectMode: this._outputType !== "nodebuffer"
          }, r);
        }
      }, N.exports = A;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(v, N, y) {
      if (y.base64 = !0, y.array = !0, y.string = !0, y.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", y.nodebuffer = typeof Buffer < "u", y.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        y.blob = !1;
      else {
        var d = new ArrayBuffer(0);
        try {
          y.blob = new Blob([d], {
            type: "application/zip"
          }).size === 0;
        } catch {
          try {
            var f = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder, p = new f();
            p.append(d), y.blob = p.getBlob("application/zip").size === 0;
          } catch {
            y.blob = !1;
          }
        }
      }
      try {
        y.nodestream = !!v("readable-stream").Readable;
      } catch {
        y.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(v, N, y) {
      for (var d = v("./utils"), f = v("./support"), p = v("./nodejsUtils"), o = v("./stream/GenericWorker"), w = new Array(256), l = 0; l < 256; l++)
        w[l] = l >= 252 ? 6 : l >= 248 ? 5 : l >= 240 ? 4 : l >= 224 ? 3 : l >= 192 ? 2 : 1;
      w[254] = w[254] = 1;
      var h = function(r) {
        var n, s, b, O, c, g = r.length, k = 0;
        for (O = 0; O < g; O++)
          s = r.charCodeAt(O), (s & 64512) === 55296 && O + 1 < g && (b = r.charCodeAt(O + 1), (b & 64512) === 56320 && (s = 65536 + (s - 55296 << 10) + (b - 56320), O++)), k += s < 128 ? 1 : s < 2048 ? 2 : s < 65536 ? 3 : 4;
        for (f.uint8array ? n = new Uint8Array(k) : n = new Array(k), c = 0, O = 0; c < k; O++)
          s = r.charCodeAt(O), (s & 64512) === 55296 && O + 1 < g && (b = r.charCodeAt(O + 1), (b & 64512) === 56320 && (s = 65536 + (s - 55296 << 10) + (b - 56320), O++)), s < 128 ? n[c++] = s : s < 2048 ? (n[c++] = 192 | s >>> 6, n[c++] = 128 | s & 63) : s < 65536 ? (n[c++] = 224 | s >>> 12, n[c++] = 128 | s >>> 6 & 63, n[c++] = 128 | s & 63) : (n[c++] = 240 | s >>> 18, n[c++] = 128 | s >>> 12 & 63, n[c++] = 128 | s >>> 6 & 63, n[c++] = 128 | s & 63);
        return n;
      }, x = function(r, n) {
        var s;
        for (n = n || r.length, n > r.length && (n = r.length), s = n - 1; s >= 0 && (r[s] & 192) === 128; )
          s--;
        return s < 0 || s === 0 ? n : s + w[r[s]] > n ? s : n;
      }, u = function(r) {
        var n, s, b, O, c = r.length, g = new Array(c * 2);
        for (s = 0, n = 0; n < c; ) {
          if (b = r[n++], b < 128) {
            g[s++] = b;
            continue;
          }
          if (O = w[b], O > 4) {
            g[s++] = 65533, n += O - 1;
            continue;
          }
          for (b &= O === 2 ? 31 : O === 3 ? 15 : 7; O > 1 && n < c; )
            b = b << 6 | r[n++] & 63, O--;
          if (O > 1) {
            g[s++] = 65533;
            continue;
          }
          b < 65536 ? g[s++] = b : (b -= 65536, g[s++] = 55296 | b >> 10 & 1023, g[s++] = 56320 | b & 1023);
        }
        return g.length !== s && (g.subarray ? g = g.subarray(0, s) : g.length = s), d.applyFromCharCode(g);
      };
      y.utf8encode = function(n) {
        return f.nodebuffer ? p.newBufferFrom(n, "utf-8") : h(n);
      }, y.utf8decode = function(n) {
        return f.nodebuffer ? d.transformTo("nodebuffer", n).toString("utf-8") : (n = d.transformTo(f.uint8array ? "uint8array" : "array", n), u(n));
      };
      function z() {
        o.call(this, "utf-8 decode"), this.leftOver = null;
      }
      d.inherits(z, o), z.prototype.processChunk = function(r) {
        var n = d.transformTo(f.uint8array ? "uint8array" : "array", r.data);
        if (this.leftOver && this.leftOver.length) {
          if (f.uint8array) {
            var s = n;
            n = new Uint8Array(s.length + this.leftOver.length), n.set(this.leftOver, 0), n.set(s, this.leftOver.length);
          } else
            n = this.leftOver.concat(n);
          this.leftOver = null;
        }
        var b = x(n), O = n;
        b !== n.length && (f.uint8array ? (O = n.subarray(0, b), this.leftOver = n.subarray(b, n.length)) : (O = n.slice(0, b), this.leftOver = n.slice(b, n.length))), this.push({
          data: y.utf8decode(O),
          meta: r.meta
        });
      }, z.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({
          data: y.utf8decode(this.leftOver),
          meta: {}
        }), this.leftOver = null);
      }, y.Utf8DecodeWorker = z;
      function A() {
        o.call(this, "utf-8 encode");
      }
      d.inherits(A, o), A.prototype.processChunk = function(r) {
        this.push({
          data: y.utf8encode(r.data),
          meta: r.meta
        });
      }, y.Utf8EncodeWorker = A;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(v, N, y) {
      var d = v("./support"), f = v("./base64"), p = v("./nodejsUtils"), o = v("./external");
      v("setimmediate");
      function w(r) {
        var n = null;
        return d.uint8array ? n = new Uint8Array(r.length) : n = new Array(r.length), h(r, n);
      }
      y.newBlob = function(r, n) {
        y.checkSupport("blob");
        try {
          return new Blob([r], {
            type: n
          });
        } catch {
          try {
            var s = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder, b = new s();
            return b.append(r), b.getBlob(n);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      function l(r) {
        return r;
      }
      function h(r, n) {
        for (var s = 0; s < r.length; ++s)
          n[s] = r.charCodeAt(s) & 255;
        return n;
      }
      var x = {
        /**
         * Transform an array of int into a string, chunk by chunk.
         * See the performances notes on arrayLikeToString.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @param {String} type the type of the array.
         * @param {Integer} chunk the chunk size.
         * @return {String} the resulting string.
         * @throws Error if the chunk is too big for the stack.
         */
        stringifyByChunk: function(r, n, s) {
          var b = [], O = 0, c = r.length;
          if (c <= s)
            return String.fromCharCode.apply(null, r);
          for (; O < c; )
            n === "array" || n === "nodebuffer" ? b.push(String.fromCharCode.apply(null, r.slice(O, Math.min(O + s, c)))) : b.push(String.fromCharCode.apply(null, r.subarray(O, Math.min(O + s, c)))), O += s;
          return b.join("");
        },
        /**
         * Call String.fromCharCode on every item in the array.
         * This is the naive implementation, which generate A LOT of intermediate string.
         * This should be used when everything else fail.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @return {String} the result.
         */
        stringifyByChar: function(r) {
          for (var n = "", s = 0; s < r.length; s++)
            n += String.fromCharCode(r[s]);
          return n;
        },
        applyCanBeUsed: {
          /**
           * true if the browser accepts to use String.fromCharCode on Uint8Array
           */
          uint8array: function() {
            try {
              return d.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch {
              return !1;
            }
          }(),
          /**
           * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
           */
          nodebuffer: function() {
            try {
              return d.nodebuffer && String.fromCharCode.apply(null, p.allocBuffer(1)).length === 1;
            } catch {
              return !1;
            }
          }()
        }
      };
      function u(r) {
        var n = 65536, s = y.getTypeOf(r), b = !0;
        if (s === "uint8array" ? b = x.applyCanBeUsed.uint8array : s === "nodebuffer" && (b = x.applyCanBeUsed.nodebuffer), b)
          for (; n > 1; )
            try {
              return x.stringifyByChunk(r, s, n);
            } catch {
              n = Math.floor(n / 2);
            }
        return x.stringifyByChar(r);
      }
      y.applyFromCharCode = u;
      function z(r, n) {
        for (var s = 0; s < r.length; s++)
          n[s] = r[s];
        return n;
      }
      var A = {};
      A.string = {
        string: l,
        array: function(r) {
          return h(r, new Array(r.length));
        },
        arraybuffer: function(r) {
          return A.string.uint8array(r).buffer;
        },
        uint8array: function(r) {
          return h(r, new Uint8Array(r.length));
        },
        nodebuffer: function(r) {
          return h(r, p.allocBuffer(r.length));
        }
      }, A.array = {
        string: u,
        array: l,
        arraybuffer: function(r) {
          return new Uint8Array(r).buffer;
        },
        uint8array: function(r) {
          return new Uint8Array(r);
        },
        nodebuffer: function(r) {
          return p.newBufferFrom(r);
        }
      }, A.arraybuffer = {
        string: function(r) {
          return u(new Uint8Array(r));
        },
        array: function(r) {
          return z(new Uint8Array(r), new Array(r.byteLength));
        },
        arraybuffer: l,
        uint8array: function(r) {
          return new Uint8Array(r);
        },
        nodebuffer: function(r) {
          return p.newBufferFrom(new Uint8Array(r));
        }
      }, A.uint8array = {
        string: u,
        array: function(r) {
          return z(r, new Array(r.length));
        },
        arraybuffer: function(r) {
          return r.buffer;
        },
        uint8array: l,
        nodebuffer: function(r) {
          return p.newBufferFrom(r);
        }
      }, A.nodebuffer = {
        string: u,
        array: function(r) {
          return z(r, new Array(r.length));
        },
        arraybuffer: function(r) {
          return A.nodebuffer.uint8array(r).buffer;
        },
        uint8array: function(r) {
          return z(r, new Uint8Array(r.length));
        },
        nodebuffer: l
      }, y.transformTo = function(r, n) {
        if (n || (n = ""), !r)
          return n;
        y.checkSupport(r);
        var s = y.getTypeOf(n), b = A[s][r](n);
        return b;
      }, y.resolve = function(r) {
        for (var n = r.split("/"), s = [], b = 0; b < n.length; b++) {
          var O = n[b];
          O === "." || O === "" && b !== 0 && b !== n.length - 1 || (O === ".." ? s.pop() : s.push(O));
        }
        return s.join("/");
      }, y.getTypeOf = function(r) {
        if (typeof r == "string")
          return "string";
        if (Object.prototype.toString.call(r) === "[object Array]")
          return "array";
        if (d.nodebuffer && p.isBuffer(r))
          return "nodebuffer";
        if (d.uint8array && r instanceof Uint8Array)
          return "uint8array";
        if (d.arraybuffer && r instanceof ArrayBuffer)
          return "arraybuffer";
      }, y.checkSupport = function(r) {
        var n = d[r.toLowerCase()];
        if (!n)
          throw new Error(r + " is not supported by this platform");
      }, y.MAX_VALUE_16BITS = 65535, y.MAX_VALUE_32BITS = -1, y.pretty = function(r) {
        var n = "", s, b;
        for (b = 0; b < (r || "").length; b++)
          s = r.charCodeAt(b), n += "\\x" + (s < 16 ? "0" : "") + s.toString(16).toUpperCase();
        return n;
      }, y.delay = function(r, n, s) {
        setImmediate(function() {
          r.apply(s || null, n || []);
        });
      }, y.inherits = function(r, n) {
        var s = function() {
        };
        s.prototype = n.prototype, r.prototype = new s();
      }, y.extend = function() {
        var r = {}, n, s;
        for (n = 0; n < arguments.length; n++)
          for (s in arguments[n])
            Object.prototype.hasOwnProperty.call(arguments[n], s) && typeof r[s] > "u" && (r[s] = arguments[n][s]);
        return r;
      }, y.prepareContent = function(r, n, s, b, O) {
        var c = o.Promise.resolve(n).then(function(g) {
          var k = d.blob && (g instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(g)) !== -1);
          return k && typeof FileReader < "u" ? new o.Promise(function(S, R) {
            var I = new FileReader();
            I.onload = function(P) {
              S(P.target.result);
            }, I.onerror = function(P) {
              R(P.target.error);
            }, I.readAsArrayBuffer(g);
          }) : g;
        });
        return c.then(function(g) {
          var k = y.getTypeOf(g);
          return k ? (k === "arraybuffer" ? g = y.transformTo("uint8array", g) : k === "string" && (O ? g = f.decode(g) : s && b !== !0 && (g = w(g))), g) : o.Promise.reject(
            new Error("Can't read the data of '" + r + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(v, N, y) {
      var d = v("./reader/readerFor"), f = v("./utils"), p = v("./signature"), o = v("./zipEntry"), w = v("./support");
      function l(h) {
        this.files = [], this.loadOptions = h;
      }
      l.prototype = {
        /**
         * Check that the reader is on the specified signature.
         * @param {string} expectedSignature the expected signature.
         * @throws {Error} if it is an other signature.
         */
        checkSignature: function(h) {
          if (!this.reader.readAndCheckSignature(h)) {
            this.reader.index -= 4;
            var x = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + f.pretty(x) + ", expected " + f.pretty(h) + ")");
          }
        },
        /**
         * Check if the given signature is at the given index.
         * @param {number} askedIndex the index to check.
         * @param {string} expectedSignature the signature to expect.
         * @return {boolean} true if the signature is here, false otherwise.
         */
        isSignature: function(h, x) {
          var u = this.reader.index;
          this.reader.setIndex(h);
          var z = this.reader.readString(4), A = z === x;
          return this.reader.setIndex(u), A;
        },
        /**
         * Read the end of the central directory.
         */
        readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var h = this.reader.readData(this.zipCommentLength), x = w.uint8array ? "uint8array" : "array", u = f.transformTo(x, h);
          this.zipComment = this.loadOptions.decodeFileName(u);
        },
        /**
         * Read the end of the Zip 64 central directory.
         * Not merged with the method readEndOfCentral :
         * The end of central can coexist with its Zip64 brother,
         * I don't want to read the wrong number of bytes !
         */
        readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var h = this.zip64EndOfCentralSize - 44, x = 0, u, z, A; x < h; )
            u = this.reader.readInt(2), z = this.reader.readInt(4), A = this.reader.readData(z), this.zip64ExtensibleData[u] = {
              id: u,
              length: z,
              value: A
            };
        },
        /**
         * Read the end of the Zip 64 central directory locator.
         */
        readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), this.disksCount > 1)
            throw new Error("Multi-volumes zip are not supported");
        },
        /**
         * Read the local files, based on the offset read in the central part.
         */
        readLocalFiles: function() {
          var h, x;
          for (h = 0; h < this.files.length; h++)
            x = this.files[h], this.reader.setIndex(x.localHeaderOffset), this.checkSignature(p.LOCAL_FILE_HEADER), x.readLocalPart(this.reader), x.handleUTF8(), x.processAttributes();
        },
        /**
         * Read the central directory.
         */
        readCentralDir: function() {
          var h;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(p.CENTRAL_FILE_HEADER); )
            h = new o({
              zip64: this.zip64
            }, this.loadOptions), h.readCentralPart(this.reader), this.files.push(h);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        },
        /**
         * Read the end of central directory.
         */
        readEndOfCentral: function() {
          var h = this.reader.lastIndexOfSignature(p.CENTRAL_DIRECTORY_END);
          if (h < 0) {
            var x = !this.isSignature(0, p.LOCAL_FILE_HEADER);
            throw x ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          }
          this.reader.setIndex(h);
          var u = h;
          if (this.checkSignature(p.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === f.MAX_VALUE_16BITS || this.diskWithCentralDirStart === f.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === f.MAX_VALUE_16BITS || this.centralDirRecords === f.MAX_VALUE_16BITS || this.centralDirSize === f.MAX_VALUE_32BITS || this.centralDirOffset === f.MAX_VALUE_32BITS) {
            if (this.zip64 = !0, h = this.reader.lastIndexOfSignature(p.ZIP64_CENTRAL_DIRECTORY_LOCATOR), h < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(h), this.checkSignature(p.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, p.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(p.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(p.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var z = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (z += 20, z += 12 + this.zip64EndOfCentralSize);
          var A = u - z;
          if (A > 0)
            this.isSignature(u, p.CENTRAL_FILE_HEADER) || (this.reader.zero = A);
          else if (A < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(A) + " bytes.");
        },
        prepareReader: function(h) {
          this.reader = d(h);
        },
        /**
         * Read a zip file and create ZipEntries.
         * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
         */
        load: function(h) {
          this.prepareReader(h), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        }
      }, N.exports = l;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(v, N, y) {
      var d = v("./reader/readerFor"), f = v("./utils"), p = v("./compressedObject"), o = v("./crc32"), w = v("./utf8"), l = v("./compressions"), h = v("./support"), x = 0, u = 3, z = function(r) {
        for (var n in l)
          if (Object.prototype.hasOwnProperty.call(l, n) && l[n].magic === r)
            return l[n];
        return null;
      };
      function A(r, n) {
        this.options = r, this.loadOptions = n;
      }
      A.prototype = {
        /**
         * say if the file is encrypted.
         * @return {boolean} true if the file is encrypted, false otherwise.
         */
        isEncrypted: function() {
          return (this.bitFlag & 1) === 1;
        },
        /**
         * say if the file has utf-8 filename/comment.
         * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
         */
        useUTF8: function() {
          return (this.bitFlag & 2048) === 2048;
        },
        /**
         * Read the local part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readLocalPart: function(r) {
          var n, s;
          if (r.skip(22), this.fileNameLength = r.readInt(2), s = r.readInt(2), this.fileName = r.readData(this.fileNameLength), r.skip(s), this.compressedSize === -1 || this.uncompressedSize === -1)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (n = z(this.compressionMethod), n === null)
            throw new Error("Corrupted zip : compression " + f.pretty(this.compressionMethod) + " unknown (inner file : " + f.transformTo("string", this.fileName) + ")");
          this.decompressed = new p(this.compressedSize, this.uncompressedSize, this.crc32, n, r.readData(this.compressedSize));
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readCentralPart: function(r) {
          this.versionMadeBy = r.readInt(2), r.skip(2), this.bitFlag = r.readInt(2), this.compressionMethod = r.readString(2), this.date = r.readDate(), this.crc32 = r.readInt(4), this.compressedSize = r.readInt(4), this.uncompressedSize = r.readInt(4);
          var n = r.readInt(2);
          if (this.extraFieldsLength = r.readInt(2), this.fileCommentLength = r.readInt(2), this.diskNumberStart = r.readInt(2), this.internalFileAttributes = r.readInt(2), this.externalFileAttributes = r.readInt(4), this.localHeaderOffset = r.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          r.skip(n), this.readExtraFields(r), this.parseZIP64ExtraField(r), this.fileComment = r.readData(this.fileCommentLength);
        },
        /**
         * Parse the external file attributes and get the unix/dos permissions.
         */
        processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var r = this.versionMadeBy >> 8;
          this.dir = !!(this.externalFileAttributes & 16), r === x && (this.dosPermissions = this.externalFileAttributes & 63), r === u && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), !this.dir && this.fileNameStr.slice(-1) === "/" && (this.dir = !0);
        },
        /**
         * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
         * @param {DataReader} reader the reader to use.
         */
        parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var r = d(this.extraFields[1].value);
            this.uncompressedSize === f.MAX_VALUE_32BITS && (this.uncompressedSize = r.readInt(8)), this.compressedSize === f.MAX_VALUE_32BITS && (this.compressedSize = r.readInt(8)), this.localHeaderOffset === f.MAX_VALUE_32BITS && (this.localHeaderOffset = r.readInt(8)), this.diskNumberStart === f.MAX_VALUE_32BITS && (this.diskNumberStart = r.readInt(4));
          }
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readExtraFields: function(r) {
          var n = r.index + this.extraFieldsLength, s, b, O;
          for (this.extraFields || (this.extraFields = {}); r.index + 4 < n; )
            s = r.readInt(2), b = r.readInt(2), O = r.readData(b), this.extraFields[s] = {
              id: s,
              length: b,
              value: O
            };
          r.setIndex(n);
        },
        /**
         * Apply an UTF8 transformation if needed.
         */
        handleUTF8: function() {
          var r = h.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = w.utf8decode(this.fileName), this.fileCommentStr = w.utf8decode(this.fileComment);
          else {
            var n = this.findExtraFieldUnicodePath();
            if (n !== null)
              this.fileNameStr = n;
            else {
              var s = f.transformTo(r, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(s);
            }
            var b = this.findExtraFieldUnicodeComment();
            if (b !== null)
              this.fileCommentStr = b;
            else {
              var O = f.transformTo(r, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(O);
            }
          }
        },
        /**
         * Find the unicode path declared in the extra field, if any.
         * @return {String} the unicode path, null otherwise.
         */
        findExtraFieldUnicodePath: function() {
          var r = this.extraFields[28789];
          if (r) {
            var n = d(r.value);
            return n.readInt(1) !== 1 || o(this.fileName) !== n.readInt(4) ? null : w.utf8decode(n.readData(r.length - 5));
          }
          return null;
        },
        /**
         * Find the unicode comment declared in the extra field, if any.
         * @return {String} the unicode comment, null otherwise.
         */
        findExtraFieldUnicodeComment: function() {
          var r = this.extraFields[25461];
          if (r) {
            var n = d(r.value);
            return n.readInt(1) !== 1 || o(this.fileComment) !== n.readInt(4) ? null : w.utf8decode(n.readData(r.length - 5));
          }
          return null;
        }
      }, N.exports = A;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(v, N, y) {
      var d = v("./stream/StreamHelper"), f = v("./stream/DataWorker"), p = v("./utf8"), o = v("./compressedObject"), w = v("./stream/GenericWorker"), l = function(z, A, r) {
        this.name = z, this.dir = r.dir, this.date = r.date, this.comment = r.comment, this.unixPermissions = r.unixPermissions, this.dosPermissions = r.dosPermissions, this._data = A, this._dataBinary = r.binary, this.options = {
          compression: r.compression,
          compressionOptions: r.compressionOptions
        };
      };
      l.prototype = {
        /**
         * Create an internal stream for the content of this object.
         * @param {String} type the type of each chunk.
         * @return StreamHelper the stream.
         */
        internalStream: function(z) {
          var A = null, r = "string";
          try {
            if (!z)
              throw new Error("No output type specified.");
            r = z.toLowerCase();
            var n = r === "string" || r === "text";
            (r === "binarystring" || r === "text") && (r = "string"), A = this._decompressWorker();
            var s = !this._dataBinary;
            s && !n && (A = A.pipe(new p.Utf8EncodeWorker())), !s && n && (A = A.pipe(new p.Utf8DecodeWorker()));
          } catch (b) {
            A = new w("error"), A.error(b);
          }
          return new d(A, r, "");
        },
        /**
         * Prepare the content in the asked type.
         * @param {String} type the type of the result.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Promise the promise of the result.
         */
        async: function(z, A) {
          return this.internalStream(z).accumulate(A);
        },
        /**
         * Prepare the content as a nodejs stream.
         * @param {String} type the type of each chunk.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Stream the stream.
         */
        nodeStream: function(z, A) {
          return this.internalStream(z || "nodebuffer").toNodejsStream(A);
        },
        /**
         * Return a worker for the compressed content.
         * @private
         * @param {Object} compression the compression object to use.
         * @param {Object} compressionOptions the options to use when compressing.
         * @return Worker the worker.
         */
        _compressWorker: function(z, A) {
          if (this._data instanceof o && this._data.compression.magic === z.magic)
            return this._data.getCompressedWorker();
          var r = this._decompressWorker();
          return this._dataBinary || (r = r.pipe(new p.Utf8EncodeWorker())), o.createWorkerFrom(r, z, A);
        },
        /**
         * Return a worker for the decompressed content.
         * @private
         * @return Worker the worker.
         */
        _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof w ? this._data : new f(this._data);
        }
      };
      for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], x = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, u = 0; u < h.length; u++)
        l.prototype[h[u]] = x;
      N.exports = l;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(v, N, y) {
      (function(d) {
        var f = d.MutationObserver || d.WebKitMutationObserver, p;
        if (f) {
          var o = 0, w = new f(z), l = d.document.createTextNode("");
          w.observe(l, {
            characterData: !0
          }), p = function() {
            l.data = o = ++o % 2;
          };
        } else if (!d.setImmediate && typeof d.MessageChannel < "u") {
          var h = new d.MessageChannel();
          h.port1.onmessage = z, p = function() {
            h.port2.postMessage(0);
          };
        } else "document" in d && "onreadystatechange" in d.document.createElement("script") ? p = function() {
          var r = d.document.createElement("script");
          r.onreadystatechange = function() {
            z(), r.onreadystatechange = null, r.parentNode.removeChild(r), r = null;
          }, d.document.documentElement.appendChild(r);
        } : p = function() {
          setTimeout(z, 0);
        };
        var x, u = [];
        function z() {
          x = !0;
          for (var r, n, s = u.length; s; ) {
            for (n = u, u = [], r = -1; ++r < s; )
              n[r]();
            s = u.length;
          }
          x = !1;
        }
        N.exports = A;
        function A(r) {
          u.push(r) === 1 && !x && p();
        }
      }).call(this, typeof Xe < "u" ? Xe : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(v, N, y) {
      var d = v("immediate");
      function f() {
      }
      var p = {}, o = ["REJECTED"], w = ["FULFILLED"], l = ["PENDING"];
      N.exports = h;
      function h(c) {
        if (typeof c != "function")
          throw new TypeError("resolver must be a function");
        this.state = l, this.queue = [], this.outcome = void 0, c !== f && A(this, c);
      }
      h.prototype.finally = function(c) {
        if (typeof c != "function")
          return this;
        var g = this.constructor;
        return this.then(k, S);
        function k(R) {
          function I() {
            return R;
          }
          return g.resolve(c()).then(I);
        }
        function S(R) {
          function I() {
            throw R;
          }
          return g.resolve(c()).then(I);
        }
      }, h.prototype.catch = function(c) {
        return this.then(null, c);
      }, h.prototype.then = function(c, g) {
        if (typeof c != "function" && this.state === w || typeof g != "function" && this.state === o)
          return this;
        var k = new this.constructor(f);
        if (this.state !== l) {
          var S = this.state === w ? c : g;
          u(k, S, this.outcome);
        } else
          this.queue.push(new x(k, c, g));
        return k;
      };
      function x(c, g, k) {
        this.promise = c, typeof g == "function" && (this.onFulfilled = g, this.callFulfilled = this.otherCallFulfilled), typeof k == "function" && (this.onRejected = k, this.callRejected = this.otherCallRejected);
      }
      x.prototype.callFulfilled = function(c) {
        p.resolve(this.promise, c);
      }, x.prototype.otherCallFulfilled = function(c) {
        u(this.promise, this.onFulfilled, c);
      }, x.prototype.callRejected = function(c) {
        p.reject(this.promise, c);
      }, x.prototype.otherCallRejected = function(c) {
        u(this.promise, this.onRejected, c);
      };
      function u(c, g, k) {
        d(function() {
          var S;
          try {
            S = g(k);
          } catch (R) {
            return p.reject(c, R);
          }
          S === c ? p.reject(c, new TypeError("Cannot resolve promise with itself")) : p.resolve(c, S);
        });
      }
      p.resolve = function(c, g) {
        var k = r(z, g);
        if (k.status === "error")
          return p.reject(c, k.value);
        var S = k.value;
        if (S)
          A(c, S);
        else {
          c.state = w, c.outcome = g;
          for (var R = -1, I = c.queue.length; ++R < I; )
            c.queue[R].callFulfilled(g);
        }
        return c;
      }, p.reject = function(c, g) {
        c.state = o, c.outcome = g;
        for (var k = -1, S = c.queue.length; ++k < S; )
          c.queue[k].callRejected(g);
        return c;
      };
      function z(c) {
        var g = c && c.then;
        if (c && (typeof c == "object" || typeof c == "function") && typeof g == "function")
          return function() {
            g.apply(c, arguments);
          };
      }
      function A(c, g) {
        var k = !1;
        function S(L) {
          k || (k = !0, p.reject(c, L));
        }
        function R(L) {
          k || (k = !0, p.resolve(c, L));
        }
        function I() {
          g(R, S);
        }
        var P = r(I);
        P.status === "error" && S(P.value);
      }
      function r(c, g) {
        var k = {};
        try {
          k.value = c(g), k.status = "success";
        } catch (S) {
          k.status = "error", k.value = S;
        }
        return k;
      }
      h.resolve = n;
      function n(c) {
        return c instanceof this ? c : p.resolve(new this(f), c);
      }
      h.reject = s;
      function s(c) {
        var g = new this(f);
        return p.reject(g, c);
      }
      h.all = b;
      function b(c) {
        var g = this;
        if (Object.prototype.toString.call(c) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var k = c.length, S = !1;
        if (!k)
          return this.resolve([]);
        for (var R = new Array(k), I = 0, P = -1, L = new this(f); ++P < k; )
          G(c[P], P);
        return L;
        function G(J, X) {
          g.resolve(J).then(te, function(V) {
            S || (S = !0, p.reject(L, V));
          });
          function te(V) {
            R[X] = V, ++I === k && !S && (S = !0, p.resolve(L, R));
          }
        }
      }
      h.race = O;
      function O(c) {
        var g = this;
        if (Object.prototype.toString.call(c) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var k = c.length, S = !1;
        if (!k)
          return this.resolve([]);
        for (var R = -1, I = new this(f); ++R < k; )
          P(c[R]);
        return I;
        function P(L) {
          g.resolve(L).then(function(G) {
            S || (S = !0, p.resolve(I, G));
          }, function(G) {
            S || (S = !0, p.reject(I, G));
          });
        }
      }
    }, { immediate: 36 }], 38: [function(v, N, y) {
      var d = v("./lib/utils/common").assign, f = v("./lib/deflate"), p = v("./lib/inflate"), o = v("./lib/zlib/constants"), w = {};
      d(w, f, p, o), N.exports = w;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(v, N, y) {
      var d = v("./zlib/deflate"), f = v("./utils/common"), p = v("./utils/strings"), o = v("./zlib/messages"), w = v("./zlib/zstream"), l = Object.prototype.toString, h = 0, x = 4, u = 0, z = 1, A = 2, r = -1, n = 0, s = 8;
      function b(k) {
        if (!(this instanceof b)) return new b(k);
        this.options = f.assign({
          level: r,
          method: s,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: n,
          to: ""
        }, k || {});
        var S = this.options;
        S.raw && S.windowBits > 0 ? S.windowBits = -S.windowBits : S.gzip && S.windowBits > 0 && S.windowBits < 16 && (S.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new w(), this.strm.avail_out = 0;
        var R = d.deflateInit2(
          this.strm,
          S.level,
          S.method,
          S.windowBits,
          S.memLevel,
          S.strategy
        );
        if (R !== u)
          throw new Error(o[R]);
        if (S.header && d.deflateSetHeader(this.strm, S.header), S.dictionary) {
          var I;
          if (typeof S.dictionary == "string" ? I = p.string2buf(S.dictionary) : l.call(S.dictionary) === "[object ArrayBuffer]" ? I = new Uint8Array(S.dictionary) : I = S.dictionary, R = d.deflateSetDictionary(this.strm, I), R !== u)
            throw new Error(o[R]);
          this._dict_set = !0;
        }
      }
      b.prototype.push = function(k, S) {
        var R = this.strm, I = this.options.chunkSize, P, L;
        if (this.ended)
          return !1;
        L = S === ~~S ? S : S === !0 ? x : h, typeof k == "string" ? R.input = p.string2buf(k) : l.call(k) === "[object ArrayBuffer]" ? R.input = new Uint8Array(k) : R.input = k, R.next_in = 0, R.avail_in = R.input.length;
        do {
          if (R.avail_out === 0 && (R.output = new f.Buf8(I), R.next_out = 0, R.avail_out = I), P = d.deflate(R, L), P !== z && P !== u)
            return this.onEnd(P), this.ended = !0, !1;
          (R.avail_out === 0 || R.avail_in === 0 && (L === x || L === A)) && (this.options.to === "string" ? this.onData(p.buf2binstring(f.shrinkBuf(R.output, R.next_out))) : this.onData(f.shrinkBuf(R.output, R.next_out)));
        } while ((R.avail_in > 0 || R.avail_out === 0) && P !== z);
        return L === x ? (P = d.deflateEnd(this.strm), this.onEnd(P), this.ended = !0, P === u) : (L === A && (this.onEnd(u), R.avail_out = 0), !0);
      }, b.prototype.onData = function(k) {
        this.chunks.push(k);
      }, b.prototype.onEnd = function(k) {
        k === u && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = f.flattenChunks(this.chunks)), this.chunks = [], this.err = k, this.msg = this.strm.msg;
      };
      function O(k, S) {
        var R = new b(S);
        if (R.push(k, !0), R.err)
          throw R.msg || o[R.err];
        return R.result;
      }
      function c(k, S) {
        return S = S || {}, S.raw = !0, O(k, S);
      }
      function g(k, S) {
        return S = S || {}, S.gzip = !0, O(k, S);
      }
      y.Deflate = b, y.deflate = O, y.deflateRaw = c, y.gzip = g;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(v, N, y) {
      var d = v("./zlib/inflate"), f = v("./utils/common"), p = v("./utils/strings"), o = v("./zlib/constants"), w = v("./zlib/messages"), l = v("./zlib/zstream"), h = v("./zlib/gzheader"), x = Object.prototype.toString;
      function u(r) {
        if (!(this instanceof u)) return new u(r);
        this.options = f.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, r || {});
        var n = this.options;
        n.raw && n.windowBits >= 0 && n.windowBits < 16 && (n.windowBits = -n.windowBits, n.windowBits === 0 && (n.windowBits = -15)), n.windowBits >= 0 && n.windowBits < 16 && !(r && r.windowBits) && (n.windowBits += 32), n.windowBits > 15 && n.windowBits < 48 && (n.windowBits & 15 || (n.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new l(), this.strm.avail_out = 0;
        var s = d.inflateInit2(
          this.strm,
          n.windowBits
        );
        if (s !== o.Z_OK)
          throw new Error(w[s]);
        this.header = new h(), d.inflateGetHeader(this.strm, this.header);
      }
      u.prototype.push = function(r, n) {
        var s = this.strm, b = this.options.chunkSize, O = this.options.dictionary, c, g, k, S, R, I, P = !1;
        if (this.ended)
          return !1;
        g = n === ~~n ? n : n === !0 ? o.Z_FINISH : o.Z_NO_FLUSH, typeof r == "string" ? s.input = p.binstring2buf(r) : x.call(r) === "[object ArrayBuffer]" ? s.input = new Uint8Array(r) : s.input = r, s.next_in = 0, s.avail_in = s.input.length;
        do {
          if (s.avail_out === 0 && (s.output = new f.Buf8(b), s.next_out = 0, s.avail_out = b), c = d.inflate(s, o.Z_NO_FLUSH), c === o.Z_NEED_DICT && O && (typeof O == "string" ? I = p.string2buf(O) : x.call(O) === "[object ArrayBuffer]" ? I = new Uint8Array(O) : I = O, c = d.inflateSetDictionary(this.strm, I)), c === o.Z_BUF_ERROR && P === !0 && (c = o.Z_OK, P = !1), c !== o.Z_STREAM_END && c !== o.Z_OK)
            return this.onEnd(c), this.ended = !0, !1;
          s.next_out && (s.avail_out === 0 || c === o.Z_STREAM_END || s.avail_in === 0 && (g === o.Z_FINISH || g === o.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (k = p.utf8border(s.output, s.next_out), S = s.next_out - k, R = p.buf2string(s.output, k), s.next_out = S, s.avail_out = b - S, S && f.arraySet(s.output, s.output, k, S, 0), this.onData(R)) : this.onData(f.shrinkBuf(s.output, s.next_out))), s.avail_in === 0 && s.avail_out === 0 && (P = !0);
        } while ((s.avail_in > 0 || s.avail_out === 0) && c !== o.Z_STREAM_END);
        return c === o.Z_STREAM_END && (g = o.Z_FINISH), g === o.Z_FINISH ? (c = d.inflateEnd(this.strm), this.onEnd(c), this.ended = !0, c === o.Z_OK) : (g === o.Z_SYNC_FLUSH && (this.onEnd(o.Z_OK), s.avail_out = 0), !0);
      }, u.prototype.onData = function(r) {
        this.chunks.push(r);
      }, u.prototype.onEnd = function(r) {
        r === o.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = f.flattenChunks(this.chunks)), this.chunks = [], this.err = r, this.msg = this.strm.msg;
      };
      function z(r, n) {
        var s = new u(n);
        if (s.push(r, !0), s.err)
          throw s.msg || w[s.err];
        return s.result;
      }
      function A(r, n) {
        return n = n || {}, n.raw = !0, z(r, n);
      }
      y.Inflate = u, y.inflate = z, y.inflateRaw = A, y.ungzip = z;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(v, N, y) {
      var d = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      y.assign = function(o) {
        for (var w = Array.prototype.slice.call(arguments, 1); w.length; ) {
          var l = w.shift();
          if (l) {
            if (typeof l != "object")
              throw new TypeError(l + "must be non-object");
            for (var h in l)
              l.hasOwnProperty(h) && (o[h] = l[h]);
          }
        }
        return o;
      }, y.shrinkBuf = function(o, w) {
        return o.length === w ? o : o.subarray ? o.subarray(0, w) : (o.length = w, o);
      };
      var f = {
        arraySet: function(o, w, l, h, x) {
          if (w.subarray && o.subarray) {
            o.set(w.subarray(l, l + h), x);
            return;
          }
          for (var u = 0; u < h; u++)
            o[x + u] = w[l + u];
        },
        // Join array of chunks to single array.
        flattenChunks: function(o) {
          var w, l, h, x, u, z;
          for (h = 0, w = 0, l = o.length; w < l; w++)
            h += o[w].length;
          for (z = new Uint8Array(h), x = 0, w = 0, l = o.length; w < l; w++)
            u = o[w], z.set(u, x), x += u.length;
          return z;
        }
      }, p = {
        arraySet: function(o, w, l, h, x) {
          for (var u = 0; u < h; u++)
            o[x + u] = w[l + u];
        },
        // Join array of chunks to single array.
        flattenChunks: function(o) {
          return [].concat.apply([], o);
        }
      };
      y.setTyped = function(o) {
        o ? (y.Buf8 = Uint8Array, y.Buf16 = Uint16Array, y.Buf32 = Int32Array, y.assign(y, f)) : (y.Buf8 = Array, y.Buf16 = Array, y.Buf32 = Array, y.assign(y, p));
      }, y.setTyped(d);
    }, {}], 42: [function(v, N, y) {
      var d = v("./common"), f = !0, p = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        f = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        p = !1;
      }
      for (var o = new d.Buf8(256), w = 0; w < 256; w++)
        o[w] = w >= 252 ? 6 : w >= 248 ? 5 : w >= 240 ? 4 : w >= 224 ? 3 : w >= 192 ? 2 : 1;
      o[254] = o[254] = 1, y.string2buf = function(h) {
        var x, u, z, A, r, n = h.length, s = 0;
        for (A = 0; A < n; A++)
          u = h.charCodeAt(A), (u & 64512) === 55296 && A + 1 < n && (z = h.charCodeAt(A + 1), (z & 64512) === 56320 && (u = 65536 + (u - 55296 << 10) + (z - 56320), A++)), s += u < 128 ? 1 : u < 2048 ? 2 : u < 65536 ? 3 : 4;
        for (x = new d.Buf8(s), r = 0, A = 0; r < s; A++)
          u = h.charCodeAt(A), (u & 64512) === 55296 && A + 1 < n && (z = h.charCodeAt(A + 1), (z & 64512) === 56320 && (u = 65536 + (u - 55296 << 10) + (z - 56320), A++)), u < 128 ? x[r++] = u : u < 2048 ? (x[r++] = 192 | u >>> 6, x[r++] = 128 | u & 63) : u < 65536 ? (x[r++] = 224 | u >>> 12, x[r++] = 128 | u >>> 6 & 63, x[r++] = 128 | u & 63) : (x[r++] = 240 | u >>> 18, x[r++] = 128 | u >>> 12 & 63, x[r++] = 128 | u >>> 6 & 63, x[r++] = 128 | u & 63);
        return x;
      };
      function l(h, x) {
        if (x < 65537 && (h.subarray && p || !h.subarray && f))
          return String.fromCharCode.apply(null, d.shrinkBuf(h, x));
        for (var u = "", z = 0; z < x; z++)
          u += String.fromCharCode(h[z]);
        return u;
      }
      y.buf2binstring = function(h) {
        return l(h, h.length);
      }, y.binstring2buf = function(h) {
        for (var x = new d.Buf8(h.length), u = 0, z = x.length; u < z; u++)
          x[u] = h.charCodeAt(u);
        return x;
      }, y.buf2string = function(h, x) {
        var u, z, A, r, n = x || h.length, s = new Array(n * 2);
        for (z = 0, u = 0; u < n; ) {
          if (A = h[u++], A < 128) {
            s[z++] = A;
            continue;
          }
          if (r = o[A], r > 4) {
            s[z++] = 65533, u += r - 1;
            continue;
          }
          for (A &= r === 2 ? 31 : r === 3 ? 15 : 7; r > 1 && u < n; )
            A = A << 6 | h[u++] & 63, r--;
          if (r > 1) {
            s[z++] = 65533;
            continue;
          }
          A < 65536 ? s[z++] = A : (A -= 65536, s[z++] = 55296 | A >> 10 & 1023, s[z++] = 56320 | A & 1023);
        }
        return l(s, z);
      }, y.utf8border = function(h, x) {
        var u;
        for (x = x || h.length, x > h.length && (x = h.length), u = x - 1; u >= 0 && (h[u] & 192) === 128; )
          u--;
        return u < 0 || u === 0 ? x : u + o[h[u]] > x ? u : x;
      };
    }, { "./common": 41 }], 43: [function(v, N, y) {
      function d(f, p, o, w) {
        for (var l = f & 65535 | 0, h = f >>> 16 & 65535 | 0, x = 0; o !== 0; ) {
          x = o > 2e3 ? 2e3 : o, o -= x;
          do
            l = l + p[w++] | 0, h = h + l | 0;
          while (--x);
          l %= 65521, h %= 65521;
        }
        return l | h << 16 | 0;
      }
      N.exports = d;
    }, {}], 44: [function(v, N, y) {
      N.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }, {}], 45: [function(v, N, y) {
      function d() {
        for (var o, w = [], l = 0; l < 256; l++) {
          o = l;
          for (var h = 0; h < 8; h++)
            o = o & 1 ? 3988292384 ^ o >>> 1 : o >>> 1;
          w[l] = o;
        }
        return w;
      }
      var f = d();
      function p(o, w, l, h) {
        var x = f, u = h + l;
        o ^= -1;
        for (var z = h; z < u; z++)
          o = o >>> 8 ^ x[(o ^ w[z]) & 255];
        return o ^ -1;
      }
      N.exports = p;
    }, {}], 46: [function(v, N, y) {
      var d = v("../utils/common"), f = v("./trees"), p = v("./adler32"), o = v("./crc32"), w = v("./messages"), l = 0, h = 1, x = 3, u = 4, z = 5, A = 0, r = 1, n = -2, s = -3, b = -5, O = -1, c = 1, g = 2, k = 3, S = 4, R = 0, I = 2, P = 8, L = 9, G = 15, J = 8, X = 29, te = 256, V = te + 1 + X, j = 30, q = 19, fe = 2 * V + 1, ce = 15, Y = 3, se = 258, ie = se + Y + 1, we = 32, me = 42, de = 69, $ = 73, ge = 91, pe = 103, ae = 113, he = 666, ne = 1, xe = 2, Ae = 3, Te = 4, oe = 3;
      function Ee(e, C) {
        return e.msg = w[C], C;
      }
      function We(e) {
        return (e << 1) - (e > 4 ? 9 : 0);
      }
      function Ie(e) {
        for (var C = e.length; --C >= 0; )
          e[C] = 0;
      }
      function Ce(e) {
        var C = e.state, T = C.pending;
        T > e.avail_out && (T = e.avail_out), T !== 0 && (d.arraySet(e.output, C.pending_buf, C.pending_out, T, e.next_out), e.next_out += T, C.pending_out += T, e.total_out += T, e.avail_out -= T, C.pending -= T, C.pending === 0 && (C.pending_out = 0));
      }
      function le(e, C) {
        f._tr_flush_block(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, C), e.block_start = e.strstart, Ce(e.strm);
      }
      function Q(e, C) {
        e.pending_buf[e.pending++] = C;
      }
      function ze(e, C) {
        e.pending_buf[e.pending++] = C >>> 8 & 255, e.pending_buf[e.pending++] = C & 255;
      }
      function Me(e, C, T, i) {
        var _ = e.avail_in;
        return _ > i && (_ = i), _ === 0 ? 0 : (e.avail_in -= _, d.arraySet(C, e.input, e.next_in, _, T), e.state.wrap === 1 ? e.adler = p(e.adler, C, _, T) : e.state.wrap === 2 && (e.adler = o(e.adler, C, _, T)), e.next_in += _, e.total_in += _, _);
      }
      function Ue(e, C) {
        var T = e.max_chain_length, i = e.strstart, _, E, H = e.prev_length, Z = e.nice_match, W = e.strstart > e.w_size - ie ? e.strstart - (e.w_size - ie) : 0, ee = e.window, Ne = e.w_mask, ue = e.prev, re = e.strstart + se, ve = ee[i + H - 1], ke = ee[i + H];
        e.prev_length >= e.good_match && (T >>= 2), Z > e.lookahead && (Z = e.lookahead);
        do
          if (_ = C, !(ee[_ + H] !== ke || ee[_ + H - 1] !== ve || ee[_] !== ee[i] || ee[++_] !== ee[i + 1])) {
            i += 2, _++;
            do
              ;
            while (ee[++i] === ee[++_] && ee[++i] === ee[++_] && ee[++i] === ee[++_] && ee[++i] === ee[++_] && ee[++i] === ee[++_] && ee[++i] === ee[++_] && ee[++i] === ee[++_] && ee[++i] === ee[++_] && i < re);
            if (E = se - (re - i), i = re - se, E > H) {
              if (e.match_start = C, H = E, E >= Z)
                break;
              ve = ee[i + H - 1], ke = ee[i + H];
            }
          }
        while ((C = ue[C & Ne]) > W && --T !== 0);
        return H <= e.lookahead ? H : e.lookahead;
      }
      function Oe(e) {
        var C = e.w_size, T, i, _, E, H;
        do {
          if (E = e.window_size - e.lookahead - e.strstart, e.strstart >= C + (C - ie)) {
            d.arraySet(e.window, e.window, C, C, 0), e.match_start -= C, e.strstart -= C, e.block_start -= C, i = e.hash_size, T = i;
            do
              _ = e.head[--T], e.head[T] = _ >= C ? _ - C : 0;
            while (--i);
            i = C, T = i;
            do
              _ = e.prev[--T], e.prev[T] = _ >= C ? _ - C : 0;
            while (--i);
            E += C;
          }
          if (e.strm.avail_in === 0)
            break;
          if (i = Me(e.strm, e.window, e.strstart + e.lookahead, E), e.lookahead += i, e.lookahead + e.insert >= Y)
            for (H = e.strstart - e.insert, e.ins_h = e.window[H], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[H + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[H + Y - 1]) & e.hash_mask, e.prev[H & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = H, H++, e.insert--, !(e.lookahead + e.insert < Y)); )
              ;
        } while (e.lookahead < ie && e.strm.avail_in !== 0);
      }
      function je(e, C) {
        var T = 65535;
        for (T > e.pending_buf_size - 5 && (T = e.pending_buf_size - 5); ; ) {
          if (e.lookahead <= 1) {
            if (Oe(e), e.lookahead === 0 && C === l)
              return ne;
            if (e.lookahead === 0)
              break;
          }
          e.strstart += e.lookahead, e.lookahead = 0;
          var i = e.block_start + T;
          if ((e.strstart === 0 || e.strstart >= i) && (e.lookahead = e.strstart - i, e.strstart = i, le(e, !1), e.strm.avail_out === 0) || e.strstart - e.block_start >= e.w_size - ie && (le(e, !1), e.strm.avail_out === 0))
            return ne;
        }
        return e.insert = 0, C === u ? (le(e, !0), e.strm.avail_out === 0 ? Ae : Te) : (e.strstart > e.block_start && (le(e, !1), e.strm.avail_out === 0), ne);
      }
      function Pe(e, C) {
        for (var T, i; ; ) {
          if (e.lookahead < ie) {
            if (Oe(e), e.lookahead < ie && C === l)
              return ne;
            if (e.lookahead === 0)
              break;
          }
          if (T = 0, e.lookahead >= Y && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + Y - 1]) & e.hash_mask, T = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), T !== 0 && e.strstart - T <= e.w_size - ie && (e.match_length = Ue(e, T)), e.match_length >= Y)
            if (i = f._tr_tally(e, e.strstart - e.match_start, e.match_length - Y), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= Y) {
              e.match_length--;
              do
                e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + Y - 1]) & e.hash_mask, T = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
              while (--e.match_length !== 0);
              e.strstart++;
            } else
              e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask;
          else
            i = f._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
          if (i && (le(e, !1), e.strm.avail_out === 0))
            return ne;
        }
        return e.insert = e.strstart < Y - 1 ? e.strstart : Y - 1, C === u ? (le(e, !0), e.strm.avail_out === 0 ? Ae : Te) : e.last_lit && (le(e, !1), e.strm.avail_out === 0) ? ne : xe;
      }
      function Re(e, C) {
        for (var T, i, _; ; ) {
          if (e.lookahead < ie) {
            if (Oe(e), e.lookahead < ie && C === l)
              return ne;
            if (e.lookahead === 0)
              break;
          }
          if (T = 0, e.lookahead >= Y && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + Y - 1]) & e.hash_mask, T = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = Y - 1, T !== 0 && e.prev_length < e.max_lazy_match && e.strstart - T <= e.w_size - ie && (e.match_length = Ue(e, T), e.match_length <= 5 && (e.strategy === c || e.match_length === Y && e.strstart - e.match_start > 4096) && (e.match_length = Y - 1)), e.prev_length >= Y && e.match_length <= e.prev_length) {
            _ = e.strstart + e.lookahead - Y, i = f._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - Y), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
            do
              ++e.strstart <= _ && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + Y - 1]) & e.hash_mask, T = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
            while (--e.prev_length !== 0);
            if (e.match_available = 0, e.match_length = Y - 1, e.strstart++, i && (le(e, !1), e.strm.avail_out === 0))
              return ne;
          } else if (e.match_available) {
            if (i = f._tr_tally(e, 0, e.window[e.strstart - 1]), i && le(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
              return ne;
          } else
            e.match_available = 1, e.strstart++, e.lookahead--;
        }
        return e.match_available && (i = f._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < Y - 1 ? e.strstart : Y - 1, C === u ? (le(e, !0), e.strm.avail_out === 0 ? Ae : Te) : e.last_lit && (le(e, !1), e.strm.avail_out === 0) ? ne : xe;
      }
      function He(e, C) {
        for (var T, i, _, E, H = e.window; ; ) {
          if (e.lookahead <= se) {
            if (Oe(e), e.lookahead <= se && C === l)
              return ne;
            if (e.lookahead === 0)
              break;
          }
          if (e.match_length = 0, e.lookahead >= Y && e.strstart > 0 && (_ = e.strstart - 1, i = H[_], i === H[++_] && i === H[++_] && i === H[++_])) {
            E = e.strstart + se;
            do
              ;
            while (i === H[++_] && i === H[++_] && i === H[++_] && i === H[++_] && i === H[++_] && i === H[++_] && i === H[++_] && i === H[++_] && _ < E);
            e.match_length = se - (E - _), e.match_length > e.lookahead && (e.match_length = e.lookahead);
          }
          if (e.match_length >= Y ? (T = f._tr_tally(e, 1, e.match_length - Y), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (T = f._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), T && (le(e, !1), e.strm.avail_out === 0))
            return ne;
        }
        return e.insert = 0, C === u ? (le(e, !0), e.strm.avail_out === 0 ? Ae : Te) : e.last_lit && (le(e, !1), e.strm.avail_out === 0) ? ne : xe;
      }
      function Ze(e, C) {
        for (var T; ; ) {
          if (e.lookahead === 0 && (Oe(e), e.lookahead === 0)) {
            if (C === l)
              return ne;
            break;
          }
          if (e.match_length = 0, T = f._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, T && (le(e, !1), e.strm.avail_out === 0))
            return ne;
        }
        return e.insert = 0, C === u ? (le(e, !0), e.strm.avail_out === 0 ? Ae : Te) : e.last_lit && (le(e, !1), e.strm.avail_out === 0) ? ne : xe;
      }
      function ye(e, C, T, i, _) {
        this.good_length = e, this.max_lazy = C, this.nice_length = T, this.max_chain = i, this.func = _;
      }
      var Fe;
      Fe = [
        /*      good lazy nice chain */
        new ye(0, 0, 0, 0, je),
        /* 0 store only */
        new ye(4, 4, 8, 4, Pe),
        /* 1 max speed, no lazy matches */
        new ye(4, 5, 16, 8, Pe),
        /* 2 */
        new ye(4, 6, 32, 32, Pe),
        /* 3 */
        new ye(4, 4, 16, 16, Re),
        /* 4 lazy matches */
        new ye(8, 16, 32, 32, Re),
        /* 5 */
        new ye(8, 16, 128, 128, Re),
        /* 6 */
        new ye(8, 32, 128, 256, Re),
        /* 7 */
        new ye(32, 128, 258, 1024, Re),
        /* 8 */
        new ye(32, 258, 258, 4096, Re)
        /* 9 max compression */
      ];
      function Ge(e) {
        e.window_size = 2 * e.w_size, Ie(e.head), e.max_lazy_match = Fe[e.level].max_lazy, e.good_match = Fe[e.level].good_length, e.nice_match = Fe[e.level].nice_length, e.max_chain_length = Fe[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = Y - 1, e.match_available = 0, e.ins_h = 0;
      }
      function a() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = P, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new d.Buf16(fe * 2), this.dyn_dtree = new d.Buf16((2 * j + 1) * 2), this.bl_tree = new d.Buf16((2 * q + 1) * 2), Ie(this.dyn_ltree), Ie(this.dyn_dtree), Ie(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new d.Buf16(ce + 1), this.heap = new d.Buf16(2 * V + 1), Ie(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new d.Buf16(2 * V + 1), Ie(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function F(e) {
        var C;
        return !e || !e.state ? Ee(e, n) : (e.total_in = e.total_out = 0, e.data_type = I, C = e.state, C.pending = 0, C.pending_out = 0, C.wrap < 0 && (C.wrap = -C.wrap), C.status = C.wrap ? me : ae, e.adler = C.wrap === 2 ? 0 : 1, C.last_flush = l, f._tr_init(C), A);
      }
      function U(e) {
        var C = F(e);
        return C === A && Ge(e.state), C;
      }
      function M(e, C) {
        return !e || !e.state || e.state.wrap !== 2 ? n : (e.state.gzhead = C, A);
      }
      function m(e, C, T, i, _, E) {
        if (!e)
          return n;
        var H = 1;
        if (C === O && (C = 6), i < 0 ? (H = 0, i = -i) : i > 15 && (H = 2, i -= 16), _ < 1 || _ > L || T !== P || i < 8 || i > 15 || C < 0 || C > 9 || E < 0 || E > S)
          return Ee(e, n);
        i === 8 && (i = 9);
        var Z = new a();
        return e.state = Z, Z.strm = e, Z.wrap = H, Z.gzhead = null, Z.w_bits = i, Z.w_size = 1 << Z.w_bits, Z.w_mask = Z.w_size - 1, Z.hash_bits = _ + 7, Z.hash_size = 1 << Z.hash_bits, Z.hash_mask = Z.hash_size - 1, Z.hash_shift = ~~((Z.hash_bits + Y - 1) / Y), Z.window = new d.Buf8(Z.w_size * 2), Z.head = new d.Buf16(Z.hash_size), Z.prev = new d.Buf16(Z.w_size), Z.lit_bufsize = 1 << _ + 6, Z.pending_buf_size = Z.lit_bufsize * 4, Z.pending_buf = new d.Buf8(Z.pending_buf_size), Z.d_buf = 1 * Z.lit_bufsize, Z.l_buf = 3 * Z.lit_bufsize, Z.level = C, Z.strategy = E, Z.method = T, U(e);
      }
      function D(e, C) {
        return m(e, C, P, G, J, R);
      }
      function t(e, C) {
        var T, i, _, E;
        if (!e || !e.state || C > z || C < 0)
          return e ? Ee(e, n) : n;
        if (i = e.state, !e.output || !e.input && e.avail_in !== 0 || i.status === he && C !== u)
          return Ee(e, e.avail_out === 0 ? b : n);
        if (i.strm = e, T = i.last_flush, i.last_flush = C, i.status === me)
          if (i.wrap === 2)
            e.adler = 0, Q(i, 31), Q(i, 139), Q(i, 8), i.gzhead ? (Q(
              i,
              (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)
            ), Q(i, i.gzhead.time & 255), Q(i, i.gzhead.time >> 8 & 255), Q(i, i.gzhead.time >> 16 & 255), Q(i, i.gzhead.time >> 24 & 255), Q(i, i.level === 9 ? 2 : i.strategy >= g || i.level < 2 ? 4 : 0), Q(i, i.gzhead.os & 255), i.gzhead.extra && i.gzhead.extra.length && (Q(i, i.gzhead.extra.length & 255), Q(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (e.adler = o(e.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = de) : (Q(i, 0), Q(i, 0), Q(i, 0), Q(i, 0), Q(i, 0), Q(i, i.level === 9 ? 2 : i.strategy >= g || i.level < 2 ? 4 : 0), Q(i, oe), i.status = ae);
          else {
            var H = P + (i.w_bits - 8 << 4) << 8, Z = -1;
            i.strategy >= g || i.level < 2 ? Z = 0 : i.level < 6 ? Z = 1 : i.level === 6 ? Z = 2 : Z = 3, H |= Z << 6, i.strstart !== 0 && (H |= we), H += 31 - H % 31, i.status = ae, ze(i, H), i.strstart !== 0 && (ze(i, e.adler >>> 16), ze(i, e.adler & 65535)), e.adler = 1;
          }
        if (i.status === de)
          if (i.gzhead.extra) {
            for (_ = i.pending; i.gzindex < (i.gzhead.extra.length & 65535) && !(i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > _ && (e.adler = o(e.adler, i.pending_buf, i.pending - _, _)), Ce(e), _ = i.pending, i.pending === i.pending_buf_size)); )
              Q(i, i.gzhead.extra[i.gzindex] & 255), i.gzindex++;
            i.gzhead.hcrc && i.pending > _ && (e.adler = o(e.adler, i.pending_buf, i.pending - _, _)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = $);
          } else
            i.status = $;
        if (i.status === $)
          if (i.gzhead.name) {
            _ = i.pending;
            do {
              if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > _ && (e.adler = o(e.adler, i.pending_buf, i.pending - _, _)), Ce(e), _ = i.pending, i.pending === i.pending_buf_size)) {
                E = 1;
                break;
              }
              i.gzindex < i.gzhead.name.length ? E = i.gzhead.name.charCodeAt(i.gzindex++) & 255 : E = 0, Q(i, E);
            } while (E !== 0);
            i.gzhead.hcrc && i.pending > _ && (e.adler = o(e.adler, i.pending_buf, i.pending - _, _)), E === 0 && (i.gzindex = 0, i.status = ge);
          } else
            i.status = ge;
        if (i.status === ge)
          if (i.gzhead.comment) {
            _ = i.pending;
            do {
              if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > _ && (e.adler = o(e.adler, i.pending_buf, i.pending - _, _)), Ce(e), _ = i.pending, i.pending === i.pending_buf_size)) {
                E = 1;
                break;
              }
              i.gzindex < i.gzhead.comment.length ? E = i.gzhead.comment.charCodeAt(i.gzindex++) & 255 : E = 0, Q(i, E);
            } while (E !== 0);
            i.gzhead.hcrc && i.pending > _ && (e.adler = o(e.adler, i.pending_buf, i.pending - _, _)), E === 0 && (i.status = pe);
          } else
            i.status = pe;
        if (i.status === pe && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && Ce(e), i.pending + 2 <= i.pending_buf_size && (Q(i, e.adler & 255), Q(i, e.adler >> 8 & 255), e.adler = 0, i.status = ae)) : i.status = ae), i.pending !== 0) {
          if (Ce(e), e.avail_out === 0)
            return i.last_flush = -1, A;
        } else if (e.avail_in === 0 && We(C) <= We(T) && C !== u)
          return Ee(e, b);
        if (i.status === he && e.avail_in !== 0)
          return Ee(e, b);
        if (e.avail_in !== 0 || i.lookahead !== 0 || C !== l && i.status !== he) {
          var W = i.strategy === g ? Ze(i, C) : i.strategy === k ? He(i, C) : Fe[i.level].func(i, C);
          if ((W === Ae || W === Te) && (i.status = he), W === ne || W === Ae)
            return e.avail_out === 0 && (i.last_flush = -1), A;
          if (W === xe && (C === h ? f._tr_align(i) : C !== z && (f._tr_stored_block(i, 0, 0, !1), C === x && (Ie(i.head), i.lookahead === 0 && (i.strstart = 0, i.block_start = 0, i.insert = 0))), Ce(e), e.avail_out === 0))
            return i.last_flush = -1, A;
        }
        return C !== u ? A : i.wrap <= 0 ? r : (i.wrap === 2 ? (Q(i, e.adler & 255), Q(i, e.adler >> 8 & 255), Q(i, e.adler >> 16 & 255), Q(i, e.adler >> 24 & 255), Q(i, e.total_in & 255), Q(i, e.total_in >> 8 & 255), Q(i, e.total_in >> 16 & 255), Q(i, e.total_in >> 24 & 255)) : (ze(i, e.adler >>> 16), ze(i, e.adler & 65535)), Ce(e), i.wrap > 0 && (i.wrap = -i.wrap), i.pending !== 0 ? A : r);
      }
      function B(e) {
        var C;
        return !e || !e.state ? n : (C = e.state.status, C !== me && C !== de && C !== $ && C !== ge && C !== pe && C !== ae && C !== he ? Ee(e, n) : (e.state = null, C === ae ? Ee(e, s) : A));
      }
      function K(e, C) {
        var T = C.length, i, _, E, H, Z, W, ee, Ne;
        if (!e || !e.state || (i = e.state, H = i.wrap, H === 2 || H === 1 && i.status !== me || i.lookahead))
          return n;
        for (H === 1 && (e.adler = p(e.adler, C, T, 0)), i.wrap = 0, T >= i.w_size && (H === 0 && (Ie(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0), Ne = new d.Buf8(i.w_size), d.arraySet(Ne, C, T - i.w_size, i.w_size, 0), C = Ne, T = i.w_size), Z = e.avail_in, W = e.next_in, ee = e.input, e.avail_in = T, e.next_in = 0, e.input = C, Oe(i); i.lookahead >= Y; ) {
          _ = i.strstart, E = i.lookahead - (Y - 1);
          do
            i.ins_h = (i.ins_h << i.hash_shift ^ i.window[_ + Y - 1]) & i.hash_mask, i.prev[_ & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = _, _++;
          while (--E);
          i.strstart = _, i.lookahead = Y - 1, Oe(i);
        }
        return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = Y - 1, i.match_available = 0, e.next_in = W, e.input = ee, e.avail_in = Z, i.wrap = H, A;
      }
      y.deflateInit = D, y.deflateInit2 = m, y.deflateReset = U, y.deflateResetKeep = F, y.deflateSetHeader = M, y.deflate = t, y.deflateEnd = B, y.deflateSetDictionary = K, y.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(v, N, y) {
      function d() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      }
      N.exports = d;
    }, {}], 48: [function(v, N, y) {
      var d = 30, f = 12;
      N.exports = function(o, w) {
        var l, h, x, u, z, A, r, n, s, b, O, c, g, k, S, R, I, P, L, G, J, X, te, V, j;
        l = o.state, h = o.next_in, V = o.input, x = h + (o.avail_in - 5), u = o.next_out, j = o.output, z = u - (w - o.avail_out), A = u + (o.avail_out - 257), r = l.dmax, n = l.wsize, s = l.whave, b = l.wnext, O = l.window, c = l.hold, g = l.bits, k = l.lencode, S = l.distcode, R = (1 << l.lenbits) - 1, I = (1 << l.distbits) - 1;
        e:
          do {
            g < 15 && (c += V[h++] << g, g += 8, c += V[h++] << g, g += 8), P = k[c & R];
            t:
              for (; ; ) {
                if (L = P >>> 24, c >>>= L, g -= L, L = P >>> 16 & 255, L === 0)
                  j[u++] = P & 65535;
                else if (L & 16) {
                  G = P & 65535, L &= 15, L && (g < L && (c += V[h++] << g, g += 8), G += c & (1 << L) - 1, c >>>= L, g -= L), g < 15 && (c += V[h++] << g, g += 8, c += V[h++] << g, g += 8), P = S[c & I];
                  r:
                    for (; ; ) {
                      if (L = P >>> 24, c >>>= L, g -= L, L = P >>> 16 & 255, L & 16) {
                        if (J = P & 65535, L &= 15, g < L && (c += V[h++] << g, g += 8, g < L && (c += V[h++] << g, g += 8)), J += c & (1 << L) - 1, J > r) {
                          o.msg = "invalid distance too far back", l.mode = d;
                          break e;
                        }
                        if (c >>>= L, g -= L, L = u - z, J > L) {
                          if (L = J - L, L > s && l.sane) {
                            o.msg = "invalid distance too far back", l.mode = d;
                            break e;
                          }
                          if (X = 0, te = O, b === 0) {
                            if (X += n - L, L < G) {
                              G -= L;
                              do
                                j[u++] = O[X++];
                              while (--L);
                              X = u - J, te = j;
                            }
                          } else if (b < L) {
                            if (X += n + b - L, L -= b, L < G) {
                              G -= L;
                              do
                                j[u++] = O[X++];
                              while (--L);
                              if (X = 0, b < G) {
                                L = b, G -= L;
                                do
                                  j[u++] = O[X++];
                                while (--L);
                                X = u - J, te = j;
                              }
                            }
                          } else if (X += b - L, L < G) {
                            G -= L;
                            do
                              j[u++] = O[X++];
                            while (--L);
                            X = u - J, te = j;
                          }
                          for (; G > 2; )
                            j[u++] = te[X++], j[u++] = te[X++], j[u++] = te[X++], G -= 3;
                          G && (j[u++] = te[X++], G > 1 && (j[u++] = te[X++]));
                        } else {
                          X = u - J;
                          do
                            j[u++] = j[X++], j[u++] = j[X++], j[u++] = j[X++], G -= 3;
                          while (G > 2);
                          G && (j[u++] = j[X++], G > 1 && (j[u++] = j[X++]));
                        }
                      } else if (L & 64) {
                        o.msg = "invalid distance code", l.mode = d;
                        break e;
                      } else {
                        P = S[(P & 65535) + (c & (1 << L) - 1)];
                        continue r;
                      }
                      break;
                    }
                } else if (L & 64)
                  if (L & 32) {
                    l.mode = f;
                    break e;
                  } else {
                    o.msg = "invalid literal/length code", l.mode = d;
                    break e;
                  }
                else {
                  P = k[(P & 65535) + (c & (1 << L) - 1)];
                  continue t;
                }
                break;
              }
          } while (h < x && u < A);
        G = g >> 3, h -= G, g -= G << 3, c &= (1 << g) - 1, o.next_in = h, o.next_out = u, o.avail_in = h < x ? 5 + (x - h) : 5 - (h - x), o.avail_out = u < A ? 257 + (A - u) : 257 - (u - A), l.hold = c, l.bits = g;
      };
    }, {}], 49: [function(v, N, y) {
      var d = v("../utils/common"), f = v("./adler32"), p = v("./crc32"), o = v("./inffast"), w = v("./inftrees"), l = 0, h = 1, x = 2, u = 4, z = 5, A = 6, r = 0, n = 1, s = 2, b = -2, O = -3, c = -4, g = -5, k = 8, S = 1, R = 2, I = 3, P = 4, L = 5, G = 6, J = 7, X = 8, te = 9, V = 10, j = 11, q = 12, fe = 13, ce = 14, Y = 15, se = 16, ie = 17, we = 18, me = 19, de = 20, $ = 21, ge = 22, pe = 23, ae = 24, he = 25, ne = 26, xe = 27, Ae = 28, Te = 29, oe = 30, Ee = 31, We = 32, Ie = 852, Ce = 592, le = 15, Q = le;
      function ze(m) {
        return (m >>> 24 & 255) + (m >>> 8 & 65280) + ((m & 65280) << 8) + ((m & 255) << 24);
      }
      function Me() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new d.Buf16(320), this.work = new d.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function Ue(m) {
        var D;
        return !m || !m.state ? b : (D = m.state, m.total_in = m.total_out = D.total = 0, m.msg = "", D.wrap && (m.adler = D.wrap & 1), D.mode = S, D.last = 0, D.havedict = 0, D.dmax = 32768, D.head = null, D.hold = 0, D.bits = 0, D.lencode = D.lendyn = new d.Buf32(Ie), D.distcode = D.distdyn = new d.Buf32(Ce), D.sane = 1, D.back = -1, r);
      }
      function Oe(m) {
        var D;
        return !m || !m.state ? b : (D = m.state, D.wsize = 0, D.whave = 0, D.wnext = 0, Ue(m));
      }
      function je(m, D) {
        var t, B;
        return !m || !m.state || (B = m.state, D < 0 ? (t = 0, D = -D) : (t = (D >> 4) + 1, D < 48 && (D &= 15)), D && (D < 8 || D > 15)) ? b : (B.window !== null && B.wbits !== D && (B.window = null), B.wrap = t, B.wbits = D, Oe(m));
      }
      function Pe(m, D) {
        var t, B;
        return m ? (B = new Me(), m.state = B, B.window = null, t = je(m, D), t !== r && (m.state = null), t) : b;
      }
      function Re(m) {
        return Pe(m, Q);
      }
      var He = !0, Ze, ye;
      function Fe(m) {
        if (He) {
          var D;
          for (Ze = new d.Buf32(512), ye = new d.Buf32(32), D = 0; D < 144; )
            m.lens[D++] = 8;
          for (; D < 256; )
            m.lens[D++] = 9;
          for (; D < 280; )
            m.lens[D++] = 7;
          for (; D < 288; )
            m.lens[D++] = 8;
          for (w(h, m.lens, 0, 288, Ze, 0, m.work, { bits: 9 }), D = 0; D < 32; )
            m.lens[D++] = 5;
          w(x, m.lens, 0, 32, ye, 0, m.work, { bits: 5 }), He = !1;
        }
        m.lencode = Ze, m.lenbits = 9, m.distcode = ye, m.distbits = 5;
      }
      function Ge(m, D, t, B) {
        var K, e = m.state;
        return e.window === null && (e.wsize = 1 << e.wbits, e.wnext = 0, e.whave = 0, e.window = new d.Buf8(e.wsize)), B >= e.wsize ? (d.arraySet(e.window, D, t - e.wsize, e.wsize, 0), e.wnext = 0, e.whave = e.wsize) : (K = e.wsize - e.wnext, K > B && (K = B), d.arraySet(e.window, D, t - B, K, e.wnext), B -= K, B ? (d.arraySet(e.window, D, t - B, B, 0), e.wnext = B, e.whave = e.wsize) : (e.wnext += K, e.wnext === e.wsize && (e.wnext = 0), e.whave < e.wsize && (e.whave += K))), 0;
      }
      function a(m, D) {
        var t, B, K, e, C, T, i, _, E, H, Z, W, ee, Ne, ue = 0, re, ve, ke, Se, Ye, Ke, _e, De, be = new d.Buf8(4), Le, Be, Je = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!m || !m.state || !m.output || !m.input && m.avail_in !== 0)
          return b;
        t = m.state, t.mode === q && (t.mode = fe), C = m.next_out, K = m.output, i = m.avail_out, e = m.next_in, B = m.input, T = m.avail_in, _ = t.hold, E = t.bits, H = T, Z = i, De = r;
        e:
          for (; ; )
            switch (t.mode) {
              case S:
                if (t.wrap === 0) {
                  t.mode = fe;
                  break;
                }
                for (; E < 16; ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                if (t.wrap & 2 && _ === 35615) {
                  t.check = 0, be[0] = _ & 255, be[1] = _ >>> 8 & 255, t.check = p(t.check, be, 2, 0), _ = 0, E = 0, t.mode = R;
                  break;
                }
                if (t.flags = 0, t.head && (t.head.done = !1), !(t.wrap & 1) || /* check if zlib header allowed */
                (((_ & 255) << 8) + (_ >> 8)) % 31) {
                  m.msg = "incorrect header check", t.mode = oe;
                  break;
                }
                if ((_ & 15) !== k) {
                  m.msg = "unknown compression method", t.mode = oe;
                  break;
                }
                if (_ >>>= 4, E -= 4, _e = (_ & 15) + 8, t.wbits === 0)
                  t.wbits = _e;
                else if (_e > t.wbits) {
                  m.msg = "invalid window size", t.mode = oe;
                  break;
                }
                t.dmax = 1 << _e, m.adler = t.check = 1, t.mode = _ & 512 ? V : q, _ = 0, E = 0;
                break;
              case R:
                for (; E < 16; ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                if (t.flags = _, (t.flags & 255) !== k) {
                  m.msg = "unknown compression method", t.mode = oe;
                  break;
                }
                if (t.flags & 57344) {
                  m.msg = "unknown header flags set", t.mode = oe;
                  break;
                }
                t.head && (t.head.text = _ >> 8 & 1), t.flags & 512 && (be[0] = _ & 255, be[1] = _ >>> 8 & 255, t.check = p(t.check, be, 2, 0)), _ = 0, E = 0, t.mode = I;
              case I:
                for (; E < 32; ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                t.head && (t.head.time = _), t.flags & 512 && (be[0] = _ & 255, be[1] = _ >>> 8 & 255, be[2] = _ >>> 16 & 255, be[3] = _ >>> 24 & 255, t.check = p(t.check, be, 4, 0)), _ = 0, E = 0, t.mode = P;
              case P:
                for (; E < 16; ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                t.head && (t.head.xflags = _ & 255, t.head.os = _ >> 8), t.flags & 512 && (be[0] = _ & 255, be[1] = _ >>> 8 & 255, t.check = p(t.check, be, 2, 0)), _ = 0, E = 0, t.mode = L;
              case L:
                if (t.flags & 1024) {
                  for (; E < 16; ) {
                    if (T === 0)
                      break e;
                    T--, _ += B[e++] << E, E += 8;
                  }
                  t.length = _, t.head && (t.head.extra_len = _), t.flags & 512 && (be[0] = _ & 255, be[1] = _ >>> 8 & 255, t.check = p(t.check, be, 2, 0)), _ = 0, E = 0;
                } else t.head && (t.head.extra = null);
                t.mode = G;
              case G:
                if (t.flags & 1024 && (W = t.length, W > T && (W = T), W && (t.head && (_e = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Array(t.head.extra_len)), d.arraySet(
                  t.head.extra,
                  B,
                  e,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  W,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  _e
                )), t.flags & 512 && (t.check = p(t.check, B, W, e)), T -= W, e += W, t.length -= W), t.length))
                  break e;
                t.length = 0, t.mode = J;
              case J:
                if (t.flags & 2048) {
                  if (T === 0)
                    break e;
                  W = 0;
                  do
                    _e = B[e + W++], t.head && _e && t.length < 65536 && (t.head.name += String.fromCharCode(_e));
                  while (_e && W < T);
                  if (t.flags & 512 && (t.check = p(t.check, B, W, e)), T -= W, e += W, _e)
                    break e;
                } else t.head && (t.head.name = null);
                t.length = 0, t.mode = X;
              case X:
                if (t.flags & 4096) {
                  if (T === 0)
                    break e;
                  W = 0;
                  do
                    _e = B[e + W++], t.head && _e && t.length < 65536 && (t.head.comment += String.fromCharCode(_e));
                  while (_e && W < T);
                  if (t.flags & 512 && (t.check = p(t.check, B, W, e)), T -= W, e += W, _e)
                    break e;
                } else t.head && (t.head.comment = null);
                t.mode = te;
              case te:
                if (t.flags & 512) {
                  for (; E < 16; ) {
                    if (T === 0)
                      break e;
                    T--, _ += B[e++] << E, E += 8;
                  }
                  if (_ !== (t.check & 65535)) {
                    m.msg = "header crc mismatch", t.mode = oe;
                    break;
                  }
                  _ = 0, E = 0;
                }
                t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = !0), m.adler = t.check = 0, t.mode = q;
                break;
              case V:
                for (; E < 32; ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                m.adler = t.check = ze(_), _ = 0, E = 0, t.mode = j;
              case j:
                if (t.havedict === 0)
                  return m.next_out = C, m.avail_out = i, m.next_in = e, m.avail_in = T, t.hold = _, t.bits = E, s;
                m.adler = t.check = 1, t.mode = q;
              case q:
                if (D === z || D === A)
                  break e;
              case fe:
                if (t.last) {
                  _ >>>= E & 7, E -= E & 7, t.mode = xe;
                  break;
                }
                for (; E < 3; ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                switch (t.last = _ & 1, _ >>>= 1, E -= 1, _ & 3) {
                  case 0:
                    t.mode = ce;
                    break;
                  case 1:
                    if (Fe(t), t.mode = de, D === A) {
                      _ >>>= 2, E -= 2;
                      break e;
                    }
                    break;
                  case 2:
                    t.mode = ie;
                    break;
                  case 3:
                    m.msg = "invalid block type", t.mode = oe;
                }
                _ >>>= 2, E -= 2;
                break;
              case ce:
                for (_ >>>= E & 7, E -= E & 7; E < 32; ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                if ((_ & 65535) !== (_ >>> 16 ^ 65535)) {
                  m.msg = "invalid stored block lengths", t.mode = oe;
                  break;
                }
                if (t.length = _ & 65535, _ = 0, E = 0, t.mode = Y, D === A)
                  break e;
              case Y:
                t.mode = se;
              case se:
                if (W = t.length, W) {
                  if (W > T && (W = T), W > i && (W = i), W === 0)
                    break e;
                  d.arraySet(K, B, e, W, C), T -= W, e += W, i -= W, C += W, t.length -= W;
                  break;
                }
                t.mode = q;
                break;
              case ie:
                for (; E < 14; ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                if (t.nlen = (_ & 31) + 257, _ >>>= 5, E -= 5, t.ndist = (_ & 31) + 1, _ >>>= 5, E -= 5, t.ncode = (_ & 15) + 4, _ >>>= 4, E -= 4, t.nlen > 286 || t.ndist > 30) {
                  m.msg = "too many length or distance symbols", t.mode = oe;
                  break;
                }
                t.have = 0, t.mode = we;
              case we:
                for (; t.have < t.ncode; ) {
                  for (; E < 3; ) {
                    if (T === 0)
                      break e;
                    T--, _ += B[e++] << E, E += 8;
                  }
                  t.lens[Je[t.have++]] = _ & 7, _ >>>= 3, E -= 3;
                }
                for (; t.have < 19; )
                  t.lens[Je[t.have++]] = 0;
                if (t.lencode = t.lendyn, t.lenbits = 7, Le = { bits: t.lenbits }, De = w(l, t.lens, 0, 19, t.lencode, 0, t.work, Le), t.lenbits = Le.bits, De) {
                  m.msg = "invalid code lengths set", t.mode = oe;
                  break;
                }
                t.have = 0, t.mode = me;
              case me:
                for (; t.have < t.nlen + t.ndist; ) {
                  for (; ue = t.lencode[_ & (1 << t.lenbits) - 1], re = ue >>> 24, ve = ue >>> 16 & 255, ke = ue & 65535, !(re <= E); ) {
                    if (T === 0)
                      break e;
                    T--, _ += B[e++] << E, E += 8;
                  }
                  if (ke < 16)
                    _ >>>= re, E -= re, t.lens[t.have++] = ke;
                  else {
                    if (ke === 16) {
                      for (Be = re + 2; E < Be; ) {
                        if (T === 0)
                          break e;
                        T--, _ += B[e++] << E, E += 8;
                      }
                      if (_ >>>= re, E -= re, t.have === 0) {
                        m.msg = "invalid bit length repeat", t.mode = oe;
                        break;
                      }
                      _e = t.lens[t.have - 1], W = 3 + (_ & 3), _ >>>= 2, E -= 2;
                    } else if (ke === 17) {
                      for (Be = re + 3; E < Be; ) {
                        if (T === 0)
                          break e;
                        T--, _ += B[e++] << E, E += 8;
                      }
                      _ >>>= re, E -= re, _e = 0, W = 3 + (_ & 7), _ >>>= 3, E -= 3;
                    } else {
                      for (Be = re + 7; E < Be; ) {
                        if (T === 0)
                          break e;
                        T--, _ += B[e++] << E, E += 8;
                      }
                      _ >>>= re, E -= re, _e = 0, W = 11 + (_ & 127), _ >>>= 7, E -= 7;
                    }
                    if (t.have + W > t.nlen + t.ndist) {
                      m.msg = "invalid bit length repeat", t.mode = oe;
                      break;
                    }
                    for (; W--; )
                      t.lens[t.have++] = _e;
                  }
                }
                if (t.mode === oe)
                  break;
                if (t.lens[256] === 0) {
                  m.msg = "invalid code -- missing end-of-block", t.mode = oe;
                  break;
                }
                if (t.lenbits = 9, Le = { bits: t.lenbits }, De = w(h, t.lens, 0, t.nlen, t.lencode, 0, t.work, Le), t.lenbits = Le.bits, De) {
                  m.msg = "invalid literal/lengths set", t.mode = oe;
                  break;
                }
                if (t.distbits = 6, t.distcode = t.distdyn, Le = { bits: t.distbits }, De = w(x, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, Le), t.distbits = Le.bits, De) {
                  m.msg = "invalid distances set", t.mode = oe;
                  break;
                }
                if (t.mode = de, D === A)
                  break e;
              case de:
                t.mode = $;
              case $:
                if (T >= 6 && i >= 258) {
                  m.next_out = C, m.avail_out = i, m.next_in = e, m.avail_in = T, t.hold = _, t.bits = E, o(m, Z), C = m.next_out, K = m.output, i = m.avail_out, e = m.next_in, B = m.input, T = m.avail_in, _ = t.hold, E = t.bits, t.mode === q && (t.back = -1);
                  break;
                }
                for (t.back = 0; ue = t.lencode[_ & (1 << t.lenbits) - 1], re = ue >>> 24, ve = ue >>> 16 & 255, ke = ue & 65535, !(re <= E); ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                if (ve && !(ve & 240)) {
                  for (Se = re, Ye = ve, Ke = ke; ue = t.lencode[Ke + ((_ & (1 << Se + Ye) - 1) >> Se)], re = ue >>> 24, ve = ue >>> 16 & 255, ke = ue & 65535, !(Se + re <= E); ) {
                    if (T === 0)
                      break e;
                    T--, _ += B[e++] << E, E += 8;
                  }
                  _ >>>= Se, E -= Se, t.back += Se;
                }
                if (_ >>>= re, E -= re, t.back += re, t.length = ke, ve === 0) {
                  t.mode = ne;
                  break;
                }
                if (ve & 32) {
                  t.back = -1, t.mode = q;
                  break;
                }
                if (ve & 64) {
                  m.msg = "invalid literal/length code", t.mode = oe;
                  break;
                }
                t.extra = ve & 15, t.mode = ge;
              case ge:
                if (t.extra) {
                  for (Be = t.extra; E < Be; ) {
                    if (T === 0)
                      break e;
                    T--, _ += B[e++] << E, E += 8;
                  }
                  t.length += _ & (1 << t.extra) - 1, _ >>>= t.extra, E -= t.extra, t.back += t.extra;
                }
                t.was = t.length, t.mode = pe;
              case pe:
                for (; ue = t.distcode[_ & (1 << t.distbits) - 1], re = ue >>> 24, ve = ue >>> 16 & 255, ke = ue & 65535, !(re <= E); ) {
                  if (T === 0)
                    break e;
                  T--, _ += B[e++] << E, E += 8;
                }
                if (!(ve & 240)) {
                  for (Se = re, Ye = ve, Ke = ke; ue = t.distcode[Ke + ((_ & (1 << Se + Ye) - 1) >> Se)], re = ue >>> 24, ve = ue >>> 16 & 255, ke = ue & 65535, !(Se + re <= E); ) {
                    if (T === 0)
                      break e;
                    T--, _ += B[e++] << E, E += 8;
                  }
                  _ >>>= Se, E -= Se, t.back += Se;
                }
                if (_ >>>= re, E -= re, t.back += re, ve & 64) {
                  m.msg = "invalid distance code", t.mode = oe;
                  break;
                }
                t.offset = ke, t.extra = ve & 15, t.mode = ae;
              case ae:
                if (t.extra) {
                  for (Be = t.extra; E < Be; ) {
                    if (T === 0)
                      break e;
                    T--, _ += B[e++] << E, E += 8;
                  }
                  t.offset += _ & (1 << t.extra) - 1, _ >>>= t.extra, E -= t.extra, t.back += t.extra;
                }
                if (t.offset > t.dmax) {
                  m.msg = "invalid distance too far back", t.mode = oe;
                  break;
                }
                t.mode = he;
              case he:
                if (i === 0)
                  break e;
                if (W = Z - i, t.offset > W) {
                  if (W = t.offset - W, W > t.whave && t.sane) {
                    m.msg = "invalid distance too far back", t.mode = oe;
                    break;
                  }
                  W > t.wnext ? (W -= t.wnext, ee = t.wsize - W) : ee = t.wnext - W, W > t.length && (W = t.length), Ne = t.window;
                } else
                  Ne = K, ee = C - t.offset, W = t.length;
                W > i && (W = i), i -= W, t.length -= W;
                do
                  K[C++] = Ne[ee++];
                while (--W);
                t.length === 0 && (t.mode = $);
                break;
              case ne:
                if (i === 0)
                  break e;
                K[C++] = t.length, i--, t.mode = $;
                break;
              case xe:
                if (t.wrap) {
                  for (; E < 32; ) {
                    if (T === 0)
                      break e;
                    T--, _ |= B[e++] << E, E += 8;
                  }
                  if (Z -= i, m.total_out += Z, t.total += Z, Z && (m.adler = t.check = /*UPDATE(state.check, put - _out, _out);*/
                  t.flags ? p(t.check, K, Z, C - Z) : f(t.check, K, Z, C - Z)), Z = i, (t.flags ? _ : ze(_)) !== t.check) {
                    m.msg = "incorrect data check", t.mode = oe;
                    break;
                  }
                  _ = 0, E = 0;
                }
                t.mode = Ae;
              case Ae:
                if (t.wrap && t.flags) {
                  for (; E < 32; ) {
                    if (T === 0)
                      break e;
                    T--, _ += B[e++] << E, E += 8;
                  }
                  if (_ !== (t.total & 4294967295)) {
                    m.msg = "incorrect length check", t.mode = oe;
                    break;
                  }
                  _ = 0, E = 0;
                }
                t.mode = Te;
              case Te:
                De = n;
                break e;
              case oe:
                De = O;
                break e;
              case Ee:
                return c;
              case We:
              default:
                return b;
            }
        return m.next_out = C, m.avail_out = i, m.next_in = e, m.avail_in = T, t.hold = _, t.bits = E, (t.wsize || Z !== m.avail_out && t.mode < oe && (t.mode < xe || D !== u)) && Ge(m, m.output, m.next_out, Z - m.avail_out), H -= m.avail_in, Z -= m.avail_out, m.total_in += H, m.total_out += Z, t.total += Z, t.wrap && Z && (m.adler = t.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        t.flags ? p(t.check, K, Z, m.next_out - Z) : f(t.check, K, Z, m.next_out - Z)), m.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === q ? 128 : 0) + (t.mode === de || t.mode === Y ? 256 : 0), (H === 0 && Z === 0 || D === u) && De === r && (De = g), De;
      }
      function F(m) {
        if (!m || !m.state)
          return b;
        var D = m.state;
        return D.window && (D.window = null), m.state = null, r;
      }
      function U(m, D) {
        var t;
        return !m || !m.state || (t = m.state, !(t.wrap & 2)) ? b : (t.head = D, D.done = !1, r);
      }
      function M(m, D) {
        var t = D.length, B, K, e;
        return !m || !m.state || (B = m.state, B.wrap !== 0 && B.mode !== j) ? b : B.mode === j && (K = 1, K = f(K, D, t, 0), K !== B.check) ? O : (e = Ge(m, D, t, t), e ? (B.mode = Ee, c) : (B.havedict = 1, r));
      }
      y.inflateReset = Oe, y.inflateReset2 = je, y.inflateResetKeep = Ue, y.inflateInit = Re, y.inflateInit2 = Pe, y.inflate = a, y.inflateEnd = F, y.inflateGetHeader = U, y.inflateSetDictionary = M, y.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(v, N, y) {
      var d = v("../utils/common"), f = 15, p = 852, o = 592, w = 0, l = 1, h = 2, x = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ], u = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ], z = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ], A = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      N.exports = function(n, s, b, O, c, g, k, S) {
        var R = S.bits, I = 0, P = 0, L = 0, G = 0, J = 0, X = 0, te = 0, V = 0, j = 0, q = 0, fe, ce, Y, se, ie, we = null, me = 0, de, $ = new d.Buf16(f + 1), ge = new d.Buf16(f + 1), pe = null, ae = 0, he, ne, xe;
        for (I = 0; I <= f; I++)
          $[I] = 0;
        for (P = 0; P < O; P++)
          $[s[b + P]]++;
        for (J = R, G = f; G >= 1 && $[G] === 0; G--)
          ;
        if (J > G && (J = G), G === 0)
          return c[g++] = 1 << 24 | 64 << 16 | 0, c[g++] = 1 << 24 | 64 << 16 | 0, S.bits = 1, 0;
        for (L = 1; L < G && $[L] === 0; L++)
          ;
        for (J < L && (J = L), V = 1, I = 1; I <= f; I++)
          if (V <<= 1, V -= $[I], V < 0)
            return -1;
        if (V > 0 && (n === w || G !== 1))
          return -1;
        for (ge[1] = 0, I = 1; I < f; I++)
          ge[I + 1] = ge[I] + $[I];
        for (P = 0; P < O; P++)
          s[b + P] !== 0 && (k[ge[s[b + P]]++] = P);
        if (n === w ? (we = pe = k, de = 19) : n === l ? (we = x, me -= 257, pe = u, ae -= 257, de = 256) : (we = z, pe = A, de = -1), q = 0, P = 0, I = L, ie = g, X = J, te = 0, Y = -1, j = 1 << J, se = j - 1, n === l && j > p || n === h && j > o)
          return 1;
        for (; ; ) {
          he = I - te, k[P] < de ? (ne = 0, xe = k[P]) : k[P] > de ? (ne = pe[ae + k[P]], xe = we[me + k[P]]) : (ne = 96, xe = 0), fe = 1 << I - te, ce = 1 << X, L = ce;
          do
            ce -= fe, c[ie + (q >> te) + ce] = he << 24 | ne << 16 | xe | 0;
          while (ce !== 0);
          for (fe = 1 << I - 1; q & fe; )
            fe >>= 1;
          if (fe !== 0 ? (q &= fe - 1, q += fe) : q = 0, P++, --$[I] === 0) {
            if (I === G)
              break;
            I = s[b + k[P]];
          }
          if (I > J && (q & se) !== Y) {
            for (te === 0 && (te = J), ie += L, X = I - te, V = 1 << X; X + te < G && (V -= $[X + te], !(V <= 0)); )
              X++, V <<= 1;
            if (j += 1 << X, n === l && j > p || n === h && j > o)
              return 1;
            Y = q & se, c[Y] = J << 24 | X << 16 | ie - g | 0;
          }
        }
        return q !== 0 && (c[ie + q] = I - te << 24 | 64 << 16 | 0), S.bits = J, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(v, N, y) {
      N.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }, {}], 52: [function(v, N, y) {
      var d = v("../utils/common"), f = 4, p = 0, o = 1, w = 2;
      function l(a) {
        for (var F = a.length; --F >= 0; )
          a[F] = 0;
      }
      var h = 0, x = 1, u = 2, z = 3, A = 258, r = 29, n = 256, s = n + 1 + r, b = 30, O = 19, c = 2 * s + 1, g = 15, k = 16, S = 7, R = 256, I = 16, P = 17, L = 18, G = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      ), J = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      ), X = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      ), te = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], V = 512, j = new Array((s + 2) * 2);
      l(j);
      var q = new Array(b * 2);
      l(q);
      var fe = new Array(V);
      l(fe);
      var ce = new Array(A - z + 1);
      l(ce);
      var Y = new Array(r);
      l(Y);
      var se = new Array(b);
      l(se);
      function ie(a, F, U, M, m) {
        this.static_tree = a, this.extra_bits = F, this.extra_base = U, this.elems = M, this.max_length = m, this.has_stree = a && a.length;
      }
      var we, me, de;
      function $(a, F) {
        this.dyn_tree = a, this.max_code = 0, this.stat_desc = F;
      }
      function ge(a) {
        return a < 256 ? fe[a] : fe[256 + (a >>> 7)];
      }
      function pe(a, F) {
        a.pending_buf[a.pending++] = F & 255, a.pending_buf[a.pending++] = F >>> 8 & 255;
      }
      function ae(a, F, U) {
        a.bi_valid > k - U ? (a.bi_buf |= F << a.bi_valid & 65535, pe(a, a.bi_buf), a.bi_buf = F >> k - a.bi_valid, a.bi_valid += U - k) : (a.bi_buf |= F << a.bi_valid & 65535, a.bi_valid += U);
      }
      function he(a, F, U) {
        ae(
          a,
          U[F * 2],
          U[F * 2 + 1]
          /*.Len*/
        );
      }
      function ne(a, F) {
        var U = 0;
        do
          U |= a & 1, a >>>= 1, U <<= 1;
        while (--F > 0);
        return U >>> 1;
      }
      function xe(a) {
        a.bi_valid === 16 ? (pe(a, a.bi_buf), a.bi_buf = 0, a.bi_valid = 0) : a.bi_valid >= 8 && (a.pending_buf[a.pending++] = a.bi_buf & 255, a.bi_buf >>= 8, a.bi_valid -= 8);
      }
      function Ae(a, F) {
        var U = F.dyn_tree, M = F.max_code, m = F.stat_desc.static_tree, D = F.stat_desc.has_stree, t = F.stat_desc.extra_bits, B = F.stat_desc.extra_base, K = F.stat_desc.max_length, e, C, T, i, _, E, H = 0;
        for (i = 0; i <= g; i++)
          a.bl_count[i] = 0;
        for (U[a.heap[a.heap_max] * 2 + 1] = 0, e = a.heap_max + 1; e < c; e++)
          C = a.heap[e], i = U[U[C * 2 + 1] * 2 + 1] + 1, i > K && (i = K, H++), U[C * 2 + 1] = i, !(C > M) && (a.bl_count[i]++, _ = 0, C >= B && (_ = t[C - B]), E = U[C * 2], a.opt_len += E * (i + _), D && (a.static_len += E * (m[C * 2 + 1] + _)));
        if (H !== 0) {
          do {
            for (i = K - 1; a.bl_count[i] === 0; )
              i--;
            a.bl_count[i]--, a.bl_count[i + 1] += 2, a.bl_count[K]--, H -= 2;
          } while (H > 0);
          for (i = K; i !== 0; i--)
            for (C = a.bl_count[i]; C !== 0; )
              T = a.heap[--e], !(T > M) && (U[T * 2 + 1] !== i && (a.opt_len += (i - U[T * 2 + 1]) * U[T * 2], U[T * 2 + 1] = i), C--);
        }
      }
      function Te(a, F, U) {
        var M = new Array(g + 1), m = 0, D, t;
        for (D = 1; D <= g; D++)
          M[D] = m = m + U[D - 1] << 1;
        for (t = 0; t <= F; t++) {
          var B = a[t * 2 + 1];
          B !== 0 && (a[t * 2] = ne(M[B]++, B));
        }
      }
      function oe() {
        var a, F, U, M, m, D = new Array(g + 1);
        for (U = 0, M = 0; M < r - 1; M++)
          for (Y[M] = U, a = 0; a < 1 << G[M]; a++)
            ce[U++] = M;
        for (ce[U - 1] = M, m = 0, M = 0; M < 16; M++)
          for (se[M] = m, a = 0; a < 1 << J[M]; a++)
            fe[m++] = M;
        for (m >>= 7; M < b; M++)
          for (se[M] = m << 7, a = 0; a < 1 << J[M] - 7; a++)
            fe[256 + m++] = M;
        for (F = 0; F <= g; F++)
          D[F] = 0;
        for (a = 0; a <= 143; )
          j[a * 2 + 1] = 8, a++, D[8]++;
        for (; a <= 255; )
          j[a * 2 + 1] = 9, a++, D[9]++;
        for (; a <= 279; )
          j[a * 2 + 1] = 7, a++, D[7]++;
        for (; a <= 287; )
          j[a * 2 + 1] = 8, a++, D[8]++;
        for (Te(j, s + 1, D), a = 0; a < b; a++)
          q[a * 2 + 1] = 5, q[a * 2] = ne(a, 5);
        we = new ie(j, G, n + 1, s, g), me = new ie(q, J, 0, b, g), de = new ie(new Array(0), X, 0, O, S);
      }
      function Ee(a) {
        var F;
        for (F = 0; F < s; F++)
          a.dyn_ltree[F * 2] = 0;
        for (F = 0; F < b; F++)
          a.dyn_dtree[F * 2] = 0;
        for (F = 0; F < O; F++)
          a.bl_tree[F * 2] = 0;
        a.dyn_ltree[R * 2] = 1, a.opt_len = a.static_len = 0, a.last_lit = a.matches = 0;
      }
      function We(a) {
        a.bi_valid > 8 ? pe(a, a.bi_buf) : a.bi_valid > 0 && (a.pending_buf[a.pending++] = a.bi_buf), a.bi_buf = 0, a.bi_valid = 0;
      }
      function Ie(a, F, U, M) {
        We(a), pe(a, U), pe(a, ~U), d.arraySet(a.pending_buf, a.window, F, U, a.pending), a.pending += U;
      }
      function Ce(a, F, U, M) {
        var m = F * 2, D = U * 2;
        return a[m] < a[D] || a[m] === a[D] && M[F] <= M[U];
      }
      function le(a, F, U) {
        for (var M = a.heap[U], m = U << 1; m <= a.heap_len && (m < a.heap_len && Ce(F, a.heap[m + 1], a.heap[m], a.depth) && m++, !Ce(F, M, a.heap[m], a.depth)); )
          a.heap[U] = a.heap[m], U = m, m <<= 1;
        a.heap[U] = M;
      }
      function Q(a, F, U) {
        var M, m, D = 0, t, B;
        if (a.last_lit !== 0)
          do
            M = a.pending_buf[a.d_buf + D * 2] << 8 | a.pending_buf[a.d_buf + D * 2 + 1], m = a.pending_buf[a.l_buf + D], D++, M === 0 ? he(a, m, F) : (t = ce[m], he(a, t + n + 1, F), B = G[t], B !== 0 && (m -= Y[t], ae(a, m, B)), M--, t = ge(M), he(a, t, U), B = J[t], B !== 0 && (M -= se[t], ae(a, M, B)));
          while (D < a.last_lit);
        he(a, R, F);
      }
      function ze(a, F) {
        var U = F.dyn_tree, M = F.stat_desc.static_tree, m = F.stat_desc.has_stree, D = F.stat_desc.elems, t, B, K = -1, e;
        for (a.heap_len = 0, a.heap_max = c, t = 0; t < D; t++)
          U[t * 2] !== 0 ? (a.heap[++a.heap_len] = K = t, a.depth[t] = 0) : U[t * 2 + 1] = 0;
        for (; a.heap_len < 2; )
          e = a.heap[++a.heap_len] = K < 2 ? ++K : 0, U[e * 2] = 1, a.depth[e] = 0, a.opt_len--, m && (a.static_len -= M[e * 2 + 1]);
        for (F.max_code = K, t = a.heap_len >> 1; t >= 1; t--)
          le(a, U, t);
        e = D;
        do
          t = a.heap[
            1
            /*SMALLEST*/
          ], a.heap[
            1
            /*SMALLEST*/
          ] = a.heap[a.heap_len--], le(
            a,
            U,
            1
            /*SMALLEST*/
          ), B = a.heap[
            1
            /*SMALLEST*/
          ], a.heap[--a.heap_max] = t, a.heap[--a.heap_max] = B, U[e * 2] = U[t * 2] + U[B * 2], a.depth[e] = (a.depth[t] >= a.depth[B] ? a.depth[t] : a.depth[B]) + 1, U[t * 2 + 1] = U[B * 2 + 1] = e, a.heap[
            1
            /*SMALLEST*/
          ] = e++, le(
            a,
            U,
            1
            /*SMALLEST*/
          );
        while (a.heap_len >= 2);
        a.heap[--a.heap_max] = a.heap[
          1
          /*SMALLEST*/
        ], Ae(a, F), Te(U, K, a.bl_count);
      }
      function Me(a, F, U) {
        var M, m = -1, D, t = F[0 * 2 + 1], B = 0, K = 7, e = 4;
        for (t === 0 && (K = 138, e = 3), F[(U + 1) * 2 + 1] = 65535, M = 0; M <= U; M++)
          D = t, t = F[(M + 1) * 2 + 1], !(++B < K && D === t) && (B < e ? a.bl_tree[D * 2] += B : D !== 0 ? (D !== m && a.bl_tree[D * 2]++, a.bl_tree[I * 2]++) : B <= 10 ? a.bl_tree[P * 2]++ : a.bl_tree[L * 2]++, B = 0, m = D, t === 0 ? (K = 138, e = 3) : D === t ? (K = 6, e = 3) : (K = 7, e = 4));
      }
      function Ue(a, F, U) {
        var M, m = -1, D, t = F[0 * 2 + 1], B = 0, K = 7, e = 4;
        for (t === 0 && (K = 138, e = 3), M = 0; M <= U; M++)
          if (D = t, t = F[(M + 1) * 2 + 1], !(++B < K && D === t)) {
            if (B < e)
              do
                he(a, D, a.bl_tree);
              while (--B !== 0);
            else D !== 0 ? (D !== m && (he(a, D, a.bl_tree), B--), he(a, I, a.bl_tree), ae(a, B - 3, 2)) : B <= 10 ? (he(a, P, a.bl_tree), ae(a, B - 3, 3)) : (he(a, L, a.bl_tree), ae(a, B - 11, 7));
            B = 0, m = D, t === 0 ? (K = 138, e = 3) : D === t ? (K = 6, e = 3) : (K = 7, e = 4);
          }
      }
      function Oe(a) {
        var F;
        for (Me(a, a.dyn_ltree, a.l_desc.max_code), Me(a, a.dyn_dtree, a.d_desc.max_code), ze(a, a.bl_desc), F = O - 1; F >= 3 && a.bl_tree[te[F] * 2 + 1] === 0; F--)
          ;
        return a.opt_len += 3 * (F + 1) + 5 + 5 + 4, F;
      }
      function je(a, F, U, M) {
        var m;
        for (ae(a, F - 257, 5), ae(a, U - 1, 5), ae(a, M - 4, 4), m = 0; m < M; m++)
          ae(a, a.bl_tree[te[m] * 2 + 1], 3);
        Ue(a, a.dyn_ltree, F - 1), Ue(a, a.dyn_dtree, U - 1);
      }
      function Pe(a) {
        var F = 4093624447, U;
        for (U = 0; U <= 31; U++, F >>>= 1)
          if (F & 1 && a.dyn_ltree[U * 2] !== 0)
            return p;
        if (a.dyn_ltree[9 * 2] !== 0 || a.dyn_ltree[10 * 2] !== 0 || a.dyn_ltree[13 * 2] !== 0)
          return o;
        for (U = 32; U < n; U++)
          if (a.dyn_ltree[U * 2] !== 0)
            return o;
        return p;
      }
      var Re = !1;
      function He(a) {
        Re || (oe(), Re = !0), a.l_desc = new $(a.dyn_ltree, we), a.d_desc = new $(a.dyn_dtree, me), a.bl_desc = new $(a.bl_tree, de), a.bi_buf = 0, a.bi_valid = 0, Ee(a);
      }
      function Ze(a, F, U, M) {
        ae(a, (h << 1) + (M ? 1 : 0), 3), Ie(a, F, U);
      }
      function ye(a) {
        ae(a, x << 1, 3), he(a, R, j), xe(a);
      }
      function Fe(a, F, U, M) {
        var m, D, t = 0;
        a.level > 0 ? (a.strm.data_type === w && (a.strm.data_type = Pe(a)), ze(a, a.l_desc), ze(a, a.d_desc), t = Oe(a), m = a.opt_len + 3 + 7 >>> 3, D = a.static_len + 3 + 7 >>> 3, D <= m && (m = D)) : m = D = U + 5, U + 4 <= m && F !== -1 ? Ze(a, F, U, M) : a.strategy === f || D === m ? (ae(a, (x << 1) + (M ? 1 : 0), 3), Q(a, j, q)) : (ae(a, (u << 1) + (M ? 1 : 0), 3), je(a, a.l_desc.max_code + 1, a.d_desc.max_code + 1, t + 1), Q(a, a.dyn_ltree, a.dyn_dtree)), Ee(a), M && We(a);
      }
      function Ge(a, F, U) {
        return a.pending_buf[a.d_buf + a.last_lit * 2] = F >>> 8 & 255, a.pending_buf[a.d_buf + a.last_lit * 2 + 1] = F & 255, a.pending_buf[a.l_buf + a.last_lit] = U & 255, a.last_lit++, F === 0 ? a.dyn_ltree[U * 2]++ : (a.matches++, F--, a.dyn_ltree[(ce[U] + n + 1) * 2]++, a.dyn_dtree[ge(F) * 2]++), a.last_lit === a.lit_bufsize - 1;
      }
      y._tr_init = He, y._tr_stored_block = Ze, y._tr_flush_block = Fe, y._tr_tally = Ge, y._tr_align = ye;
    }, { "../utils/common": 41 }], 53: [function(v, N, y) {
      function d() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
      N.exports = d;
    }, {}], 54: [function(v, N, y) {
      (function(d) {
        (function(f, p) {
          if (f.setImmediate)
            return;
          var o = 1, w = {}, l = !1, h = f.document, x;
          function u(S) {
            typeof S != "function" && (S = new Function("" + S));
            for (var R = new Array(arguments.length - 1), I = 0; I < R.length; I++)
              R[I] = arguments[I + 1];
            var P = { callback: S, args: R };
            return w[o] = P, x(o), o++;
          }
          function z(S) {
            delete w[S];
          }
          function A(S) {
            var R = S.callback, I = S.args;
            switch (I.length) {
              case 0:
                R();
                break;
              case 1:
                R(I[0]);
                break;
              case 2:
                R(I[0], I[1]);
                break;
              case 3:
                R(I[0], I[1], I[2]);
                break;
              default:
                R.apply(p, I);
                break;
            }
          }
          function r(S) {
            if (l)
              setTimeout(r, 0, S);
            else {
              var R = w[S];
              if (R) {
                l = !0;
                try {
                  A(R);
                } finally {
                  z(S), l = !1;
                }
              }
            }
          }
          function n() {
            x = function(S) {
              process.nextTick(function() {
                r(S);
              });
            };
          }
          function s() {
            if (f.postMessage && !f.importScripts) {
              var S = !0, R = f.onmessage;
              return f.onmessage = function() {
                S = !1;
              }, f.postMessage("", "*"), f.onmessage = R, S;
            }
          }
          function b() {
            var S = "setImmediate$" + Math.random() + "$", R = function(I) {
              I.source === f && typeof I.data == "string" && I.data.indexOf(S) === 0 && r(+I.data.slice(S.length));
            };
            f.addEventListener ? f.addEventListener("message", R, !1) : f.attachEvent("onmessage", R), x = function(I) {
              f.postMessage(S + I, "*");
            };
          }
          function O() {
            var S = new MessageChannel();
            S.port1.onmessage = function(R) {
              var I = R.data;
              r(I);
            }, x = function(R) {
              S.port2.postMessage(R);
            };
          }
          function c() {
            var S = h.documentElement;
            x = function(R) {
              var I = h.createElement("script");
              I.onreadystatechange = function() {
                r(R), I.onreadystatechange = null, S.removeChild(I), I = null;
              }, S.appendChild(I);
            };
          }
          function g() {
            x = function(S) {
              setTimeout(r, 0, S);
            };
          }
          var k = Object.getPrototypeOf && Object.getPrototypeOf(f);
          k = k && k.setTimeout ? k : f, {}.toString.call(f.process) === "[object process]" ? n() : s() ? b() : f.MessageChannel ? O() : h && "onreadystatechange" in h.createElement("script") ? c() : g(), k.setImmediate = u, k.clearImmediate = z;
        })(typeof self > "u" ? typeof d > "u" ? this : d : self);
      }).call(this, typeof Xe < "u" ? Xe : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Qe);
var et = Qe.exports;
const at = /* @__PURE__ */ qe(et);
export {
  at as default
};
//# sourceMappingURL=jszip.mjs.map
