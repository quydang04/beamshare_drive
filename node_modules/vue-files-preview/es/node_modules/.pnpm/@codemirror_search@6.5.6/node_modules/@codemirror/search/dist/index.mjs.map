{"version":3,"file":"index.mjs","sources":["../../../../../../../../../node_modules/.pnpm/@codemirror+search@6.5.6/node_modules/@codemirror/search/dist/index.js"],"sourcesContent":["import { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';\nimport elt from 'crelt';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: end };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: end };\n            else\n                this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))\n            match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length)\n                    this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\n                    (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\", value: line });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: 'center' })],\n            selection,\n        });\n        view.focus();\n    }\n    return { dom };\n}\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) &&\n                    insideWord(check, state, range.from, range.to)))\n                    return Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query)\n                    return Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n        effects: EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: view => new SearchPanel(view),\n            scrollToMatch: range => EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */\n    unquote(text) {\n        return this.literal ? text :\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\n            this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n    getCursor(state, from = 0, to) {\n        let st = state.doc ? state : EditorState.create({ doc: state });\n        if (to == null)\n            to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos) => {\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||\n            categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&\n            (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||\n                categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done)\n            cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* FindPrev.ChunkSize */;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice(findClusterBreak(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, findClusterBreak(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match) => !match[0].length ||\n        (categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||\n            categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &&\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||\n                categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m);\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next)\n        return false;\n    let selection = EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev)\n        return false;\n    let selection = EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let next = query.nextMatch(state, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes, selection, effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = getPanel(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement)\n        input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Mod-Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = elt(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = elt(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return elt(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = elt(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            elt(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\n            ...view.state.readOnly ? [] : [\n                elt(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\n            ],\n            elt(\"button\", {\n                name: \"close\",\n                onclick: () => closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\"Ã—\"])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value,\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if (runScopeHandlers(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.low(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };\n"],"names":["basicNormalize","x","SearchCursor","text","query","from","to","normalize","test","codePointAt","next","str","fromCodePoint","start","codePointSize","norm","i","pos","code","match","end","index","keep","empty","baseFlags","RegExpCursor","options","MultilineRegExpCursor","startLine","toCharEnd","skip","off","flattened","FlattenedDoc","doc","cached","flat","cachedFrom","validRegExp","source","line","createLineDialog","view","input","elt","dom","event","dialogEffect","go","state","sign","ln","cl","percent","col","pc","docLine","selection","EditorSelection","EditorView","StateEffect","dialogField","StateField","value","tr","e","f","showPanel","val","gotoLine","panel","getPanel","effects","baseTheme$1","defaultHighlightOptions","highlightConfig","Facet","combineConfig","a","b","highlightSelectionMatches","defaultTheme","matchHighlighter","matchDeco","Decoration","mainMatchDeco","insideWordBoundaries","check","CharCategory","insideWord","ViewPlugin","update","conf","sel","range","word","len","deco","part","cursor","v","selectWord","dispatch","newSel","findNextOccurrence","main","ranges","fullWord","cycled","r","selectNextOccurrence","searchedText","searchConfigFacet","configs","SearchPanel","SearchQuery","config","_","ch","other","RegExpQuery","StringQuery","st","EditorState","regexpCursor","stringCursor","QueryType","spec","stringWordTest","categorizer","buf","bufPos","charBefore","charAfter","curFrom","curTo","_result","limit","add","regexpWordTest","findClusterBreak","_from","_to","size","result","m","setSearchQuery","togglePanel","searchState","SearchState","defaultQuery","effect","createSearchPanel","matchMark","selectedMatchMark","searchHighlighter","builder","RangeSetBuilder","l","selected","searchCommand","openSearchPanel","findNext","announceMatch","selectSearchInput","findPrevious","prev","selectMatches","selectSelectionMatches","cur","replaceNext","changes","replacement","replaceAll","announceText","fallback","_a","_b","_c","_d","_e","selText","getSearchInput","searchInput","searchExtensions","closeSearchPanel","searchKeymap","phrase","button","name","onclick","content","runScopeHandlers","AnnounceMargin","Break","lineEnd","baseTheme","Prec"],"mappings":";;;AAIA,MAAMA,IAAiB,OAAO,OAAO,UAAU,aAAa,aACtD,CAAAC,MAAKA,EAAE,UAAU,MAAM,IAAI,CAAAA,MAAKA;AAKtC,MAAMC,EAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcf,YAAYC,GAAMC,GAAOC,IAAO,GAAGC,IAAKH,EAAK,QAAQI,GAAWC,GAAM;AAClE,SAAK,OAAOA,GAMZ,KAAK,QAAQ,EAAE,MAAM,GAAG,IAAI,KAI5B,KAAK,OAAO,IACZ,KAAK,UAAU,IACf,KAAK,SAAS,IACd,KAAK,YAAY,GACjB,KAAK,OAAOL,EAAK,UAAUE,GAAMC,CAAE,GACnC,KAAK,cAAcD,GACnB,KAAK,YAAYE,IAAY,CAAAN,MAAKM,EAAUP,EAAeC,CAAC,CAAC,IAAID,GACjE,KAAK,QAAQ,KAAK,UAAUI,CAAK;AAAA,EACpC;AAAA,EACD,OAAO;AACH,QAAI,KAAK,aAAa,KAAK,OAAO,QAAQ;AAGtC,UAFA,KAAK,eAAe,KAAK,OAAO,QAChC,KAAK,KAAK,QACN,KAAK,KAAK;AACV,eAAO;AACX,WAAK,YAAY,GACjB,KAAK,SAAS,KAAK,KAAK;AAAA,IAC3B;AACD,WAAOK,GAAY,KAAK,QAAQ,KAAK,SAAS;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,OAAO;AACH,WAAO,KAAK,QAAQ;AAChB,WAAK,QAAQ;AACjB,WAAO,KAAK;EACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,kBAAkB;AACd,eAAS;AACL,UAAIC,IAAO,KAAK;AAChB,UAAIA,IAAO;AACP,oBAAK,OAAO,IACL;AAEX,UAAIC,IAAMC,GAAcF,CAAI,GAAGG,IAAQ,KAAK,cAAc,KAAK;AAC/D,WAAK,aAAaC,GAAcJ,CAAI;AACpC,UAAIK,IAAO,KAAK,UAAUJ,CAAG;AAC7B,eAASK,IAAI,GAAGC,IAAMJ,KAAQG,KAAK;AAC/B,YAAIE,IAAOH,EAAK,WAAWC,CAAC,GACxBG,IAAQ,KAAK,MAAMD,GAAMD,GAAK,KAAK,YAAY,KAAK,WAAW;AACnE,YAAID,KAAKD,EAAK,SAAS,GAAG;AACtB,cAAII;AACA,wBAAK,QAAQA,GACN;AAEX;AAAA,QACH;AACD,QAAIF,KAAOJ,KAASG,IAAIL,EAAI,UAAUA,EAAI,WAAWK,CAAC,KAAKE,KACvDD;AAAA,MACP;AAAA,IACJ;AAAA,EACJ;AAAA,EACD,MAAMC,GAAMD,GAAKG,GAAK;AAClB,QAAID,IAAQ;AACZ,aAASH,IAAI,GAAGA,IAAI,KAAK,QAAQ,QAAQA,KAAK,GAAG;AAC7C,UAAIK,IAAQ,KAAK,QAAQL,CAAC,GAAGM,IAAO;AACpC,MAAI,KAAK,MAAM,WAAWD,CAAK,KAAKH,MAC5BG,KAAS,KAAK,MAAM,SAAS,IAC7BF,IAAQ,EAAE,MAAM,KAAK,QAAQH,IAAI,CAAC,GAAG,IAAII,OAGzC,KAAK,QAAQJ,CAAC,KACdM,IAAO,MAGVA,MACD,KAAK,QAAQ,OAAON,GAAG,CAAC,GACxBA,KAAK;AAAA,IAEZ;AACD,WAAI,KAAK,MAAM,WAAW,CAAC,KAAKE,MACxB,KAAK,MAAM,UAAU,IACrBC,IAAQ,EAAE,MAAMF,GAAK,IAAIG,EAAG,IAE5B,KAAK,QAAQ,KAAK,GAAGH,CAAG,IAE5BE,KAAS,KAAK,QAAQ,CAAC,KAAK,KAAKA,EAAM,MAAMA,EAAM,IAAI,KAAK,QAAQ,KAAK,WAAW,MACpFA,IAAQ,OACLA;AAAA,EACV;AACL;AACI,OAAO,SAAU,QACjBjB,EAAa,UAAU,OAAO,QAAQ,IAAI,WAAY;AAAE,SAAO;;AAEnE,MAAMqB,KAAQ,EAAE,MAAM,IAAI,IAAI,IAAI,OAAoB,qBAAK,KAAK,EAAE,EAAC,GAC7DC,IAAY,QAAQ,IAAI,WAAW,OAAO,KAAK;AAMrD,MAAMC,GAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMf,YAAYtB,GAAMC,GAAOsB,GAASrB,IAAO,GAAGC,IAAKH,EAAK,QAAQ;AAe1D,QAdA,KAAK,OAAOA,GACZ,KAAK,KAAKG,GACV,KAAK,UAAU,IAKf,KAAK,OAAO,IAMZ,KAAK,QAAQiB,IACT,uBAAuB,KAAKnB,CAAK;AACjC,aAAO,IAAIuB,GAAsBxB,GAAMC,GAAOsB,GAASrB,GAAMC,CAAE;AACnE,SAAK,KAAK,IAAI,OAAOF,GAAOoB,KAAcE,KAAY,QAAsCA,EAAQ,aAAc,MAAM,GAAG,GAC3H,KAAK,OAAOA,KAAY,OAA6B,SAASA,EAAQ,MACtE,KAAK,OAAOvB,EAAK;AACjB,QAAIyB,IAAYzB,EAAK,OAAOE,CAAI;AAChC,SAAK,eAAeuB,EAAU,MAC9B,KAAK,WAAWC,EAAU1B,GAAME,CAAI,GACpC,KAAK,QAAQ,KAAK,YAAY;AAAA,EACjC;AAAA,EACD,QAAQyB,GAAM;AACV,SAAK,KAAK,KAAKA,CAAI,GACf,KAAK,KAAK,YACV,KAAK,UAAU,MAGf,KAAK,UAAU,KAAK,KAAK,OACrB,KAAK,eAAe,KAAK,QAAQ,SAAS,KAAK,OAC/C,KAAK,UAAU,KAAK,QAAQ,MAAM,GAAG,KAAK,KAAK,KAAK,YAAY,IACpE,KAAK,KAAK;EAEjB;AAAA,EACD,WAAW;AACP,SAAK,eAAe,KAAK,eAAe,KAAK,QAAQ,SAAS,GAC1D,KAAK,eAAe,KAAK,KACzB,KAAK,UAAU,KAEf,KAAK,QAAQ,CAAC;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAID,OAAO;AACH,aAASC,IAAM,KAAK,WAAW,KAAK,kBAAgB;AAChD,WAAK,GAAG,YAAYA;AACpB,UAAIZ,IAAQ,KAAK,YAAY,KAAK,MAAM,KAAK,GAAG,KAAK,KAAK,OAAO;AACjE,UAAIA,GAAO;AACP,YAAId,IAAO,KAAK,eAAec,EAAM,OAAOb,IAAKD,IAAOc,EAAM,CAAC,EAAE;AAIjE,YAHA,KAAK,WAAWU,EAAU,KAAK,MAAMvB,KAAMD,KAAQC,IAAK,IAAI,EAAE,GAC1DD,KAAQ,KAAK,eAAe,KAAK,QAAQ,UACzC,KAAK,SAAQ,IACZA,IAAOC,KAAMD,IAAO,KAAK,MAAM,QAAQ,CAAC,KAAK,QAAQ,KAAK,KAAKA,GAAMC,GAAIa,CAAK;AAC/E,sBAAK,QAAQ,EAAE,MAAAd,GAAM,IAAAC,GAAI,OAAAa,EAAK,GACvB;AAEX,QAAAY,IAAM,KAAK,WAAW,KAAK;AAAA,MAC9B,WACQ,KAAK,eAAe,KAAK,QAAQ,SAAS,KAAK;AACpD,aAAK,SAAQ,GACbA,IAAM;AAAA;AAGN,oBAAK,OAAO,IACL;AAAA,IAEd;AAAA,EACJ;AACL;AACA,MAAMC,IAAyB,oBAAI;AAEnC,MAAMC,EAAa;AAAA,EACf,YAAY5B,GAAMF,GAAM;AACpB,SAAK,OAAOE,GACZ,KAAK,OAAOF;AAAA,EACf;AAAA,EACD,IAAI,KAAK;AAAE,WAAO,KAAK,OAAO,KAAK,KAAK;AAAA,EAAS;AAAA,EACjD,OAAO,IAAI+B,GAAK7B,GAAMC,GAAI;AACtB,QAAI6B,IAASH,EAAU,IAAIE,CAAG;AAC9B,QAAI,CAACC,KAAUA,EAAO,QAAQ7B,KAAM6B,EAAO,MAAM9B,GAAM;AACnD,UAAI+B,IAAO,IAAIH,EAAa5B,GAAM6B,EAAI,YAAY7B,GAAMC,CAAE,CAAC;AAC3D,aAAA0B,EAAU,IAAIE,GAAKE,CAAI,GAChBA;AAAA,IACV;AACD,QAAID,EAAO,QAAQ9B,KAAQ8B,EAAO,MAAM7B;AACpC,aAAO6B;AACX,QAAI,EAAE,MAAAhC,GAAM,MAAMkC,EAAU,IAAKF;AACjC,WAAIE,IAAahC,MACbF,IAAO+B,EAAI,YAAY7B,GAAMgC,CAAU,IAAIlC,GAC3CkC,IAAahC,IAEb8B,EAAO,KAAK7B,MACZH,KAAQ+B,EAAI,YAAYC,EAAO,IAAI7B,CAAE,IACzC0B,EAAU,IAAIE,GAAK,IAAID,EAAaI,GAAYlC,CAAI,CAAC,GAC9C,IAAI8B,EAAa5B,GAAMF,EAAK,MAAME,IAAOgC,GAAY/B,IAAK+B,CAAU,CAAC;AAAA,EAC/E;AACL;AACA,MAAMV,GAAsB;AAAA,EACxB,YAAYxB,GAAMC,GAAOsB,GAASrB,GAAMC,GAAI;AACxC,SAAK,OAAOH,GACZ,KAAK,KAAKG,GACV,KAAK,OAAO,IACZ,KAAK,QAAQiB,IACb,KAAK,WAAWM,EAAU1B,GAAME,CAAI,GACpC,KAAK,KAAK,IAAI,OAAOD,GAAOoB,KAAcE,KAAY,QAAsCA,EAAQ,aAAc,MAAM,GAAG,GAC3H,KAAK,OAAOA,KAAY,OAA6B,SAASA,EAAQ,MACtE,KAAK,OAAOO,EAAa,IAAI9B,GAAME,GAAM,KAAK;AAAA,MAASA,IAAO;AAAA;AAAA,IAAsB,CAAA;AAAA,EACvF;AAAA,EACD,SAASY,GAAK;AACV,WAAOA,KAAO,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,OAAOA,CAAG,EAAE;AAAA,EAC3D;AAAA,EACD,OAAO;AACH,eAAS;AACL,UAAIc,IAAM,KAAK,GAAG,YAAY,KAAK,WAAW,KAAK,KAAK,MACpDZ,IAAQ,KAAK,GAAG,KAAK,KAAK,KAAK,IAAI;AAMvC,UAJIA,KAAS,CAACA,EAAM,CAAC,KAAKA,EAAM,SAASY,MACrC,KAAK,GAAG,YAAYA,IAAM,GAC1BZ,IAAQ,KAAK,GAAG,KAAK,KAAK,KAAK,IAAI,IAEnCA,GAAO;AACP,YAAId,IAAO,KAAK,KAAK,OAAOc,EAAM,OAAOb,IAAKD,IAAOc,EAAM,CAAC,EAAE;AAG9D,aAAK,KAAK,KAAK,MAAM,KAAK,MAAMA,EAAM,QAAQA,EAAM,CAAC,EAAE,UAAU,KAAK,KAAK,KAAK,SAAS,QACpF,CAAC,KAAK,QAAQ,KAAK,KAAKd,GAAMC,GAAIa,CAAK;AACxC,sBAAK,QAAQ,EAAE,MAAAd,GAAM,IAAAC,GAAI,OAAAa,EAAK,GAC9B,KAAK,WAAWU,EAAU,KAAK,MAAMvB,KAAMD,KAAQC,IAAK,IAAI,EAAE,GACvD;AAAA,MAEd;AACD,UAAI,KAAK,KAAK,MAAM,KAAK;AACrB,oBAAK,OAAO,IACL;AAGX,WAAK,OAAO2B,EAAa,IAAI,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,SAAS,KAAK,KAAK,OAAO,KAAK,KAAK,KAAK,SAAS,CAAC,CAAC;AAAA,IACpH;AAAA,EACJ;AACL;AACI,OAAO,SAAU,QACjBR,GAAa,UAAU,OAAO,QAAQ,IAAIE,GAAsB,UAAU,OAAO,QAAQ,IACrF,WAAY;AAAE,SAAO;;AAE7B,SAASW,GAAYC,GAAQ;AACzB,MAAI;AACA,eAAI,OAAOA,GAAQf,CAAS,GACrB;AAAA,EACV,QACU;AACP,WAAO;AAAA,EACV;AACL;AACA,SAASK,EAAU1B,GAAMc,GAAK;AAC1B,MAAIA,KAAOd,EAAK;AACZ,WAAOc;AACX,MAAIuB,IAAOrC,EAAK,OAAOc,CAAG,GAAGP;AAC7B,SAAOO,IAAMuB,EAAK,OAAO9B,IAAO8B,EAAK,KAAK,WAAWvB,IAAMuB,EAAK,IAAI,MAAM,SAAU9B,IAAO;AACvF,IAAAO;AACJ,SAAOA;AACX;AAEA,SAASwB,EAAiBC,GAAM;AAC5B,MAAIF,IAAO,OAAOE,EAAK,MAAM,IAAI,OAAOA,EAAK,MAAM,UAAU,KAAK,IAAI,EAAE,MAAM,GAC1EC,IAAQC,EAAI,SAAS,EAAE,OAAO,gBAAgB,MAAM,QAAQ,OAAOJ,EAAM,CAAA,GACzEK,IAAMD,EAAI,QAAQ;AAAA,IAClB,OAAO;AAAA,IACP,WAAW,CAACE,MAAU;AAClB,MAAIA,EAAM,WAAW,MACjBA,EAAM,eAAc,GACpBJ,EAAK,SAAS,EAAE,SAASK,EAAa,GAAG,EAAK,EAAC,CAAE,GACjDL,EAAK,MAAK,KAELI,EAAM,WAAW,OACtBA,EAAM,eAAc,GACpBE;IAEP;AAAA,IACD,UAAU,CAACF,MAAU;AACjB,MAAAA,EAAM,eAAc,GACpBE;IACH;AAAA,EACJ,GAAEJ,EAAI,SAASF,EAAK,MAAM,OAAO,YAAY,GAAG,MAAMC,CAAK,GAAG,KAAKC,EAAI,UAAU,EAAE,OAAO,aAAa,MAAM,SAAQ,GAAIF,EAAK,MAAM,OAAO,IAAI,CAAC,CAAC;AAClJ,WAASM,IAAK;AACV,QAAI7B,IAAQ,6BAA6B,KAAKwB,EAAM,KAAK;AACzD,QAAI,CAACxB;AACD;AACJ,QAAI,EAAE,OAAA8B,EAAK,IAAKP,GAAMd,IAAYqB,EAAM,IAAI,OAAOA,EAAM,UAAU,KAAK,IAAI,GACxE,CAAA,EAAGC,GAAMC,GAAIC,GAAIC,CAAO,IAAIlC,GAC5BmC,IAAMF,IAAK,CAACA,EAAG,MAAM,CAAC,IAAI,GAC1BZ,IAAOW,IAAK,CAACA,IAAKvB,EAAU;AAChC,QAAIuB,KAAME,GAAS;AACf,UAAIE,IAAKf,IAAO;AAChB,MAAIU,MACAK,IAAKA,KAAML,KAAQ,MAAM,KAAK,KAAMtB,EAAU,SAASqB,EAAM,IAAI,QACrET,IAAO,KAAK,MAAMS,EAAM,IAAI,QAAQM,CAAE;AAAA,IACzC,MACI,CAAIJ,KAAMD,MACXV,IAAOA,KAAQU,KAAQ,MAAM,KAAK,KAAKtB,EAAU;AAErD,QAAI4B,IAAUP,EAAM,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAIA,EAAM,IAAI,OAAOT,CAAI,CAAC,CAAC,GACrEiB,IAAYC,EAAgB,OAAOF,EAAQ,OAAO,KAAK,IAAI,GAAG,KAAK,IAAIF,GAAKE,EAAQ,MAAM,CAAC,CAAC;AAChG,IAAAd,EAAK,SAAS;AAAA,MACV,SAAS,CAACK,EAAa,GAAG,EAAK,GAAGY,EAAW,eAAeF,EAAU,MAAM,EAAE,GAAG,SAAU,CAAA,CAAC;AAAA,MAC5F,WAAAA;AAAA,IACZ,CAAS,GACDf,EAAK,MAAK;AAAA,EACb;AACD,SAAO,EAAE,KAAAG,EAAG;AAChB;AACA,MAAME,IAA4B,gBAAAa,EAAY,UACxCC,IAA2B,gBAAAC,GAAW,OAAO;AAAA,EAC/C,SAAS;AAAE,WAAO;AAAA,EAAO;AAAA,EACzB,OAAOC,GAAOC,GAAI;AACd,aAASC,KAAKD,EAAG;AACb,MAAIC,EAAE,GAAGlB,CAAY,MACjBgB,IAAQE,EAAE;AAClB,WAAOF;AAAA,EACV;AAAA,EACD,SAAS,CAAAG,MAAKC,GAAU,KAAKD,GAAG,CAAAE,MAAOA,IAAM3B,IAAmB,IAAI;AACxE,CAAC,GAUK4B,KAAW,CAAA3B,MAAQ;AACrB,MAAI4B,IAAQC,EAAS7B,GAAMD,CAAgB;AAC3C,MAAI,CAAC6B,GAAO;AACR,QAAIE,IAAU,CAACzB,EAAa,GAAG,EAAI,CAAC;AACpC,IAAIL,EAAK,MAAM,MAAMmB,GAAa,EAAK,KAAK,QACxCW,EAAQ,KAAKZ,EAAY,aAAa,GAAG,CAACC,GAAaY,EAAW,CAAC,CAAC,GACxE/B,EAAK,SAAS,EAAE,SAAA8B,EAAO,CAAE,GACzBF,IAAQC,EAAS7B,GAAMD,CAAgB;AAAA,EAC1C;AACD,SAAI6B,KACAA,EAAM,IAAI,cAAc,OAAO,EAAE,OAAM,GACpC;AACX,GACMG,KAA2B,gBAAAd,EAAW,UAAU;AAAA,EAClD,yBAAyB;AAAA,IACrB,SAAS;AAAA,IACT,WAAW,EAAE,UAAU,MAAO;AAAA,EACjC;AACL,CAAC,GAEKe,KAA0B;AAAA,EAC5B,2BAA2B;AAAA,EAC3B,oBAAoB;AAAA,EACpB,YAAY;AAAA,EACZ,YAAY;AAChB,GACMC,KAA+B,gBAAAC,GAAM,OAAO;AAAA,EAC9C,QAAQlD,GAAS;AACb,WAAOmD,GAAcnD,GAASgD,IAAyB;AAAA,MACnD,2BAA2B,CAACI,GAAGC,MAAMD,KAAKC;AAAA,MAC1C,oBAAoB,KAAK;AAAA,MACzB,YAAY,KAAK;AAAA,IAC7B,CAAS;AAAA,EACJ;AACL,CAAC;AAOD,SAASC,GAA0BtD,GAAS;AAIxC,SAHU,CAACuD,IAAcC,EAAgB;AAI7C;AACA,MAAMC,KAAyB,gBAAAC,EAAW,KAAK,EAAE,OAAO,oBAAqB,CAAA,GACvEC,KAA6B,gBAAAD,EAAW,KAAK,EAAE,OAAO,2CAA4C,CAAA;AAExG,SAASE,EAAqBC,GAAOtC,GAAO5C,GAAMC,GAAI;AAClD,UAAQD,KAAQ,KAAKkF,EAAMtC,EAAM,SAAS5C,IAAO,GAAGA,CAAI,CAAC,KAAKmF,EAAa,UACtElF,KAAM2C,EAAM,IAAI,UAAUsC,EAAMtC,EAAM,SAAS3C,GAAIA,IAAK,CAAC,CAAC,KAAKkF,EAAa;AACrF;AAEA,SAASC,GAAWF,GAAOtC,GAAO5C,GAAMC,GAAI;AACxC,SAAOiF,EAAMtC,EAAM,SAAS5C,GAAMA,IAAO,CAAC,CAAC,KAAKmF,EAAa,QACtDD,EAAMtC,EAAM,SAAS3C,IAAK,GAAGA,CAAE,CAAC,KAAKkF,EAAa;AAC7D;AACA,MAAMN,KAAgC,gBAAAQ,EAAW,UAAU,MAAM;AAAA,EAC7D,YAAYhD,GAAM;AACd,SAAK,cAAc,KAAK,QAAQA,CAAI;AAAA,EACvC;AAAA,EACD,OAAOiD,GAAQ;AACX,KAAIA,EAAO,gBAAgBA,EAAO,cAAcA,EAAO,qBACnD,KAAK,cAAc,KAAK,QAAQA,EAAO,IAAI;AAAA,EAClD;AAAA,EACD,QAAQjD,GAAM;AACV,QAAIkD,IAAOlD,EAAK,MAAM,MAAMiC,EAAe,GACvC,EAAE,OAAA1B,EAAK,IAAKP,GAAMmD,IAAM5C,EAAM;AAClC,QAAI4C,EAAI,OAAO,SAAS;AACpB,aAAOT,EAAW;AACtB,QAAIU,IAAQD,EAAI,MAAMzF,GAAOmF,IAAQ;AACrC,QAAIO,EAAM,OAAO;AACb,UAAI,CAACF,EAAK;AACN,eAAOR,EAAW;AACtB,UAAIW,IAAO9C,EAAM,OAAO6C,EAAM,IAAI;AAClC,UAAI,CAACC;AACD,eAAOX,EAAW;AACtB,MAAAG,IAAQtC,EAAM,gBAAgB6C,EAAM,IAAI,GACxC1F,IAAQ6C,EAAM,SAAS8C,EAAK,MAAMA,EAAK,EAAE;AAAA,IAC5C,OACI;AACD,UAAIC,IAAMF,EAAM,KAAKA,EAAM;AAC3B,UAAIE,IAAMJ,EAAK,sBAAsBI,IAAM;AACvC,eAAOZ,EAAW;AACtB,UAAIQ,EAAK;AAGL,YAFAxF,IAAQ6C,EAAM,SAAS6C,EAAM,MAAMA,EAAM,EAAE,GAC3CP,IAAQtC,EAAM,gBAAgB6C,EAAM,IAAI,GACpC,EAAER,EAAqBC,GAAOtC,GAAO6C,EAAM,MAAMA,EAAM,EAAE,KACzDL,GAAWF,GAAOtC,GAAO6C,EAAM,MAAMA,EAAM,EAAE;AAC7C,iBAAOV,EAAW;AAAA,iBAGtBhF,IAAQ6C,EAAM,SAAS6C,EAAM,MAAMA,EAAM,EAAE,GACvC,CAAC1F;AACD,eAAOgF,EAAW;AAAA,IAE7B;AACD,QAAIa,IAAO,CAAA;AACX,aAASC,KAAQxD,EAAK,eAAe;AACjC,UAAIyD,IAAS,IAAIjG,EAAa+C,EAAM,KAAK7C,GAAO8F,EAAK,MAAMA,EAAK,EAAE;AAClE,aAAO,CAACC,EAAO,KAAM,EAAC,QAAM;AACxB,YAAI,EAAE,MAAA9F,GAAM,IAAAC,MAAO6F,EAAO;AAC1B,aAAI,CAACZ,KAASD,EAAqBC,GAAOtC,GAAO5C,GAAMC,CAAE,OACjDwF,EAAM,SAASzF,KAAQyF,EAAM,QAAQxF,KAAMwF,EAAM,KACjDG,EAAK,KAAKZ,GAAc,MAAMhF,GAAMC,CAAE,CAAC,KAClCD,KAAQyF,EAAM,MAAMxF,KAAMwF,EAAM,SACrCG,EAAK,KAAKd,GAAU,MAAM9E,GAAMC,CAAE,CAAC,GACnC2F,EAAK,SAASL,EAAK;AACnB,iBAAOR,EAAW;AAAA,MAE7B;AAAA,IACJ;AACD,WAAOA,EAAW,IAAIa,CAAI;AAAA,EAC7B;AACL,GAAG;AAAA,EACC,aAAa,CAAAG,MAAKA,EAAE;AACxB,CAAC,GACKnB,KAA4B,gBAAAtB,EAAW,UAAU;AAAA,EACnD,sBAAsB,EAAE,iBAAiB,YAAa;AAAA,EACtD,sCAAsC,EAAE,iBAAiB,cAAe;AAC5E,CAAC,GAEK0C,KAAa,CAAC,EAAE,OAAApD,GAAO,UAAAqD,QAAe;AACxC,MAAI,EAAE,WAAA7C,EAAW,IAAGR,GAChBsD,IAAS7C,EAAgB,OAAOD,EAAU,OAAO,IAAI,CAAAqC,MAAS7C,EAAM,OAAO6C,EAAM,IAAI,KAAKpC,EAAgB,OAAOoC,EAAM,IAAI,CAAC,GAAGrC,EAAU,SAAS;AACtJ,SAAI8C,EAAO,GAAG9C,CAAS,IACZ,MACX6C,EAASrD,EAAM,OAAO,EAAE,WAAWsD,EAAQ,CAAA,CAAC,GACrC;AACX;AAGA,SAASC,GAAmBvD,GAAO7C,GAAO;AACtC,MAAI,EAAE,MAAAqG,GAAM,QAAAC,MAAWzD,EAAM,WACzB8C,IAAO9C,EAAM,OAAOwD,EAAK,IAAI,GAAGE,IAAWZ,KAAQA,EAAK,QAAQU,EAAK,QAAQV,EAAK,MAAMU,EAAK;AACjG,WAASG,IAAS,IAAOT,IAAS,IAAIjG,EAAa+C,EAAM,KAAK7C,GAAOsG,EAAOA,EAAO,SAAS,CAAC,EAAE,EAAE;AAE7F,QADAP,EAAO,KAAI,GACPA,EAAO,MAAM;AACb,UAAIS;AACA,eAAO;AACX,MAAAT,IAAS,IAAIjG,EAAa+C,EAAM,KAAK7C,GAAO,GAAG,KAAK,IAAI,GAAGsG,EAAOA,EAAO,SAAS,CAAC,EAAE,OAAO,CAAC,CAAC,GAC9FE,IAAS;AAAA,IACZ,OACI;AACD,UAAIA,KAAUF,EAAO,KAAK,CAAAG,MAAKA,EAAE,QAAQV,EAAO,MAAM,IAAI;AACtD;AACJ,UAAIQ,GAAU;AACV,YAAIZ,IAAO9C,EAAM,OAAOkD,EAAO,MAAM,IAAI;AACzC,YAAI,CAACJ,KAAQA,EAAK,QAAQI,EAAO,MAAM,QAAQJ,EAAK,MAAMI,EAAO,MAAM;AACnE;AAAA,MACP;AACD,aAAOA,EAAO;AAAA,IACjB;AAET;AAKK,MAACW,KAAuB,CAAC,EAAE,OAAA7D,GAAO,UAAAqD,QAAe;AAClD,MAAI,EAAE,QAAAI,EAAM,IAAKzD,EAAM;AACvB,MAAIyD,EAAO,KAAK,CAAAb,MAAOA,EAAI,SAASA,EAAI,EAAE;AACtC,WAAOQ,GAAW,EAAE,OAAApD,GAAO,UAAAqD,EAAU,CAAA;AACzC,MAAIS,IAAe9D,EAAM,SAASyD,EAAO,CAAC,EAAE,MAAMA,EAAO,CAAC,EAAE,EAAE;AAC9D,MAAIzD,EAAM,UAAU,OAAO,KAAK,CAAA4D,MAAK5D,EAAM,SAAS4D,EAAE,MAAMA,EAAE,EAAE,KAAKE,CAAY;AAC7E,WAAO;AACX,MAAIjB,IAAQU,GAAmBvD,GAAO8D,CAAY;AAClD,SAAKjB,KAELQ,EAASrD,EAAM,OAAO;AAAA,IAClB,WAAWA,EAAM,UAAU,SAASS,EAAgB,MAAMoC,EAAM,MAAMA,EAAM,EAAE,GAAG,EAAK;AAAA,IACtF,SAASnC,EAAW,eAAemC,EAAM,EAAE;AAAA,EAC9C,CAAA,CAAC,GACK,MALI;AAMf,GAEMkB,IAAiC,gBAAApC,GAAM,OAAO;AAAA,EAChD,QAAQqC,GAAS;AACb,WAAOpC,GAAcoC,GAAS;AAAA,MAC1B,KAAK;AAAA,MACL,eAAe;AAAA,MACf,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,aAAa,CAAAvE,MAAQ,IAAIwE,GAAYxE,CAAI;AAAA,MACzC,eAAe,CAAAoD,MAASnC,EAAW,eAAemC,CAAK;AAAA,IACnE,CAAS;AAAA,EACJ;AACL,CAAC;AAaD,MAAMqB,GAAY;AAAA;AAAA;AAAA;AAAA,EAId,YAAYC,GAAQ;AAChB,SAAK,SAASA,EAAO,QACrB,KAAK,gBAAgB,CAAC,CAACA,EAAO,eAC9B,KAAK,UAAU,CAAC,CAACA,EAAO,SACxB,KAAK,SAAS,CAAC,CAACA,EAAO,QACvB,KAAK,UAAUA,EAAO,WAAW,IACjC,KAAK,QAAQ,CAAC,CAAC,KAAK,WAAW,CAAC,KAAK,UAAU9E,GAAY,KAAK,MAAM,IACtE,KAAK,WAAW,KAAK,QAAQ,KAAK,MAAM,GACxC,KAAK,YAAY,CAAC,CAAC8E,EAAO;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAID,QAAQjH,GAAM;AACV,WAAO,KAAK,UAAUA,IAClBA,EAAK,QAAQ,gBAAgB,CAACkH,GAAGC,MAAOA,KAAM,MAAM;AAAA,IAAOA,KAAM,MAAM,OAAOA,KAAM,MAAM,MAAO,IAAI;AAAA,EAC5G;AAAA;AAAA;AAAA;AAAA,EAID,GAAGC,GAAO;AACN,WAAO,KAAK,UAAUA,EAAM,UAAU,KAAK,WAAWA,EAAM,WACxD,KAAK,iBAAiBA,EAAM,iBAAiB,KAAK,UAAUA,EAAM,UAClE,KAAK,aAAaA,EAAM;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAID,SAAS;AACL,WAAO,KAAK,SAAS,IAAIC,GAAY,IAAI,IAAI,IAAIC,GAAY,IAAI;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA,EAKD,UAAUxE,GAAO5C,IAAO,GAAGC,GAAI;AAC3B,QAAIoH,IAAKzE,EAAM,MAAMA,IAAQ0E,GAAY,OAAO,EAAE,KAAK1E,EAAK,CAAE;AAC9D,WAAI3C,KAAM,SACNA,IAAKoH,EAAG,IAAI,SACT,KAAK,SAASE,EAAa,MAAMF,GAAIrH,GAAMC,CAAE,IAAIuH,EAAa,MAAMH,GAAIrH,GAAMC,CAAE;AAAA,EAC1F;AACL;AACA,MAAMwH,GAAU;AAAA,EACZ,YAAYC,GAAM;AACd,SAAK,OAAOA;AAAA,EACf;AACL;AACA,SAASF,EAAaE,GAAM9E,GAAO5C,GAAMC,GAAI;AACzC,SAAO,IAAIJ,EAAa+C,EAAM,KAAK8E,EAAK,UAAU1H,GAAMC,GAAIyH,EAAK,gBAAgB,SAAY,CAAA9H,MAAKA,EAAE,eAAe8H,EAAK,YAAYC,GAAe/E,EAAM,KAAKA,EAAM,gBAAgBA,EAAM,UAAU,KAAK,IAAI,CAAC,IAAI,MAAS;AAC/N;AACA,SAAS+E,GAAe9F,GAAK+F,GAAa;AACtC,SAAO,CAAC5H,GAAMC,GAAI4H,GAAKC,QACfA,IAAS9H,KAAQ8H,IAASD,EAAI,SAAS5H,OACvC6H,IAAS,KAAK,IAAI,GAAG9H,IAAO,CAAC,GAC7B6H,IAAMhG,EAAI,YAAYiG,GAAQ,KAAK,IAAIjG,EAAI,QAAQ5B,IAAK,CAAC,CAAC,KAEtD2H,EAAYG,EAAWF,GAAK7H,IAAO8H,CAAM,CAAC,KAAK3C,EAAa,QAChEyC,EAAYI,EAAUH,GAAK7H,IAAO8H,CAAM,CAAC,KAAK3C,EAAa,UAC1DyC,EAAYI,EAAUH,GAAK5H,IAAK6H,CAAM,CAAC,KAAK3C,EAAa,QACtDyC,EAAYG,EAAWF,GAAK5H,IAAK6H,CAAM,CAAC,KAAK3C,EAAa;AAE1E;AACA,MAAMiC,WAAoBK,GAAU;AAAA,EAChC,YAAYC,GAAM;AACd,UAAMA,CAAI;AAAA,EACb;AAAA,EACD,UAAU9E,GAAOqF,GAASC,GAAO;AAC7B,QAAIpC,IAAS0B,EAAa,KAAK,MAAM5E,GAAOsF,GAAOtF,EAAM,IAAI,MAAM,EAAE,gBAAe;AACpF,WAAIkD,EAAO,SACPA,IAAS0B,EAAa,KAAK,MAAM5E,GAAO,GAAGqF,CAAO,EAAE,oBACjDnC,EAAO,OAAO,OAAOA,EAAO;AAAA,EACtC;AAAA;AAAA;AAAA,EAGD,iBAAiBlD,GAAO5C,GAAMC,GAAI;AAC9B,aAASW,IAAMX,OAAM;AACjB,UAAIO,IAAQ,KAAK,IAAIR,GAAMY,IAAM,MAAiC,KAAK,KAAK,SAAS,MAAM,GACvFkF,IAAS0B,EAAa,KAAK,MAAM5E,GAAOpC,GAAOI,CAAG,GAAG6E,IAAQ;AACjE,aAAO,CAACK,EAAO,gBAAe,EAAG;AAC7B,QAAAL,IAAQK,EAAO;AACnB,UAAIL;AACA,eAAOA;AACX,UAAIjF,KAASR;AACT,eAAO;AACX,MAAAY,KAAO;AAAA,IACV;AAAA,EACJ;AAAA,EACD,UAAUgC,GAAOqF,GAASC,GAAO;AAC7B,WAAO,KAAK,iBAAiBtF,GAAO,GAAGqF,CAAO,KAC1C,KAAK,iBAAiBrF,GAAOsF,GAAOtF,EAAM,IAAI,MAAM;AAAA,EAC3D;AAAA,EACD,eAAeuF,GAAS;AAAE,WAAO,KAAK,KAAK,QAAQ,KAAK,KAAK,OAAO;AAAA,EAAI;AAAA,EACxE,SAASvF,GAAOwF,GAAO;AACnB,QAAItC,IAAS0B,EAAa,KAAK,MAAM5E,GAAO,GAAGA,EAAM,IAAI,MAAM,GAAGyD,IAAS,CAAA;AAC3E,WAAO,CAACP,EAAO,KAAM,EAAC,QAAM;AACxB,UAAIO,EAAO,UAAU+B;AACjB,eAAO;AACX,MAAA/B,EAAO,KAAKP,EAAO,KAAK;AAAA,IAC3B;AACD,WAAOO;AAAA,EACV;AAAA,EACD,UAAUzD,GAAO5C,GAAMC,GAAIoI,GAAK;AAC5B,QAAIvC,IAAS0B,EAAa,KAAK,MAAM5E,GAAO,KAAK,IAAI,GAAG5C,IAAO,KAAK,KAAK,SAAS,MAAM,GAAG,KAAK,IAAIC,IAAK,KAAK,KAAK,SAAS,QAAQ2C,EAAM,IAAI,MAAM,CAAC;AACrJ,WAAO,CAACkD,EAAO,KAAI,EAAG;AAClB,MAAAuC,EAAIvC,EAAO,MAAM,MAAMA,EAAO,MAAM,EAAE;AAAA,EAC7C;AACL;AACA,SAASyB,EAAaG,GAAM9E,GAAO5C,GAAMC,GAAI;AACzC,SAAO,IAAImB,GAAawB,EAAM,KAAK8E,EAAK,QAAQ;AAAA,IAC5C,YAAY,CAACA,EAAK;AAAA,IAClB,MAAMA,EAAK,YAAYY,GAAe1F,EAAM,gBAAgBA,EAAM,UAAU,KAAK,IAAI,CAAC,IAAI;AAAA,EAClG,GAAO5C,GAAMC,CAAE;AACf;AACA,SAAS8H,EAAWzH,GAAKU,GAAO;AAC5B,SAAOV,EAAI,MAAMiI,GAAiBjI,GAAKU,GAAO,EAAK,GAAGA,CAAK;AAC/D;AACA,SAASgH,EAAU1H,GAAKU,GAAO;AAC3B,SAAOV,EAAI,MAAMU,GAAOuH,GAAiBjI,GAAKU,CAAK,CAAC;AACxD;AACA,SAASsH,GAAeV,GAAa;AACjC,SAAO,CAACY,GAAOC,GAAK3H,MAAU,CAACA,EAAM,CAAC,EAAE,WACnC8G,EAAYG,EAAWjH,EAAM,OAAOA,EAAM,KAAK,CAAC,KAAKqE,EAAa,QAC/DyC,EAAYI,EAAUlH,EAAM,OAAOA,EAAM,KAAK,CAAC,KAAKqE,EAAa,UAChEyC,EAAYI,EAAUlH,EAAM,OAAOA,EAAM,QAAQA,EAAM,CAAC,EAAE,MAAM,CAAC,KAAKqE,EAAa,QAChFyC,EAAYG,EAAWjH,EAAM,OAAOA,EAAM,QAAQA,EAAM,CAAC,EAAE,MAAM,CAAC,KAAKqE,EAAa;AACpG;AACA,MAAMgC,WAAoBM,GAAU;AAAA,EAChC,UAAU7E,GAAOqF,GAASC,GAAO;AAC7B,QAAIpC,IAASyB,EAAa,KAAK,MAAM3E,GAAOsF,GAAOtF,EAAM,IAAI,MAAM,EAAE,KAAI;AACzE,WAAIkD,EAAO,SACPA,IAASyB,EAAa,KAAK,MAAM3E,GAAO,GAAGqF,CAAO,EAAE,SACjDnC,EAAO,OAAO,OAAOA,EAAO;AAAA,EACtC;AAAA,EACD,iBAAiBlD,GAAO5C,GAAMC,GAAI;AAC9B,aAASyI,IAAO,KAAIA,KAAQ;AACxB,UAAIlI,IAAQ,KAAK;AAAA,QAAIR;AAAA,QAAMC,IAAKyI,IAAO;AAAA;AAAA,SACnC5C,IAASyB,EAAa,KAAK,MAAM3E,GAAOpC,GAAOP,CAAE,GAAGwF,IAAQ;AAChE,aAAO,CAACK,EAAO,KAAI,EAAG;AAClB,QAAAL,IAAQK,EAAO;AACnB,UAAIL,MAAUjF,KAASR,KAAQyF,EAAM,OAAOjF,IAAQ;AAChD,eAAOiF;AACX,UAAIjF,KAASR;AACT,eAAO;AAAA,IACd;AAAA,EACJ;AAAA,EACD,UAAU4C,GAAOqF,GAASC,GAAO;AAC7B,WAAO,KAAK,iBAAiBtF,GAAO,GAAGqF,CAAO,KAC1C,KAAK,iBAAiBrF,GAAOsF,GAAOtF,EAAM,IAAI,MAAM;AAAA,EAC3D;AAAA,EACD,eAAe+F,GAAQ;AACnB,WAAO,KAAK,KAAK,QAAQ,KAAK,KAAK,OAAO,EAAE,QAAQ,gBAAgB,CAACC,GAAGjI,MAAMA,KAAK,MAAM,MACnFA,KAAK,MAAMgI,EAAO,MAAM,CAAC,IACrBhI,KAAK,OAAO,CAACA,IAAIgI,EAAO,MAAM,SAASA,EAAO,MAAMhI,CAAC,IACjDiI,CAAC;AAAA,EAClB;AAAA,EACD,SAAShG,GAAOwF,GAAO;AACnB,QAAItC,IAASyB,EAAa,KAAK,MAAM3E,GAAO,GAAGA,EAAM,IAAI,MAAM,GAAGyD,IAAS,CAAA;AAC3E,WAAO,CAACP,EAAO,KAAM,EAAC,QAAM;AACxB,UAAIO,EAAO,UAAU+B;AACjB,eAAO;AACX,MAAA/B,EAAO,KAAKP,EAAO,KAAK;AAAA,IAC3B;AACD,WAAOO;AAAA,EACV;AAAA,EACD,UAAUzD,GAAO5C,GAAMC,GAAIoI,GAAK;AAC5B,QAAIvC,IAASyB,EAAa,KAAK,MAAM3E,GAAO,KAAK;AAAA,MAAI;AAAA,MAAG5C,IAAO;AAAA;AAAA,OAAmC,KAAK,IAAIC,IAAK,KAAkC2C,EAAM,IAAI,MAAM,CAAC;AACnK,WAAO,CAACkD,EAAO,KAAI,EAAG;AAClB,MAAAuC,EAAIvC,EAAO,MAAM,MAAMA,EAAO,MAAM,EAAE;AAAA,EAC7C;AACL;AAQK,MAAC+C,IAA8B,gBAAAtF,EAAY,OAAS,GACnDuF,IAA2B,gBAAAvF,EAAY,UACvCwF,IAA2B,gBAAAtF,GAAW,OAAO;AAAA,EAC/C,OAAOb,GAAO;AACV,WAAO,IAAIoG,EAAYC,EAAarG,CAAK,EAAE,OAAM,GAAI,IAAI;AAAA,EAC5D;AAAA,EACD,OAAOc,GAAOC,GAAI;AACd,aAASuF,KAAUvF,EAAG;AAClB,MAAIuF,EAAO,GAAGL,CAAc,IACxBnF,IAAQ,IAAIsF,EAAYE,EAAO,MAAM,UAAUxF,EAAM,KAAK,IACrDwF,EAAO,GAAGJ,CAAW,MAC1BpF,IAAQ,IAAIsF,EAAYtF,EAAM,OAAOwF,EAAO,QAAQC,IAAoB,IAAI;AAEpF,WAAOzF;AAAA,EACV;AAAA,EACD,SAAS,CAAAG,MAAKC,GAAU,KAAKD,GAAG,CAAAE,MAAOA,EAAI,KAAK;AACpD,CAAC;AAeD,MAAMiF,EAAY;AAAA,EACd,YAAYjJ,GAAOkE,GAAO;AACtB,SAAK,QAAQlE,GACb,KAAK,QAAQkE;AAAA,EAChB;AACL;AACA,MAAMmF,KAAyB,gBAAArE,EAAW,KAAK,EAAE,OAAO,iBAAkB,CAAA,GAAGsE,KAAiC,gBAAAtE,EAAW,KAAK,EAAE,OAAO,yCAA0C,CAAA,GAC3KuE,KAAiC,gBAAAjE,EAAW,UAAU,MAAM;AAAA,EAC9D,YAAYhD,GAAM;AACd,SAAK,OAAOA,GACZ,KAAK,cAAc,KAAK,UAAUA,EAAK,MAAM,MAAM0G,CAAW,CAAC;AAAA,EAClE;AAAA,EACD,OAAOzD,GAAQ;AACX,QAAI1C,IAAQ0C,EAAO,MAAM,MAAMyD,CAAW;AAC1C,KAAInG,KAAS0C,EAAO,WAAW,MAAMyD,CAAW,KAAKzD,EAAO,cAAcA,EAAO,gBAAgBA,EAAO,qBACpG,KAAK,cAAc,KAAK,UAAU1C,CAAK;AAAA,EAC9C;AAAA,EACD,UAAU,EAAE,OAAA7C,GAAO,OAAAkE,KAAS;AACxB,QAAI,CAACA,KAAS,CAAClE,EAAM,KAAK;AACtB,aAAOgF,EAAW;AACtB,QAAI,EAAE,MAAA1C,EAAM,IAAG,MACXkH,IAAU,IAAIC;AAClB,aAAS,IAAI,GAAGnD,IAAShE,EAAK,eAAeoH,IAAIpD,EAAO,QAAQ,IAAIoD,GAAG,KAAK;AACxE,UAAI,EAAE,MAAAzJ,GAAM,IAAAC,EAAI,IAAGoG,EAAO,CAAC;AAC3B,aAAO,IAAIoD,IAAI,KAAKxJ,IAAKoG,EAAO,IAAI,CAAC,EAAE,OAAO,IAAI;AAC9C,QAAApG,IAAKoG,EAAO,EAAE,CAAC,EAAE;AACrB,MAAAtG,EAAM,UAAUsC,EAAK,OAAOrC,GAAMC,GAAI,CAACD,GAAMC,MAAO;AAChD,YAAIyJ,IAAWrH,EAAK,MAAM,UAAU,OAAO,KAAK,CAAAmE,MAAKA,EAAE,QAAQxG,KAAQwG,EAAE,MAAMvG,CAAE;AACjF,QAAAsJ,EAAQ,IAAIvJ,GAAMC,GAAIyJ,IAAWL,KAAoBD,EAAS;AAAA,MAC9E,CAAa;AAAA,IACJ;AACD,WAAOG,EAAQ;EAClB;AACL,GAAG;AAAA,EACC,aAAa,CAAAxD,MAAKA,EAAE;AACxB,CAAC;AACD,SAAS4D,EAAc9F,GAAG;AACtB,SAAO,CAAAxB,MAAQ;AACX,QAAIO,IAAQP,EAAK,MAAM,MAAM0G,GAAa,EAAK;AAC/C,WAAOnG,KAASA,EAAM,MAAM,KAAK,QAAQiB,EAAExB,GAAMO,CAAK,IAAIgH,GAAgBvH,CAAI;AAAA,EACtF;AACA;AAOK,MAACwH,IAAwB,gBAAAF,EAAc,CAACtH,GAAM,EAAE,OAAAtC,EAAK,MAAO;AAC7D,MAAI,EAAE,IAAAE,EAAE,IAAKoC,EAAK,MAAM,UAAU,MAC9BhC,IAAON,EAAM,UAAUsC,EAAK,OAAOpC,GAAIA,CAAE;AAC7C,MAAI,CAACI;AACD,WAAO;AACX,MAAI+C,IAAYC,EAAgB,OAAOhD,EAAK,MAAMA,EAAK,EAAE,GACrD0G,IAAS1E,EAAK,MAAM,MAAMsE,CAAiB;AAC/C,SAAAtE,EAAK,SAAS;AAAA,IACV,WAAAe;AAAA,IACA,SAAS,CAAC0G,EAAczH,GAAMhC,CAAI,GAAG0G,EAAO,cAAc3D,EAAU,MAAMf,CAAI,CAAC;AAAA,IAC/E,WAAW;AAAA,EACnB,CAAK,GACD0H,GAAkB1H,CAAI,GACf;AACX,CAAC,GAMK2H,IAA4B,gBAAAL,EAAc,CAACtH,GAAM,EAAE,OAAAtC,EAAK,MAAO;AACjE,MAAI,EAAE,OAAA6C,EAAO,IAAGP,GAAM,EAAE,MAAArC,EAAI,IAAK4C,EAAM,UAAU,MAC7CqH,IAAOlK,EAAM,UAAU6C,GAAO5C,GAAMA,CAAI;AAC5C,MAAI,CAACiK;AACD,WAAO;AACX,MAAI7G,IAAYC,EAAgB,OAAO4G,EAAK,MAAMA,EAAK,EAAE,GACrDlD,IAAS1E,EAAK,MAAM,MAAMsE,CAAiB;AAC/C,SAAAtE,EAAK,SAAS;AAAA,IACV,WAAAe;AAAA,IACA,SAAS,CAAC0G,EAAczH,GAAM4H,CAAI,GAAGlD,EAAO,cAAc3D,EAAU,MAAMf,CAAI,CAAC;AAAA,IAC/E,WAAW;AAAA,EACnB,CAAK,GACD0H,GAAkB1H,CAAI,GACf;AACX,CAAC,GAIK6H,KAA6B,gBAAAP,EAAc,CAACtH,GAAM,EAAE,OAAAtC,EAAK,MAAO;AAClE,MAAIsG,IAAStG,EAAM,SAASsC,EAAK,OAAO,GAAI;AAC5C,SAAI,CAACgE,KAAU,CAACA,EAAO,SACZ,MACXhE,EAAK,SAAS;AAAA,IACV,WAAWgB,EAAgB,OAAOgD,EAAO,IAAI,CAAAG,MAAKnD,EAAgB,MAAMmD,EAAE,MAAMA,EAAE,EAAE,CAAC,CAAC;AAAA,IACtF,WAAW;AAAA,EACnB,CAAK,GACM;AACX,CAAC,GAIK2D,KAAyB,CAAC,EAAE,OAAAvH,GAAO,UAAAqD,QAAe;AACpD,MAAIT,IAAM5C,EAAM;AAChB,MAAI4C,EAAI,OAAO,SAAS,KAAKA,EAAI,KAAK;AAClC,WAAO;AACX,MAAI,EAAE,MAAAxF,GAAM,IAAAC,MAAOuF,EAAI,MACnBa,IAAS,CAAA,GAAID,IAAO;AACxB,WAASgE,IAAM,IAAIvK,EAAa+C,EAAM,KAAKA,EAAM,SAAS5C,GAAMC,CAAE,CAAC,GAAG,CAACmK,EAAI,KAAI,EAAG,QAAO;AACrF,QAAI/D,EAAO,SAAS;AAChB,aAAO;AACX,IAAI+D,EAAI,MAAM,QAAQpK,MAClBoG,IAAOC,EAAO,SAClBA,EAAO,KAAKhD,EAAgB,MAAM+G,EAAI,MAAM,MAAMA,EAAI,MAAM,EAAE,CAAC;AAAA,EAClE;AACD,SAAAnE,EAASrD,EAAM,OAAO;AAAA,IAClB,WAAWS,EAAgB,OAAOgD,GAAQD,CAAI;AAAA,IAC9C,WAAW;AAAA,EACd,CAAA,CAAC,GACK;AACX,GAIMiE,IAA2B,gBAAAV,EAAc,CAACtH,GAAM,EAAE,OAAAtC,EAAK,MAAO;AAChE,MAAI,EAAE,OAAA6C,MAAUP,GAAM,EAAE,MAAArC,GAAM,IAAAC,MAAO2C,EAAM,UAAU;AACrD,MAAIA,EAAM;AACN,WAAO;AACX,MAAIvC,IAAON,EAAM,UAAU6C,GAAO5C,GAAMA,CAAI;AAC5C,MAAI,CAACK;AACD,WAAO;AACX,MAAIiK,IAAU,CAAA,GAAIlH,GAAWmH,GACzBpG,IAAU,CAAA;AAOd,MANI9D,EAAK,QAAQL,KAAQK,EAAK,MAAMJ,MAChCsK,IAAc3H,EAAM,OAAO7C,EAAM,eAAeM,CAAI,CAAC,GACrDiK,EAAQ,KAAK,EAAE,MAAMjK,EAAK,MAAM,IAAIA,EAAK,IAAI,QAAQkK,EAAa,CAAA,GAClElK,IAAON,EAAM,UAAU6C,GAAOvC,EAAK,MAAMA,EAAK,EAAE,GAChD8D,EAAQ,KAAKb,EAAW,SAAS,GAAGV,EAAM,OAAO,4BAA4BA,EAAM,IAAI,OAAO5C,CAAI,EAAE,MAAM,IAAI,GAAG,CAAC,IAElHK,GAAM;AACN,QAAIqB,IAAM4I,EAAQ,UAAU,KAAKA,EAAQ,CAAC,EAAE,QAAQjK,EAAK,KAAK,IAAIA,EAAK,KAAKA,EAAK,OAAOkK,EAAY;AACpG,IAAAnH,IAAYC,EAAgB,OAAOhD,EAAK,OAAOqB,GAAKrB,EAAK,KAAKqB,CAAG,GACjEyC,EAAQ,KAAK2F,EAAczH,GAAMhC,CAAI,CAAC,GACtC8D,EAAQ,KAAKvB,EAAM,MAAM+D,CAAiB,EAAE,cAAcvD,EAAU,MAAMf,CAAI,CAAC;AAAA,EAClF;AACD,SAAAA,EAAK,SAAS;AAAA,IACV,SAAAiI;AAAA,IAAS,WAAAlH;AAAA,IAAW,SAAAe;AAAA,IACpB,WAAW;AAAA,EACnB,CAAK,GACM;AACX,CAAC,GAKKqG,KAA0B,gBAAAb,EAAc,CAACtH,GAAM,EAAE,OAAAtC,EAAK,MAAO;AAC/D,MAAIsC,EAAK,MAAM;AACX,WAAO;AACX,MAAIiI,IAAUvK,EAAM,SAASsC,EAAK,OAAO,GAAG,EAAE,IAAI,CAAAvB,MAAS;AACvD,QAAI,EAAE,MAAAd,GAAM,IAAAC,EAAI,IAAGa;AACnB,WAAO,EAAE,MAAAd,GAAM,IAAAC,GAAI,QAAQF,EAAM,eAAee,CAAK;EAC7D,CAAK;AACD,MAAI,CAACwJ,EAAQ;AACT,WAAO;AACX,MAAIG,IAAepI,EAAK,MAAM,OAAO,sBAAsBiI,EAAQ,MAAM,IAAI;AAC7E,SAAAjI,EAAK,SAAS;AAAA,IACV,SAAAiI;AAAA,IACA,SAAShH,EAAW,SAAS,GAAGmH,CAAY;AAAA,IAC5C,WAAW;AAAA,EACnB,CAAK,GACM;AACX,CAAC;AACD,SAAStB,EAAkB9G,GAAM;AAC7B,SAAOA,EAAK,MAAM,MAAMsE,CAAiB,EAAE,YAAYtE,CAAI;AAC/D;AACA,SAAS4G,EAAarG,GAAO8H,GAAU;AACnC,MAAIC,GAAIC,GAAIC,GAAIC,GAAIC;AACpB,MAAIvF,IAAM5C,EAAM,UAAU,MACtBoI,IAAUxF,EAAI,SAASA,EAAI,KAAKA,EAAI,OAAO,MAAM,KAAK5C,EAAM,SAAS4C,EAAI,MAAMA,EAAI,EAAE;AACzF,MAAIkF,KAAY,CAACM;AACb,WAAON;AACX,MAAI3D,IAASnE,EAAM,MAAM+D,CAAiB;AAC1C,SAAO,IAAIG,GAAY;AAAA,IACnB,UAAU6D,IAAKD,KAAa,OAA8B,SAASA,EAAS,aAAa,QAAQC,MAAO,SAASA,IAAK5D,EAAO,WAAWiE,IAAUA,EAAQ,QAAQ,OAAO,KAAK;AAAA,IAC9K,gBAAgBJ,IAAKF,KAAa,OAA8B,SAASA,EAAS,mBAAmB,QAAQE,MAAO,SAASA,IAAK7D,EAAO;AAAA,IACzI,UAAU8D,IAAKH,KAAa,OAA8B,SAASA,EAAS,aAAa,QAAQG,MAAO,SAASA,IAAK9D,EAAO;AAAA,IAC7H,SAAS+D,IAAKJ,KAAa,OAA8B,SAASA,EAAS,YAAY,QAAQI,MAAO,SAASA,IAAK/D,EAAO;AAAA,IAC3H,YAAYgE,IAAKL,KAAa,OAA8B,SAASA,EAAS,eAAe,QAAQK,MAAO,SAASA,IAAKhE,EAAO;AAAA,EACzI,CAAK;AACL;AACA,SAASkE,GAAe5I,GAAM;AAC1B,MAAI4B,IAAQC,EAAS7B,GAAM8G,CAAiB;AAC5C,SAAOlF,KAASA,EAAM,IAAI,cAAc,cAAc;AAC1D;AACA,SAAS8F,GAAkB1H,GAAM;AAC7B,MAAIC,IAAQ2I,GAAe5I,CAAI;AAC/B,EAAIC,KAASA,KAASD,EAAK,KAAK,iBAC5BC,EAAM,OAAM;AACpB;AAIK,MAACsH,KAAkB,CAAAvH,MAAQ;AAC5B,MAAIO,IAAQP,EAAK,MAAM,MAAM0G,GAAa,EAAK;AAC/C,MAAInG,KAASA,EAAM,OAAO;AACtB,QAAIsI,IAAcD,GAAe5I,CAAI;AACrC,QAAI6I,KAAeA,KAAe7I,EAAK,KAAK,eAAe;AACvD,UAAItC,IAAQkJ,EAAa5G,EAAK,OAAOO,EAAM,MAAM,IAAI;AACrD,MAAI7C,EAAM,SACNsC,EAAK,SAAS,EAAE,SAASwG,EAAe,GAAG9I,CAAK,EAAC,CAAE,GACvDmL,EAAY,MAAK,GACjBA,EAAY,OAAM;AAAA,IACrB;AAAA,EACJ;AAEG,IAAA7I,EAAK,SAAS,EAAE,SAAS;AAAA,MACjByG,EAAY,GAAG,EAAI;AAAA,MACnBlG,IAAQiG,EAAe,GAAGI,EAAa5G,EAAK,OAAOO,EAAM,MAAM,IAAI,CAAC,IAAIW,EAAY,aAAa,GAAG4H,EAAgB;AAAA,IACvH,EAAA,CAAE;AAEX,SAAO;AACX,GAIMC,KAAmB,CAAA/I,MAAQ;AAC7B,MAAIO,IAAQP,EAAK,MAAM,MAAM0G,GAAa,EAAK;AAC/C,MAAI,CAACnG,KAAS,CAACA,EAAM;AACjB,WAAO;AACX,MAAIqB,IAAQC,EAAS7B,GAAM8G,CAAiB;AAC5C,SAAIlF,KAASA,EAAM,IAAI,SAAS5B,EAAK,KAAK,aAAa,KACnDA,EAAK,MAAK,GACdA,EAAK,SAAS,EAAE,SAASyG,EAAY,GAAG,EAAK,EAAC,CAAE,GACzC;AACX,GAUMuC,KAAe;AAAA,EACjB,EAAE,KAAK,SAAS,KAAKzB,IAAiB,OAAO,sBAAuB;AAAA,EACpE,EAAE,KAAK,MAAM,KAAKC,GAAU,OAAOG,GAAc,OAAO,uBAAuB,gBAAgB,GAAM;AAAA,EACrG,EAAE,KAAK,SAAS,KAAKH,GAAU,OAAOG,GAAc,OAAO,uBAAuB,gBAAgB,GAAM;AAAA,EACxG,EAAE,KAAK,UAAU,KAAKoB,IAAkB,OAAO,sBAAuB;AAAA,EACtE,EAAE,KAAK,eAAe,KAAKjB,GAAwB;AAAA,EACnD,EAAE,KAAK,aAAa,KAAKnG,GAAU;AAAA,EACnC,EAAE,KAAK,SAAS,KAAKyC,IAAsB,gBAAgB,GAAM;AACrE;AACA,MAAMI,GAAY;AAAA,EACd,YAAYxE,GAAM;AACd,SAAK,OAAOA;AACZ,QAAItC,IAAQ,KAAK,QAAQsC,EAAK,MAAM,MAAM0G,CAAW,EAAE,MAAM;AAC7D,SAAK,SAAS,KAAK,OAAO,KAAK,IAAI,GACnC,KAAK,cAAcxG,EAAI,SAAS;AAAA,MAC5B,OAAOxC,EAAM;AAAA,MACb,aAAauL,EAAOjJ,GAAM,MAAM;AAAA,MAChC,cAAciJ,EAAOjJ,GAAM,MAAM;AAAA,MACjC,OAAO;AAAA,MACP,MAAM;AAAA,MACN,MAAM;AAAA,MACN,cAAc;AAAA,MACd,UAAU,KAAK;AAAA,MACf,SAAS,KAAK;AAAA,IAC1B,CAAS,GACD,KAAK,eAAeE,EAAI,SAAS;AAAA,MAC7B,OAAOxC,EAAM;AAAA,MACb,aAAauL,EAAOjJ,GAAM,SAAS;AAAA,MACnC,cAAciJ,EAAOjJ,GAAM,SAAS;AAAA,MACpC,OAAO;AAAA,MACP,MAAM;AAAA,MACN,MAAM;AAAA,MACN,UAAU,KAAK;AAAA,MACf,SAAS,KAAK;AAAA,IAC1B,CAAS,GACD,KAAK,YAAYE,EAAI,SAAS;AAAA,MAC1B,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAASxC,EAAM;AAAA,MACf,UAAU,KAAK;AAAA,IAC3B,CAAS,GACD,KAAK,UAAUwC,EAAI,SAAS;AAAA,MACxB,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAASxC,EAAM;AAAA,MACf,UAAU,KAAK;AAAA,IAC3B,CAAS,GACD,KAAK,YAAYwC,EAAI,SAAS;AAAA,MAC1B,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAASxC,EAAM;AAAA,MACf,UAAU,KAAK;AAAA,IAC3B,CAAS;AACD,aAASwL,EAAOC,GAAMC,GAASC,GAAS;AACpC,aAAOnJ,EAAI,UAAU,EAAE,OAAO,aAAa,MAAAiJ,GAAM,SAAAC,GAAS,MAAM,SAAU,GAAEC,CAAO;AAAA,IACtF;AACD,SAAK,MAAMnJ,EAAI,OAAO,EAAE,WAAW,CAACqB,MAAM,KAAK,QAAQA,CAAC,GAAG,OAAO,YAAW,GAAI;AAAA,MAC7E,KAAK;AAAA,MACL2H,EAAO,QAAQ,MAAM1B,EAASxH,CAAI,GAAG,CAACiJ,EAAOjJ,GAAM,MAAM,CAAC,CAAC;AAAA,MAC3DkJ,EAAO,QAAQ,MAAMvB,EAAa3H,CAAI,GAAG,CAACiJ,EAAOjJ,GAAM,UAAU,CAAC,CAAC;AAAA,MACnEkJ,EAAO,UAAU,MAAMrB,GAAc7H,CAAI,GAAG,CAACiJ,EAAOjJ,GAAM,KAAK,CAAC,CAAC;AAAA,MACjEE,EAAI,SAAS,MAAM,CAAC,KAAK,WAAW+I,EAAOjJ,GAAM,YAAY,CAAC,CAAC;AAAA,MAC/DE,EAAI,SAAS,MAAM,CAAC,KAAK,SAAS+I,EAAOjJ,GAAM,QAAQ,CAAC,CAAC;AAAA,MACzDE,EAAI,SAAS,MAAM,CAAC,KAAK,WAAW+I,EAAOjJ,GAAM,SAAS,CAAC,CAAC;AAAA,MAC5D,GAAGA,EAAK,MAAM,WAAW,KAAK;AAAA,QAC1BE,EAAI,IAAI;AAAA,QACR,KAAK;AAAA,QACLgJ,EAAO,WAAW,MAAMlB,EAAYhI,CAAI,GAAG,CAACiJ,EAAOjJ,GAAM,SAAS,CAAC,CAAC;AAAA,QACpEkJ,EAAO,cAAc,MAAMf,GAAWnI,CAAI,GAAG,CAACiJ,EAAOjJ,GAAM,aAAa,CAAC,CAAC;AAAA,MAC7E;AAAA,MACDE,EAAI,UAAU;AAAA,QACV,MAAM;AAAA,QACN,SAAS,MAAM6I,GAAiB/I,CAAI;AAAA,QACpC,cAAciJ,EAAOjJ,GAAM,OAAO;AAAA,QAClC,MAAM;AAAA,MACtB,GAAe,CAAC,GAAG,CAAC;AAAA,IACpB,CAAS;AAAA,EACJ;AAAA,EACD,SAAS;AACL,QAAItC,IAAQ,IAAI+G,GAAY;AAAA,MACxB,QAAQ,KAAK,YAAY;AAAA,MACzB,eAAe,KAAK,UAAU;AAAA,MAC9B,QAAQ,KAAK,QAAQ;AAAA,MACrB,WAAW,KAAK,UAAU;AAAA,MAC1B,SAAS,KAAK,aAAa;AAAA,IACvC,CAAS;AACD,IAAK/G,EAAM,GAAG,KAAK,KAAK,MACpB,KAAK,QAAQA,GACb,KAAK,KAAK,SAAS,EAAE,SAAS8I,EAAe,GAAG9I,CAAK,EAAC,CAAE;AAAA,EAE/D;AAAA,EACD,QAAQ,GAAG;AACP,IAAI4L,GAAiB,KAAK,MAAM,GAAG,cAAc,IAC7C,EAAE,eAAc,IAEX,EAAE,WAAW,MAAM,EAAE,UAAU,KAAK,eACzC,EAAE,eAAc,IACf,EAAE,WAAW3B,IAAeH,GAAU,KAAK,IAAI,KAE3C,EAAE,WAAW,MAAM,EAAE,UAAU,KAAK,iBACzC,EAAE,eAAc,GAChBQ,EAAY,KAAK,IAAI;AAAA,EAE5B;AAAA,EACD,OAAO/E,GAAQ;AACX,aAAS3B,KAAM2B,EAAO;AAClB,eAAS4D,KAAUvF,EAAG;AAClB,QAAIuF,EAAO,GAAGL,CAAc,KAAK,CAACK,EAAO,MAAM,GAAG,KAAK,KAAK,KACxD,KAAK,SAASA,EAAO,KAAK;AAAA,EAEzC;AAAA,EACD,SAASnJ,GAAO;AACZ,SAAK,QAAQA,GACb,KAAK,YAAY,QAAQA,EAAM,QAC/B,KAAK,aAAa,QAAQA,EAAM,SAChC,KAAK,UAAU,UAAUA,EAAM,eAC/B,KAAK,QAAQ,UAAUA,EAAM,QAC7B,KAAK,UAAU,UAAUA,EAAM;AAAA,EAClC;AAAA,EACD,QAAQ;AACJ,SAAK,YAAY;EACpB;AAAA,EACD,IAAI,MAAM;AAAE,WAAO;AAAA,EAAK;AAAA,EACxB,IAAI,MAAM;AAAE,WAAO,KAAK,KAAK,MAAM,MAAM4G,CAAiB,EAAE;AAAA,EAAM;AACtE;AACA,SAAS2E,EAAOjJ,GAAMiJ,GAAQ;AAAE,SAAOjJ,EAAK,MAAM,OAAOiJ,CAAM;AAAI;AACnE,MAAMM,IAAiB,IACjBC,IAAQ;AACd,SAAS/B,EAAczH,GAAM,EAAE,MAAArC,GAAM,IAAAC,EAAE,GAAI;AACvC,MAAIkC,IAAOE,EAAK,MAAM,IAAI,OAAOrC,CAAI,GAAG8L,IAAUzJ,EAAK,MAAM,IAAI,OAAOpC,CAAE,EAAE,IACxEO,IAAQ,KAAK,IAAI2B,EAAK,MAAMnC,IAAO4L,CAAc,GAAG7K,IAAM,KAAK,IAAI+K,GAAS7L,IAAK2L,CAAc,GAC/F9L,IAAOuC,EAAK,MAAM,SAAS7B,GAAOO,CAAG;AACzC,MAAIP,KAAS2B,EAAK;AACd,aAASxB,IAAI,GAAGA,IAAIiL,GAAgBjL;AAChC,UAAI,CAACkL,EAAM,KAAK/L,EAAKa,IAAI,CAAC,CAAC,KAAKkL,EAAM,KAAK/L,EAAKa,CAAC,CAAC,GAAG;AACjD,QAAAb,IAAOA,EAAK,MAAMa,CAAC;AACnB;AAAA,MACH;AAAA;AAET,MAAII,KAAO+K;AACP,aAASnL,IAAIb,EAAK,SAAS,GAAGa,IAAIb,EAAK,SAAS8L,GAAgBjL;AAC5D,UAAI,CAACkL,EAAM,KAAK/L,EAAKa,IAAI,CAAC,CAAC,KAAKkL,EAAM,KAAK/L,EAAKa,CAAC,CAAC,GAAG;AACjD,QAAAb,IAAOA,EAAK,MAAM,GAAGa,CAAC;AACtB;AAAA,MACH;AAAA;AAET,SAAO2C,EAAW,SAAS,GAAG,GAAGjB,EAAK,MAAM,OAAO,eAAe,CAAC,KAAKvC,CAAI,IAAIuC,EAAK,MAAM,OAAO,SAAS,CAAC,IAAIF,EAAK,MAAM,GAAG;AAClI;AACA,MAAM4J,KAAyB,gBAAAzI,EAAW,UAAU;AAAA,EAChD,uBAAuB;AAAA,IACnB,SAAS;AAAA,IACT,UAAU;AAAA,IACV,kBAAkB;AAAA,MACd,UAAU;AAAA,MACV,KAAK;AAAA,MACL,OAAO;AAAA,MACP,iBAAiB;AAAA,MACjB,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,IACX;AAAA,IACD,8BAA8B;AAAA,MAC1B,QAAQ;AAAA,IACX;AAAA,IACD,0BAA0B;AAAA,MACtB,aAAa;AAAA,IAChB;AAAA,IACD,WAAW;AAAA,MACP,UAAU;AAAA,MACV,YAAY;AAAA,IACf;AAAA,EACJ;AAAA,EACD,0BAA0B,EAAE,iBAAiB,YAAa;AAAA,EAC1D,yBAAyB,EAAE,iBAAiB,YAAa;AAAA,EACzD,mCAAmC,EAAE,iBAAiB,YAAa;AAAA,EACnE,kCAAkC,EAAE,iBAAiB,YAAa;AACtE,CAAC,GACK6H,KAAmB;AAAA,EACrBpC;AAAA,EACa,gBAAAiD,GAAK,IAAI1C,EAAiB;AAAA,EACvCyC;AACJ;","x_google_ignoreList":[0]}