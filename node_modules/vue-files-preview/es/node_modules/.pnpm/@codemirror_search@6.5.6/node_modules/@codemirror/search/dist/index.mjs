import { ViewPlugin as Z, Decoration as d, EditorView as x, getPanel as R, showPanel as ee, runScopeHandlers as me } from "../../../../../@codemirror_view@6.33.0/node_modules/@codemirror/view/dist/index.mjs";
import { codePointAt as pe, codePointSize as ge, StateEffect as W, Facet as te, combineConfig as re, CharCategory as m, EditorSelection as p, Prec as xe, fromCodePoint as Se, StateField as ne, EditorState as ye, findClusterBreak as ie, RangeSetBuilder as Me } from "../../../../../@codemirror_state@6.4.1/node_modules/@codemirror/state/dist/index.mjs";
import h from "../../../../../crelt@1.0.6/node_modules/crelt/index.mjs";
const J = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class b {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, r, n = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(n, i), this.bufferStart = n, this.normalize = s ? (l) => s(J(l)) : J, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return pe(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let r = Se(e), n = this.bufferStart + this.bufferPos;
      this.bufferPos += ge(e);
      let i = this.normalize(r);
      for (let s = 0, o = n; ; s++) {
        let l = i.charCodeAt(s), c = this.match(l, o, this.bufferPos + this.bufferStart);
        if (s == i.length - 1) {
          if (c)
            return this.value = c, this;
          break;
        }
        o == n && s < r.length && r.charCodeAt(s) == l && o++;
      }
    }
  }
  match(e, r, n) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], l = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = { from: this.matches[s + 1], to: n } : (this.matches[s]++, l = !0)), l || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: r, to: n } : this.matches.push(1, r)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (b.prototype[Symbol.iterator] = function() {
  return this;
});
const se = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, N = "gm" + (/x/.unicode == null ? "" : "u");
class le {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, r, n, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = se, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new oe(e, r, n, i, s);
    this.re = new RegExp(r, N + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = q(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let n = this.curLineStart + r.index, i = n + r[0].length;
        if (this.matchPos = q(this.text, i + (n == i ? 1 : 0)), n == this.curLineStart + this.curLine.length && this.nextLine(), (n < i || n > this.value.to) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Q = /* @__PURE__ */ new WeakMap();
class v {
  constructor(e, r) {
    this.from = e, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, n) {
    let i = Q.get(e);
    if (!i || i.from >= n || i.to <= r) {
      let l = new v(r, e.sliceString(r, n));
      return Q.set(e, l), l;
    }
    if (i.from == r && i.to == n)
      return i;
    let { text: s, from: o } = i;
    return o > r && (s = e.sliceString(r, o) + s, o = r), i.to < n && (s += e.sliceString(i.to, n)), Q.set(e, new v(o, s)), new v(r, s.slice(r - o, n - o));
  }
}
class oe {
  constructor(e, r, n, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = se, this.matchPos = q(e, i), this.re = new RegExp(r, N + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.flat = v.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == e && (this.re.lastIndex = e + 1, r = this.re.exec(this.flat.text)), r) {
        let n = this.flat.from + r.index, i = n + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this.matchPos = q(this.text, i + (n == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = v.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (le.prototype[Symbol.iterator] = oe.prototype[Symbol.iterator] = function() {
  return this;
});
function ve(t) {
  try {
    return new RegExp(t, N), !0;
  } catch {
    return !1;
  }
}
function q(t, e) {
  if (e >= t.length)
    return e;
  let r = t.lineAt(e), n;
  for (; e < r.to && (n = r.text.charCodeAt(e - r.from)) >= 56320 && n < 57344; )
    e++;
  return e;
}
function _(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), r = h("input", { class: "cm-textfield", name: "line", value: e }), n = h("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), t.dispatch({ effects: P.of(!1) }), t.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, h("label", t.state.phrase("Go to line"), ": ", r), " ", h("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!s)
      return;
    let { state: o } = t, l = o.doc.lineAt(o.selection.main.head), [, c, a, u, g] = s, A = u ? +u.slice(1) : 0, k = a ? +a : l.number;
    if (a && g) {
      let O = k / 100;
      c && (O = O * (c == "-" ? -1 : 1) + l.number / o.doc.lines), k = Math.round(o.doc.lines * O);
    } else a && c && (k = k * (c == "-" ? -1 : 1) + l.number);
    let G = o.doc.line(Math.max(1, Math.min(o.doc.lines, k))), j = p.cursor(G.from + Math.max(0, Math.min(A, G.length)));
    t.dispatch({
      effects: [P.of(!1), x.scrollIntoView(j.from, { y: "center" })],
      selection: j
    }), t.focus();
  }
  return { dom: n };
}
const P = /* @__PURE__ */ W.define(), U = /* @__PURE__ */ ne.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(P) && (t = r.value);
    return t;
  },
  provide: (t) => ee.from(t, (e) => e ? _ : null)
}), be = (t) => {
  let e = R(t, _);
  if (!e) {
    let r = [P.of(!0)];
    t.state.field(U, !1) == null && r.push(W.appendConfig.of([U, Ce])), t.dispatch({ effects: r }), e = R(t, _);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, Ce = /* @__PURE__ */ x.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), ke = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, Le = /* @__PURE__ */ te.define({
  combine(t) {
    return re(t, ke, {
      highlightWordAroundCursor: (e, r) => e || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Ue(t) {
  return [Ee, De];
}
const We = /* @__PURE__ */ d.mark({ class: "cm-selectionMatch" }), Fe = /* @__PURE__ */ d.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function X(t, e, r, n) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != m.Word) && (n == e.doc.length || t(e.sliceDoc(n, n + 1)) != m.Word);
}
function Ae(t, e, r, n) {
  return t(e.sliceDoc(r, r + 1)) == m.Word && t(e.sliceDoc(n - 1, n)) == m.Word;
}
const De = /* @__PURE__ */ Z.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(Le), { state: r } = t, n = r.selection;
    if (n.ranges.length > 1)
      return d.none;
    let i = n.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return d.none;
      let c = r.wordAt(i.head);
      if (!c)
        return d.none;
      o = r.charCategorizer(i.head), s = r.sliceDoc(c.from, c.to);
    } else {
      let c = i.to - i.from;
      if (c < e.minSelectionLength || c > 200)
        return d.none;
      if (e.wholeWords) {
        if (s = r.sliceDoc(i.from, i.to), o = r.charCategorizer(i.head), !(X(o, r, i.from, i.to) && Ae(o, r, i.from, i.to)))
          return d.none;
      } else if (s = r.sliceDoc(i.from, i.to), !s)
        return d.none;
    }
    let l = [];
    for (let c of t.visibleRanges) {
      let a = new b(r.doc, s, c.from, c.to);
      for (; !a.next().done; ) {
        let { from: u, to: g } = a.value;
        if ((!o || X(o, r, u, g)) && (i.empty && u <= i.from && g >= i.to ? l.push(Fe.range(u, g)) : (u >= i.to || g <= i.from) && l.push(We.range(u, g)), l.length > e.maxMatches))
          return d.none;
      }
    }
    return d.set(l);
  }
}, {
  decorations: (t) => t.decorations
}), Ee = /* @__PURE__ */ x.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Re = ({ state: t, dispatch: e }) => {
  let { selection: r } = t, n = p.create(r.ranges.map((i) => t.wordAt(i.head) || p.cursor(i.head)), r.mainIndex);
  return n.eq(r) ? !1 : (e(t.update({ selection: n })), !0);
};
function qe(t, e) {
  let { main: r, ranges: n } = t.selection, i = t.wordAt(r.head), s = i && i.from == r.from && i.to == r.to;
  for (let o = !1, l = new b(t.doc, e, n[n.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new b(t.doc, e, 0, Math.max(0, n[n.length - 1].from - 1)), o = !0;
    } else {
      if (o && n.some((c) => c.from == l.value.from))
        continue;
      if (s) {
        let c = t.wordAt(l.value.from);
        if (!c || c.from != l.value.from || c.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const Pe = ({ state: t, dispatch: e }) => {
  let { ranges: r } = t.selection;
  if (r.some((s) => s.from === s.to))
    return Re({ state: t, dispatch: e });
  let n = t.sliceDoc(r[0].from, r[0].to);
  if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != n))
    return !1;
  let i = qe(t, n);
  return i ? (e(t.update({
    selection: t.selection.addRange(p.range(i.from, i.to), !1),
    effects: x.scrollIntoView(i.to)
  })), !0) : !1;
}, C = /* @__PURE__ */ te.define({
  combine(t) {
    return re(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new Ve(e),
      scrollToMatch: (e) => x.scrollIntoView(e)
    });
  }
});
class ce {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || ve(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (r, n) => n == "n" ? `
` : n == "r" ? "\r" : n == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new $e(this) : new Ie(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, r = 0, n) {
    let i = e.doc ? e : ye.create({ doc: e });
    return n == null && (n = i.doc.length), this.regexp ? M(this, i, r, n) : y(this, i, r, n);
  }
}
class ae {
  constructor(e) {
    this.spec = e;
  }
}
function y(t, e, r, n) {
  return new b(e.doc, t.unquoted, r, n, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? Te(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function Te(t, e) {
  return (r, n, i, s) => ((s > r || s + i.length < n) && (s = Math.max(0, r - 2), i = t.sliceString(s, Math.min(t.length, n + 2))), (e(T(i, r - s)) != m.Word || e(I(i, r - s)) != m.Word) && (e(I(i, n - s)) != m.Word || e(T(i, n - s)) != m.Word));
}
class Ie extends ae {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, n) {
    let i = y(this.spec, e, n, e.doc.length).nextOverlapping();
    return i.done && (i = y(this.spec, e, 0, r).nextOverlapping()), i.done ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, r, n) {
    for (let i = n; ; ) {
      let s = Math.max(r, i - 1e4 - this.spec.unquoted.length), o = y(this.spec, e, s, i), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == r)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let n = y(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = y(this.spec, e, Math.max(0, r - this.spec.unquoted.length), Math.min(n + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function M(t, e, r, n) {
  return new le(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? we(e.charCategorizer(e.selection.main.head)) : void 0
  }, r, n);
}
function T(t, e) {
  return t.slice(ie(t, e, !1), e);
}
function I(t, e) {
  return t.slice(e, ie(t, e));
}
function we(t) {
  return (e, r, n) => !n[0].length || (t(T(n.input, n.index)) != m.Word || t(I(n.input, n.index)) != m.Word) && (t(I(n.input, n.index + n[0].length)) != m.Word || t(T(n.input, n.index + n[0].length)) != m.Word);
}
class $e extends ae {
  nextMatch(e, r, n) {
    let i = M(this.spec, e, n, e.doc.length).next();
    return i.done && (i = M(this.spec, e, 0, r).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, r, n) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        r,
        n - i * 1e4
        /* FindPrev.ChunkSize */
      ), o = M(this.spec, e, s, n), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == r || l.from > s + 10))
        return l;
      if (s == r)
        return null;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (r, n) => n == "$" ? "$" : n == "&" ? e.match[0] : n != "0" && +n < e.match.length ? e.match[n] : r);
  }
  matchAll(e, r) {
    let n = M(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = M(this.spec, e, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(n + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const L = /* @__PURE__ */ W.define(), V = /* @__PURE__ */ W.define(), S = /* @__PURE__ */ ne.define({
  create(t) {
    return new z(B(t).create(), null);
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(L) ? t = new z(r.value.create(), t.panel) : r.is(V) && (t = new z(t.query, r.value ? H : null));
    return t;
  },
  provide: (t) => ee.from(t, (e) => e.panel)
});
class z {
  constructor(e, r) {
    this.query = e, this.panel = r;
  }
}
const Oe = /* @__PURE__ */ d.mark({ class: "cm-searchMatch" }), Qe = /* @__PURE__ */ d.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), ze = /* @__PURE__ */ Z.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(S));
  }
  update(t) {
    let e = t.state.field(S);
    (e != t.startState.field(S) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return d.none;
    let { view: r } = this, n = new Me();
    for (let i = 0, s = r.visibleRanges, o = s.length; i < o; i++) {
      let { from: l, to: c } = s[i];
      for (; i < o - 1 && c > s[i + 1].from - 2 * 250; )
        c = s[++i].to;
      t.highlight(r.state, l, c, (a, u) => {
        let g = r.state.selection.ranges.some((A) => A.from == a && A.to == u);
        n.add(a, u, g ? Qe : Oe);
      });
    }
    return n.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function F(t) {
  return (e) => {
    let r = e.state.field(S, !1);
    return r && r.query.spec.valid ? t(e, r) : fe(e);
  };
}
const w = /* @__PURE__ */ F((t, { query: e }) => {
  let { to: r } = t.state.selection.main, n = e.nextMatch(t.state, r, r);
  if (!n)
    return !1;
  let i = p.single(n.from, n.to), s = t.state.facet(C);
  return t.dispatch({
    selection: i,
    effects: [K(t, n), s.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), ue(t), !0;
}), $ = /* @__PURE__ */ F((t, { query: e }) => {
  let { state: r } = t, { from: n } = r.selection.main, i = e.prevMatch(r, n, n);
  if (!i)
    return !1;
  let s = p.single(i.from, i.to), o = t.state.facet(C);
  return t.dispatch({
    selection: s,
    effects: [K(t, i), o.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), ue(t), !0;
}), _e = /* @__PURE__ */ F((t, { query: e }) => {
  let r = e.matchAll(t.state, 1e3);
  return !r || !r.length ? !1 : (t.dispatch({
    selection: p.create(r.map((n) => p.range(n.from, n.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Be = ({ state: t, dispatch: e }) => {
  let r = t.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return !1;
  let { from: n, to: i } = r.main, s = [], o = 0;
  for (let l = new b(t.doc, t.sliceDoc(n, i)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == n && (o = s.length), s.push(p.range(l.value.from, l.value.to));
  }
  return e(t.update({
    selection: p.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, Y = /* @__PURE__ */ F((t, { query: e }) => {
  let { state: r } = t, { from: n, to: i } = r.selection.main;
  if (r.readOnly)
    return !1;
  let s = e.nextMatch(r, n, n);
  if (!s)
    return !1;
  let o = [], l, c, a = [];
  if (s.from == n && s.to == i && (c = r.toText(e.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: c }), s = e.nextMatch(r, s.from, s.to), a.push(x.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(n).number) + "."))), s) {
    let u = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - c.length;
    l = p.single(s.from - u, s.to - u), a.push(K(t, s)), a.push(r.facet(C).scrollToMatch(l.main, t));
  }
  return t.dispatch({
    changes: o,
    selection: l,
    effects: a,
    userEvent: "input.replace"
  }), !0;
}), Ne = /* @__PURE__ */ F((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let r = e.matchAll(t.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!r.length)
    return !1;
  let n = t.state.phrase("replaced $ matches", r.length) + ".";
  return t.dispatch({
    changes: r,
    effects: x.announce.of(n),
    userEvent: "input.replace.all"
  }), !0;
});
function H(t) {
  return t.state.facet(C).createPanel(t);
}
function B(t, e) {
  var r, n, i, s, o;
  let l = t.selection.main, c = l.empty || l.to > l.from + 100 ? "" : t.sliceDoc(l.from, l.to);
  if (e && !c)
    return e;
  let a = t.facet(C);
  return new ce({
    search: ((r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : a.literal) ? c : c.replace(/\n/g, "\\n"),
    caseSensitive: (n = e == null ? void 0 : e.caseSensitive) !== null && n !== void 0 ? n : a.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : a.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : a.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : a.wholeWord
  });
}
function he(t) {
  let e = R(t, H);
  return e && e.dom.querySelector("[main-field]");
}
function ue(t) {
  let e = he(t);
  e && e == t.root.activeElement && e.select();
}
const fe = (t) => {
  let e = t.state.field(S, !1);
  if (e && e.panel) {
    let r = he(t);
    if (r && r != t.root.activeElement) {
      let n = B(t.state, e.query.spec);
      n.valid && t.dispatch({ effects: L.of(n) }), r.focus(), r.select();
    }
  } else
    t.dispatch({ effects: [
      V.of(!0),
      e ? L.of(B(t.state, e.query.spec)) : W.appendConfig.of(Ke)
    ] });
  return !0;
}, de = (t) => {
  let e = t.state.field(S, !1);
  if (!e || !e.panel)
    return !1;
  let r = R(t, H);
  return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: V.of(!1) }), !0;
}, Xe = [
  { key: "Mod-f", run: fe, scope: "editor search-panel" },
  { key: "F3", run: w, shift: $, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: w, shift: $, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: de, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Be },
  { key: "Mod-Alt-g", run: be },
  { key: "Mod-d", run: Pe, preventDefault: !0 }
];
class Ve {
  constructor(e) {
    this.view = e;
    let r = this.query = e.state.field(S).query.spec;
    this.commit = this.commit.bind(this), this.searchField = h("input", {
      value: r.search,
      placeholder: f(e, "Find"),
      "aria-label": f(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = h("input", {
      value: r.replace,
      placeholder: f(e, "Replace"),
      "aria-label": f(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = h("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = h("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = h("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function n(i, s, o) {
      return h("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = h("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      n("next", () => w(e), [f(e, "next")]),
      n("prev", () => $(e), [f(e, "previous")]),
      n("select", () => _e(e), [f(e, "all")]),
      h("label", null, [this.caseField, f(e, "match case")]),
      h("label", null, [this.reField, f(e, "regexp")]),
      h("label", null, [this.wordField, f(e, "by word")]),
      ...e.state.readOnly ? [] : [
        h("br"),
        this.replaceField,
        n("replace", () => Y(e), [f(e, "replace")]),
        n("replaceAll", () => Ne(e), [f(e, "replace all")])
      ],
      h("button", {
        name: "close",
        onclick: () => de(e),
        "aria-label": f(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new ce({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: L.of(e) }));
  }
  keydown(e) {
    me(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? $ : w)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Y(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let n of r.effects)
        n.is(L) && !n.value.eq(this.query) && this.setQuery(n.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(C).top;
  }
}
function f(t, e) {
  return t.state.phrase(e);
}
const D = 30, E = /[\s\.,:;?!]/;
function K(t, { from: e, to: r }) {
  let n = t.state.doc.lineAt(e), i = t.state.doc.lineAt(r).to, s = Math.max(n.from, e - D), o = Math.min(i, r + D), l = t.state.sliceDoc(s, o);
  if (s != n.from) {
    for (let c = 0; c < D; c++)
      if (!E.test(l[c + 1]) && E.test(l[c])) {
        l = l.slice(c);
        break;
      }
  }
  if (o != i) {
    for (let c = l.length - 1; c > l.length - D; c--)
      if (!E.test(l[c - 1]) && E.test(l[c])) {
        l = l.slice(0, c);
        break;
      }
  }
  return x.announce.of(`${t.state.phrase("current match")}. ${l} ${t.state.phrase("on line")} ${n.number}.`);
}
const He = /* @__PURE__ */ x.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), Ke = [
  S,
  /* @__PURE__ */ xe.low(ze),
  He
];
export {
  le as RegExpCursor,
  b as SearchCursor,
  ce as SearchQuery,
  de as closeSearchPanel,
  w as findNext,
  $ as findPrevious,
  be as gotoLine,
  Ue as highlightSelectionMatches,
  fe as openSearchPanel,
  Ne as replaceAll,
  Y as replaceNext,
  Xe as searchKeymap,
  _e as selectMatches,
  Pe as selectNextOccurrence,
  Be as selectSelectionMatches,
  L as setSearchQuery
};
//# sourceMappingURL=index.mjs.map
